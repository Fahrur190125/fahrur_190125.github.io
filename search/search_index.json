{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-\\.]+"},"docs":[{"location":"","text":"INTEGRASI NUMERIK \u00b6 A. Definisi Integrasi Numerik \u00b6 \u200b Integrasi numerik merupakan metode penyelesaian integral yang digunakan oleh ilmuwan agar memperoleh jawaban aproksimasi dari integral yang tidak dapat diselesaikan secara analitik yang didasarkan pada perhitungan perkiraan. 1 Dari pengertian tersebut dapat disimpulkan bahwa integrasi numerik dapat dilakukan apabila : Integral sulit/tidak dapat diselesaikan secara analitik, Fungsi yang diintegralkan yang diberikan berbentuk angka/tabel. 2 \u200b Metode numerik dilakukan untuk mencoba lebih cepat dan lebih mendekati jawaban eksak dengan cara melakukan penintegralan pada bagian - bagian kecil. Dalam kalkulus perhitungan integral adalah perhitungan dasar yang digunakan dalam banyak hal. Perhitungan dilakukan dengan cara membagi luasan dalam beberapa pias kecil yang dibatasi oleh fungsi y = f(x) dan sumbu x . Kemudian luas totalnya adalah jumlah dari luas semua pias. 1 \u200b Secara umum integral fungsi y(x) dapat dinyatakan sebagai berikut. I = \\int^{b}_{x=a} y(x) dx \u200b Persamaan diatas dapat diartikan sebagai integral dari fungsi y(x) terhadap peubah bebas x yang dievaluasi mulai dari x = a hingga x = b . Pendekatan numerik terhadap persamaan integral tersebut dapat dinyatakan sebagai berikut. 3 I = \\sum ^{N}_{i=1}w_{i}y\\left( x_{i}\\right) \u200b Dengan N menyatakan jumlah segmen, y(x_{i}) = y(a) dan y(x_{n}) = y(b) . Pendekatan numerik pada integral diatas merupakan penjumlahan dari deret suku-suku dengan titik-titik x_{i} yang terbentang dari x = a hingga x = b dan di setiap titik x_{i} dievaluasi menjadi fungsi y(x) . Faktor x_{i} ini biasanya disebut sebagai titik simpul ( node ). sedangkan faktor pengali w_{i} disebut faktor bobot. 3 B. Metode Integrasi Numerik \u00b6 \u200b Untuk menyelesaikan integrasi numerik terdapat beberapa metode diantaranya sebagai berikut. 1. Metode Trapesium \u00b6 \u200b Sesuai dengan namanya metode trapesium merupakan metode integrasi numerik yang didasarkan pada penjumlahan pias/segmen berbentuk trapesium 3 . Dalam metode ini grafik lengkung dari fungsi f(x) digantikan oleh garis lurus. Luasan bidang di bawah fungsi f(x) antara x = a hingga x = b pada gambar di bawah didekati oleh luas trapesium di bawah garis lurus yang menghubungkan f(a) dan f(b) . 2 \u200b Penggunaan garis lurus untuk mendekati grafik lengkung ini menyebabkan terjadinya kesalahan sebesar luasan yang tidak diarsir 2 . Apabila sebuah integral diselesaikan dengan menggunakan metode trapesium satu segmen saja, maka dapat dituliskan sebagai berikut. \\int^{a}_{b} f(x) dx =I= \\dfrac{b-a}{2}[f(a) + f(b)] Keterangan : I = Hasil pengintegralan f(x) = Fungsi yang diintegralkan a = Batas atas integral b = Batas bawah integral Untuk lebih jelasnya perhatikan contoh berikut. Tentukan nilai aproksimasi integral dari fungsi f(x) = 4x^{3} dari x = 0 hingga x = 4 dengan menggunakan metode trapesium. jawab: Jika dikerjakan secara analitik, maka hasilnya sebagai berikut. \\int^{4}_{0} 4x^{3} dx = x^{4}I^{4}_{0} = 4^{4} - 4^{0} = 256 - 0 = 256 Sedangkan jika dikerjakan dengan menggunakan metode trapesium hasilnya sebagai berikut. \\int^{4}_{0} 4x^{3} dx = \\dfrac{4-0}{2}[4\\times0^{3} + 4\\times4^{3}] =2[4\\times0 + 4\\times64] = 2[0 + 256] = 512 Dari hasil yang didapatkan dari metode trapesium didapatkan eror yang sangat besar yaitu sebagai berikut. e = \\dfrac{256-512}{256} \\times 100 = -100 Untuk mengurangi nilai kesalahan ( eror ) tersebut, maka kurva lengkung didekati oleh sejumlah garis lurus , sehingga terbentuk banyak pias yang dideskripsikan pada gambar berikut. 2 Maka integral totalnya dapat ditulis dalam bentuk : \\int^{x1}_{x0}f(x)dx + \\int^{x2}_{x1}f(x)dx+...+\\int^{xn}_{n-1}f(x)dx Apabila terdapat n pias, berarti panjang setiap pias adalah : \\Delta x = \\dfrac{a-b}{n} Sehingga didapat persamaan sebagai berikut : \\int^{a}_{b} f(x) dx = \\dfrac{\\Delta x}{2}[f(x_{1})+f(x_{0})] + \\dfrac{\\Delta x}{2}[f(x_{2})+f(x_{1})]++...+\\dfrac{\\Delta x}{2}[f(x_{n})+f(x_{n-1})] atau \\int^{a}_{b} f(x) dx =I =\\dfrac{\\Delta x}{2}[f(b)+f(a)+2\\sum ^{n-1}_{i=1}f(x_{i})] Keterangan : I = Hasil pengintegralan f(x) = Fungsi yang diintegralkan a = Batas atas integral b = Batas bawah integral \\Delta x = Panjang setiap pias/segmen n = Banyak pias/segmen Untuk lebih jelasnya perhatikan contoh berikut. Tentukan nilai aproksimasi integral dari fungsi f(x) = 4x^{3} dari x = 0 hingga x = 4 dengan menggunakan metode trapesium empat pias. jawab: Dari soal diperoleh a = 0, b = 4 dan n = 4, maka panjang pias : \\Delta x = \\dfrac {4-0}{4} = 1 Sehingga nilai I : I =\\dfrac{1}{2}[(4 \\times 0^{3})+(4\\times4^{3})+2((4\\times1^{3})+(4\\times2^{3})+4\\times3^{3})] \\dfrac{1}{2}[0+256+2(4+32+108)] \\dfrac{1}{2}[256+2(144)] \\dfrac{1}{2}[256+288] \\dfrac{1}{2}[544]=272 Dari hasil yang didapatkan nilai erornya semakin kecil yaitu : e = \\dfrac{256-272}{256} \\times 100\\% = -6,25\\% Dari sini dapat ditarik kesimpulan bahwa di dalam metode trapesium semakin banyak pias maka nilai kesalahan ( eror ) yang didapat semakin kecil. Dan algoritma program dari untuk metode trapesium dapat dinyatakan sebagai berikut. Mendefinisikan fungsi yang akan diintegrasikan, Menentukan batas atas a dan batas bawah b , Menginputkan banyaknya iterasi (pias/segmen) yaitu n , Menghitung lebar segmen/pias yaitu h =(b-a)/n , Deklarasi nilai awal x = 0 dan sigma = 0 , Update nilai x = x + h setiap melakukan perulangan Mengupdate nilai sigma dimulai dari n = 1 sampai n = n - 1 , Menghitung nilai I dengan menjumlahkan nilai sigma dari n = 1 sampai n = n -1 dengan nilai f(a) dan f(b) , Cetak hasil perhitungannya. Kemudian implementasi dari algoritma tersebut sebagai berikut. 4 def f ( x ): #deklarasi fungsi y = 4 * x ** 3 #nilai fungsi return y true = 256 #nilai analitik a = 4 #batas atas b = 0 #batas bawah n = int ( input ( \"Masukkan banyak iterasi : \" )) #inputkan banyak iterasi(segmen/pias) h = ( a - b ) / n #hitung lebar segmen/pias x = b #inisialisasi awal nilai x sigma = 0 #inisialisasi awal nilai sigma I = ( h / 2 ) * ( f ( b ) + sigma + f ( a )) #menghitung nilai I e = ( true - I ) / true * 100 # menghitung eror print ( \"===========================================================================\" ) print ( \">>>>>>>>>>>>>>>>>>>>>>>>>>>- METODE TRAPESIUM -<<<<<<<<<<<<<<<<<<<<<<<<<<<<\" ) print ( \"===========================================================================\" ) print ( '|iterasi|' , 'nilai xi' , ' \\t |' , 'nilai f(xi)' , ' \\t |' , 'nilai I'' \\t |' , 'nilai eror|' ) print ( \"| %d \" % 1 , ' \\t |' , \" %f \" % x , ' \\t |' , \" %f \" % f ( a ), ' \\t |' , \" %f \" % I , ' \\t |' , \" %f |\" % e ) for i in range ( 1 , n ): x = x + h #nilai x diupdate y = i + 1 sigma = sigma + 2 * f ( x ) #nilai I dari n=1 hingga n=n-1 I = ( h / 2 ) * ( f ( b ) + sigma + f ( a )) #menghitung nilai I e = ( true - I ) / true * 100 # menghitung eror print ( \"| %d \" % y , ' \\t |' , \" %f \" % x , ' \\t |' , \" %f \" % f ( x ), ' \\t |' , \" %f \" % I , ' \\t |' , \" %f |\" % e ) #menampilkan nilai keseluruhan print ( \"===========================================================================\" ) print ( \"Hasil integral numerik dari METODE TRAPESIUM ialah : %f \" % I ) #menampilkan nilai I print ( \"Dan nilai eror yang dihasilkan dari METODE TRAPESIUM ialah : %f \" % e ) #menampilkan nilai eror Dan hasil dari source code program tersebut sebagai berikut. Masukkan banyak iterasi : 4 =========================================================================== >>>>>>>>>>>>>>>>>>>>>>>>>>>- METODE TRAPESIUM -<<<<<<<<<<<<<<<<<<<<<<<<<<<< =========================================================================== |iterasi| nilai xi | nilai f(xi) | nilai I | nilai eror| |1 | 0.000000 | 256.000000 | 128.000000 | 50.000000| |2 | 1.000000 | 4.000000 | 132.000000 | 48.437500| |3 | 2.000000 | 32.000000 | 164.000000 | 35.937500| |4 | 3.000000 | 108.000000 | 272.000000 | -6.250000| =========================================================================== Hasil integral numerik dari METODE TRAPESIUM ialah : 272.000000 Dan nilai eror yang dihasilkan dari METODE TRAPESIUM ialah : -6.250000 2. Metode Simpson 1/3 \u00b6 \u200b Metode simpson 1/3 merupakan metode integrasi numerik yang dilakukan dengan menggunakan polinomial orde 2, yang melalui 3 titik data agar memperoleh ketelitian yang lebih tinggi.Metode simpson 1/3 memerlukan langkah yang genap untuk menerapkan metodenya.Dengan kata lain, jumlah langkah untuk metode Simpson 1/3 harus dapat dibagi dengan 2. 3 Metode simpson 1/3 dideskripsikan oleh gambar berikut. Persamaan metode simpson 1/3 dengan 1 segmen dapat dituliskan sebagai berikut. \\int^{a}_{b} f(x) dx= \\dfrac{\\Delta x}{3}[f(a) + 4f(c) + f(b)] I = \\dfrac{b-a}{6}[f(a) + 4f(c) + f(b)] Keterangan : I = Hasil pengintegralan f(x) = Fungsi yang diintegralkan a = Batas atas integral b = Batas bawah integral c = Nilai tengah (b-a/2) Untuk lebih jelasnya selesaikan contoh berikut. Tentukan nilai aproksimasi integral dari fungsi f(x) = 4x^{3} dari x = 0 hingga x = 4 dengan menggunakan metode simpson1/3. jawab : I = \\dfrac{4-0}{6}[4\\times0^{3}+4(4\\times2^{3})+4\\times4^{3}] =\\dfrac{4}{6}[0+4(32)+4\\times64] =\\dfrac{4}{6}[0+128+256] =\\dfrac{4}{6}[384]=256 Untuk eror yang dihasilkan dari metode simpson 1/3 yaitu sebagai berikut. e = \\dfrac{256-256}{256} \\times 100\\% = 0\\% Sama halnya dengan metode trapesium, metode simpson1/3 juga dapat menggunakan banyak segmen/pias yang dideskripsikan pada gambar berikut. 2 Metode simpson 1/3 banyak pias dapat dinyatakan sebagai berikut. \\int^{a}_{b} f(x) dx= I = \\dfrac{\\Delta x}{3}[f(a)+f(b)+4\\sum^{n-1}_{i=1,3,5}f(x_{i})+2\\sum^{n-2}_{i=2,3,6}f(x_{i})] Keterangan : I = Hasil pengintegralan f(x) = Fungsi yang diintegralkan a = Batas atas integral b = Batas bawah integral n = Banyak pias/segmen Untuk lebih jelasnya perhatikan contoh berikut. Tentukan nilai aproksimasi integral dari fungsi f(x) = 4x^{3} dari x = 0 hingga x = 4 dengan menggunakan metode simpson 1/3 empat pias. jawab: Dengan menggunakan metode simpson 1/3 diperoleh I = \\dfrac{1}{3}[4\\times0^{3}+4\\times4^{3}+4((4\\times1^{3})+(4\\times3^{3}))+2(4\\times2^{3})] \\dfrac{1}{3}[0+256+4(4+108)+2(32)] \\dfrac{1}{3}[256+4(112)+64] \\dfrac{1}{3}[256+448+64] \\dfrac{1}{3}[768]=256 Untuk eror yang dihasilkan dari metode simpson 1/3 dengan 4 segmen/pias yaitu sebagai berikut. e = \\dfrac{256-256}{256} \\times 100\\% = 0\\% Algoritma program untuk metode simpson 1/3 dinyatakan sebagai berikut. Mendefinisikan fungsi yang akan diintegrasikan, Menentukan batas atas a dan batas bawah b , Menginputkan banyaknya iterasi (pias/segmen) yaitu n , Menghitung lebar segmen/pias yaitu h =(b-a)/n , Deklarasi nilai awal x = 0 dan sigma = 0 , Update nilai x = x + h setiap melakukan perulangan Mengupdate nilai sigma mulai dari n = 1 hingga n = n -1 dengan ketentuan : Jika i = ganjil maka sigma = sigma + 4 \\times f(x) jika i = genap maka sigma = sigma + 2 \\times f(x) Menghitung nilai I dengan menjumlahkan nilai sigma dari n = 1 sampai n = n -1 dengan nilai f(a) dan f(b) , Cetak hasil perhitungannya. Dan implementasi dari algoritma tersebut terangkum dalam source code berikut. 5 def f ( x ): #deklarasi fungsi y = 4 * x ** 3 #nilai fungsi return y true = 256 #nilai analitik a = 4 #batas atas b = 0 #batas bawah n = int ( input ( \"Masukkan banyak iterasi : \" )) #inputkan banyak iterasi(segmen/pias) h = ( a - b ) / n #hitung lebar segmen/pias x = b #inisialisasi awal nilai x sigma = 0 #inisialisasi awal nilai sigma I = ( h / 3 ) * ( f ( b ) + sigma + f ( a )) #menghitung nilai I e = ( true - I ) / true * 100 # menghitung eror print ( \"===========================================================================\" ) print ( \">>>>>>>>>>>>>>>>>>>>>>>>>>- METODE 1/3 RAMPSON -<<<<<<<<<<<<<<<<<<<<<<<<<<<\" ) print ( \"===========================================================================\" ) print ( '|iterasi|' , 'nilai xi' , ' \\t |' , 'nilai f(xi)' , ' \\t |' , 'nilai I'' \\t |' , 'nilai eror|' ) print ( \"| %d \" % 1 , ' \\t |' , \" %f \" % x , ' \\t |' , \" %f \" % f ( x ), ' \\t |' , \" %f \" % I , ' \\t |' , \" %f |\" % e ) for i in range ( 1 , n ): x = x + h #update nilai x y = i + 1 if ( i % 2 ) == 1 : #kondisi jika ganjil sigma = sigma + 4 * f ( x ) #update nilai sigma 4*f(x) else : #kondisi jika genap sigma = sigma + 2 * f ( x ) #update nilai sigma 2*f(x) I = ( h / 3 ) * ( f ( b ) + sigma + f ( a )) #menghitung nilai I e = ( true - I ) / true * 100 # menghitung eror print ( \"| %d \" % y , ' \\t |' , \" %f \" % x , ' \\t |' , \" %f \" % f ( x ), ' \\t |' , \" %f \" % I , ' \\t |' , \" %f |\" % e ) #menampilkan nilai keseluruhan print ( \"===========================================================================\" ) print ( \"Hasil integral numerik dari METODE SIMPSON 1/3 ialah : %f \" % I ) #menampilkan nilai I print ( \"Dan nilai eror yang dihasilkan dari METODE SIMPSON 1/3 ialah : %f \" % e ) #menampilkan nilai eror Dan hasil output dari source code tersebut ialah sebagai berikut. Masukkan banyak iterasi : 4 =========================================================================== >>>>>>>>>>>>>>>>>>>>>>>>>>- METODE 1/3 RAMPSON -<<<<<<<<<<<<<<<<<<<<<<<<<<< =========================================================================== |iterasi| nilai xi | nilai f(xi) | nilai I | nilai eror| |1 | 0.000000 | 0.000000 | 85.333333 | 66.666667| |2 | 1.000000 | 4.000000 | 90.666667 | 64.583333| |3 | 2.000000 | 32.000000 | 112.000000 | 56.250000| |4 | 3.000000 | 108.000000 | 256.000000 | 0.000000| =========================================================================== Hasil integral numerik dari METODE SIMPSON 1/3 ialah : 256.000000 Dan nilai eror yang dihasilkan dari METODE SIMPSON 1/3 ialah : 0.000000 3. Metode Simpson 3/8 \u00b6 \u200b Metode simpson3/8 merupakan metode integrasi numerik yang dilakukan dengan menggunakan polinomial orde 3, yang melalui 4 titik data 2 Lain halnya dengan metode Simpson 1/3, metode simpson 3/8 tidak mensyaratkan jumlah langkah yang genap ataupun ganjil melainkan mensyaratkan jumlah langkah yang dapat dibagi dengan 3. Ungkapan metode Simpson 3/8 untuk 3 segmen dinyatakan sebagai berikut. 3 \\int^{a}_{b} f(x) dx=I = \\dfrac{3\\Delta x}{8}[f(x_{0})+3f(x_{1})+3f(x_{2})+f(x_{3})] atau \\int^{a}_{b} f(x) dx=I = {3\\Delta x}\\dfrac{[f(x_{0})+3f(x_{1})+3f(x_{2})+f(x_{3})]}{8} Keterangan : I = Hasil pengintegralan f(x) = Fungsi yang diintegralkan a = Batas atas integral b = Batas bawah integral \\Delta x = Panjang setiap pias/segmen Contoh: Tentukan nilai aproksimasi integral dari fungsi f(x) = 4x^{3} dari x = 0 hingga x = 4 dengan menggunakan metode simpson 3/8. jawab: Dengan menggunakan metode simpson 3/8 diperoleh I = (4-0)\\dfrac{[4\\times0^{3}+3(4\\times1,3333^{3})+3(4\\times2,6666^{3})+4\\times4^{3}]}{8} 4\\dfrac{[0+3(4\\times2,37)+3(4\\times18,96)+4\\times64]}{8} 4\\dfrac{[3(9,48)+3(75,85)+4\\times64]}{8} 4\\dfrac{[28,4+227,6+256]}{8} 4\\dfrac{[512]}{8} = 256 Dari hasil tersebut diperoleh nilai eror e = \\dfrac{256-256}{256} \\times 100\\% = 0\\% Sedangkan untuk metode simpson 3/8 banyak segmen/pias dapat didefinisikan sebagai berikut. \\int^{a}_{b} f(x) dx=I = \\dfrac{3\\times h}{8}[f(a)+3\\sum^{n-1}_{i=1}f(x_{i})+2\\sum^{n-3}_{i=3,6,9,...}f(x_{i}) + f(b)] Keterangan : I = Hasil pengintegralan f(x) = Fungsi yang diintegralkan a = Batas atas integral b = Batas bawah integral h = Panjang setiap pias/segmen n = Banyak pias/segmen Contoh: Tentukan nilai aproksimasi integral dari fungsi f(x) = 4x^{3} dari x = 0 hingga x = 4 dengan menggunakan metode simpson 3/8 6 pias. Jawab: I = \\dfrac{3\\times0,67}{8}[4\\times0^{3}+3(4\\times0,67^{3})+3(4\\times1,33^{3})+2(4\\times2^{3})+3(4\\times2,67^{3}) +3(4\\times3,33^{3})+4\\times4^{3}] \\dfrac{2}{8}[0+3(4\\times0,296)+3(4\\times2,37)+2(4\\times8)+3(4\\times18,96)+3(4\\times37,037)+4\\times64] \\dfrac{1}{4}[0+3(1,185)+3(9,481)+2(32)+3(75,85)+3(148,128)+256] \\dfrac{1}{4}[0+3,55+28,44+64+227,55+444,384+256] \\dfrac{1}{4}[1024] = 256 Dari hasil tersebut diperoleh nilai eror e = \\dfrac{256-256}{256} \\times 100\\% = 0\\% Berikut ini merupakan algoritma program metode simpson 3/8 Mendefinisikan fungsi yang akan diintegrasikan, Menentukan batas atas a dan batas bawah b , Menginputkan banyaknya iterasi (pias/segmen) yaitu n , Menghitung lebar segmen/pias yaitu h =(b-a)/n , Deklarasi nilai awal x = 0 dan sigma = 0 , Update nilai x = x + h setiap melakukan perulangan Mengupdate nilai sigma mulai dari n = 1 hingga n = n -1 dengan ketentuan : Jika i habis dibagi 3 maka sigma = sigma + 2 \\times f(x) Jika tidak maka sigma = sigma + 3 \\times f(x) Menghitung nilai I dengan menjumlahkan nilai sigma dari n = 1 sampai n = n -1 dengan nilai f(a) dan f(b) , Cetak hasil perhitungannya. Dan implementasi dari algoritma tersebut terangkum dalam source code berikut. 6 def f ( x ): #deklarasi fungsi y = 4 * x ** 3 #nilai fungsi return y true = 256 #nilai analitik a = 4 #batas atas b = 0 #batas bawah n = int ( input ( \"Masukkan banyak iterasi : \" )) #inputkan banyak iterasi(segmen/pias) h = ( a - b ) / n #hitung lebar segmen/pias x = b #inisialisasi awal nilai x sigma = 0 #inisialisasi awal nilai sigma I = ( 3 * h / 8 ) * ( f ( b ) + sigma + f ( a )) #menghitung nilai I e = ( true - I ) / true * 100 # menghitung eror print ( \"===========================================================================\" ) print ( \">>>>>>>>>>>>>>>>>>>>>>>>>>- METODE 3/8 RAMPSON -<<<<<<<<<<<<<<<<<<<<<<<<<<<\" ) print ( \"===========================================================================\" ) print ( '|iterasi|' , 'nilai xi' , ' \\t |' , 'nilai f(xi)' , ' \\t |' , 'nilai I'' \\t |' , 'nilai eror|' ) print ( \"| %d \" % 1 , ' \\t |' , \" %f \" % x , ' \\t |' , \" %f \" % f ( x ), ' \\t |' , \" %f \" % I , ' \\t |' , \" %f |\" % e ) for i in range ( 1 , n ): x = x + h #nilai x diupdate y = i + 1 if ( i % 3 ) == 0 : #kondisi jika habis dibagi 3 sigma = sigma + 2 * f ( x ) #update nilai sigma + 2*f(x) else : #jika tidak memenuhi sigma = sigma + 3 * f ( x ) #update nilai sigma + 3*f(x) I = ( 3 * h / 8 ) * ( f ( b ) + sigma + f ( a )) #menghitung nilai I e = ( true - I ) / true * 100 # menghitung eror print ( \"| %d \" % y , ' \\t |' , \" %f \" % x , ' \\t |' , \" %f \" % f ( x ), ' \\t |' , \" %f \" % I , ' \\t |' , \" %f |\" % e ) #menampilkan nilai keseluruhanprint print ( \"===========================================================================\" ) print ( \"Hasil integral dari METODE SIMPSON 3/8 ialah : %f \" % I ) #menampilkan nilai I print ( \"Dan nilai eror yang dihasilkan dari METODE SIMPSON 3/8 ialah : %f \" % e ) #menampilkan nilai eror Dan hasil output dari source code tersebut sebagai berikut Masukkan banyak iterasi : 6 =========================================================================== >>>>>>>>>>>>>>>>>>>>>>>>>>- METODE 3/8 RAMPSON -<<<<<<<<<<<<<<<<<<<<<<<<<<< =========================================================================== |iterasi| nilai xi | nilai f(xi) | nilai I | nilai eror| |1 | 0.000000 | 0.000000 | 64.000000 | 75.000000| |2 | 0.666667 | 1.185185 | 64.888889 | 74.652778| |3 | 1.333333 | 9.481481 | 72.000000 | 71.875000| |4 | 2.000000 | 32.000000 | 88.000000 | 65.625000| |5 | 2.666667 | 75.851852 | 144.888889 | 43.402778| |6 | 3.333333 | 148.148148 | 256.000000 | 0.000000 | =========================================================================== Hasil integral dari METODE SIMPSON 3/8 ialah : 256.000000 Dan nilai eror yang dihasilkan dari METODE SIMPSON 3/8 ialah : 0.000000 4. Aturan Titik Tengah \u00b6 \u200b Aturan titik tengah merupakan metode integrasi numerik yang diperoleh degan cara yang sama dengan aturan trapesium. Dengan mengevaluasi fungsi f(x) di titik tengah pada setiap interval, maka kesalahannya akan jauh lebih kecil dibandingkan dengan metode trapesium. Gambar berikut memberikan deskripsi grafis terhadap pendekatan ini. 3 \u200b Untuk dapat mereduksi kesalahan dari metode ini adalah dengan cara membagi interval x_{0} hingga x_{1} menjadi n segmen yang lebih kecil. Aturan titik tengah banyak segmen ini dapat dinyatakan sebagai berikut. 3 \\int^{a}_{b} f(x)dx = I = h\\sum^{n-1}_{i=0}f(x_{(a+1/2)}h) Keterangan : I = Hasil pengintegralan f(x) = Fungsi yang diintegralkan a = Batas atas integral b = Batas bawah integral h = Panjang setiap pias/segmen n = Banyak pias/segmen Contoh : Tentukan nilai aproksimasi integral dari fungsi f(x) = 4x^{3} dari x = 0 hingga x = 4 dengan menggunakan aturan titik tengah empat pias/segmen. \u200b Jawab : \\int^{4}_{0}4x^{3} = 1[4\\times((0+0.5)1)^{3} + 4\\times((1+0.5)1)^{3} + 4\\times((2+0.5)1)^{3} + 4\\times((3+0.5)1)^{3}] 1[4(0.5^{3})+4(1,5^{3})+4(2,5^{3})+4(3,5^{3})] 1[4(0,125)+4(3,375)+4(15,625)+4(42,875)] 1[0,5+13,5+62,5+171,5] = 248 Dari hasil tersebut diperoleh nilai eror sebesar e = \\dfrac{256-248}{256} \\times 100\\% = 3,125\\% Algoritma program untuk aturan titik tengah dapat dinyatakan sebagai berikut. Mendefinisikan fungsi yang akan diintegrasikan, Menentukan batas atas a dan batas bawah b , Menginputkan banyaknya iterasi (pias/segmen) yaitu n , Menghitung lebar segmen/pias yaitu h =(b-a)/n , Menghitung nilai x = a + (h/2) Inisialisasi nilai sigma sama dengan nilai fungsi f(x) Update nilai x = x + h setiap melakukan perulangan Update nilai sigma = sigma + f(x) Hitung nilai I = h \\times sigma Cetak hasil perhitungannya. Kemudian implementasi dari algoritma tersebut terangkum dalam source code berikut. 7 def f ( x ): #deklarasi fungsi y = 4 * x ** 3 #nilai fungsi return y true = 256 #nilai analitik a = 4 #batas atas b = 0 #batas bawah n = int ( input ( \"Masukkan banyak iterasi : \" )) #inputkan banyak iterasi(segmen/pias) h = ( a - b ) / n #hitung lebar segmen/pias x = b + h / 2 #inisialisasi awal nilai x sigma = f ( x ) #inisialisasi awal nilai sigma I = h * sigma e = ( true - I ) / true * 100 # menghitung eror print ( \"===========================================================================\" ) print ( \">>>>>>>>>>>>>>>>>>>>>>>>>>>- ATURAN TITIK TENGAH -<<<<<<<<<<<<<<<<<<<<<<<<<\" ) print ( \"===========================================================================\" ) print ( \"banyak iterasi : \" , n ) print ( '|iterssi|' , 'nilai xi' , ' \\t |' , 'nilai f(xi)' , ' \\t |' , 'nilai I'' \\t |' , 'nilai eror|' ) print ( \"| %d \" % 1 , ' \\t |' , \" %f \" % x , ' \\t |' , \" %f \" % f ( x ), ' \\t |' , \" %f \" % I , ' \\t |' , \" %f |\" % e ) for i in range ( 1 , n ): x = x + h #nilai x diupdate y = i + 1 sigma = sigma + f ( x ) #nilai I dari n=1 hingga n=n-1 I = h * sigma #menghitung nilai I e = ( true - I ) / true * 100 # menghitung eror print ( \"| %d \" % y , ' \\t |' , \" %f \" % x , ' \\t |' , \" %f \" % f ( x ), ' \\t |' , \" %f \" % I , ' \\t |' , \" %f |\" % e ) #menampilkan nilai keseluruhan print ( \"===========================================================================\" ) print ( \"Hasil integral numerik dari ATURAN TITIK TENGAH ialah : %f \" % I ) #menampilkan nilai print ( \"Dan nilai eror yang dihasilkan dari ATURAN TITIK TENGAH ialah : %f \" % e ) #menampilkan nilai eror Dan hasil output dari source code tersebut sebagai berikut. Masukkan banyak iterasi : 4 =========================================================================== >>>>>>>>>>>>>>>>>>>>>>>>>>>- ATURAN TITIK TENGAH -<<<<<<<<<<<<<<<<<<<<<<<<< =========================================================================== banyak iterasi : 4 |iterssi| nilai xi | nilai f(xi) | nilai I | nilai eror| |1 | 0.500000 | 0.500000 | 0.500000 | 99.804688| |2 | 1.500000 | 13.500000 | 14.000000 | 94.531250| |3 | 2.500000 | 62.500000 | 76.500000 | 70.117188| |4 | 3.500000 | 171.500000 | 248.000000 | 3.125000| =========================================================================== Hasil integral numerik dari ATURAN TITIK TENGAH ialah : 248.000000 Dan nilai eror yang dihasilkan dari ATURAN TITIK TENGAH ialah : 3.125000 Referensi \u00b6 http://ishaq.staff.gunadarma.ac.id/Downloads/files/43838/Integrasi+Numerik.pdf \u21a9 \u21a9 https://youtu.be/0UcJbiFHiT4 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 http://staffnew.uny.ac.id/upload/132206562/pendidikan/Integrasi+Numerik.pdf \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 https://youtu.be/iAszeC2_1cU \u21a9 https://youtu.be/U8dttZ5MMsA \u21a9 https://youtu.be/lY8e3DysYSs \u21a9 https://youtu.be/qOaWNCBnePk \u21a9","title":"Integrasi Numerik"},{"location":"#integrasi_numerik","text":"","title":"INTEGRASI NUMERIK"},{"location":"#a_definisi_integrasi_numerik","text":"\u200b Integrasi numerik merupakan metode penyelesaian integral yang digunakan oleh ilmuwan agar memperoleh jawaban aproksimasi dari integral yang tidak dapat diselesaikan secara analitik yang didasarkan pada perhitungan perkiraan. 1 Dari pengertian tersebut dapat disimpulkan bahwa integrasi numerik dapat dilakukan apabila : Integral sulit/tidak dapat diselesaikan secara analitik, Fungsi yang diintegralkan yang diberikan berbentuk angka/tabel. 2 \u200b Metode numerik dilakukan untuk mencoba lebih cepat dan lebih mendekati jawaban eksak dengan cara melakukan penintegralan pada bagian - bagian kecil. Dalam kalkulus perhitungan integral adalah perhitungan dasar yang digunakan dalam banyak hal. Perhitungan dilakukan dengan cara membagi luasan dalam beberapa pias kecil yang dibatasi oleh fungsi y = f(x) dan sumbu x . Kemudian luas totalnya adalah jumlah dari luas semua pias. 1 \u200b Secara umum integral fungsi y(x) dapat dinyatakan sebagai berikut. I = \\int^{b}_{x=a} y(x) dx \u200b Persamaan diatas dapat diartikan sebagai integral dari fungsi y(x) terhadap peubah bebas x yang dievaluasi mulai dari x = a hingga x = b . Pendekatan numerik terhadap persamaan integral tersebut dapat dinyatakan sebagai berikut. 3 I = \\sum ^{N}_{i=1}w_{i}y\\left( x_{i}\\right) \u200b Dengan N menyatakan jumlah segmen, y(x_{i}) = y(a) dan y(x_{n}) = y(b) . Pendekatan numerik pada integral diatas merupakan penjumlahan dari deret suku-suku dengan titik-titik x_{i} yang terbentang dari x = a hingga x = b dan di setiap titik x_{i} dievaluasi menjadi fungsi y(x) . Faktor x_{i} ini biasanya disebut sebagai titik simpul ( node ). sedangkan faktor pengali w_{i} disebut faktor bobot. 3","title":"A. Definisi Integrasi Numerik"},{"location":"#b_metode_integrasi_numerik","text":"\u200b Untuk menyelesaikan integrasi numerik terdapat beberapa metode diantaranya sebagai berikut.","title":"B. Metode Integrasi Numerik"},{"location":"#1_metode_trapesium","text":"\u200b Sesuai dengan namanya metode trapesium merupakan metode integrasi numerik yang didasarkan pada penjumlahan pias/segmen berbentuk trapesium 3 . Dalam metode ini grafik lengkung dari fungsi f(x) digantikan oleh garis lurus. Luasan bidang di bawah fungsi f(x) antara x = a hingga x = b pada gambar di bawah didekati oleh luas trapesium di bawah garis lurus yang menghubungkan f(a) dan f(b) . 2 \u200b Penggunaan garis lurus untuk mendekati grafik lengkung ini menyebabkan terjadinya kesalahan sebesar luasan yang tidak diarsir 2 . Apabila sebuah integral diselesaikan dengan menggunakan metode trapesium satu segmen saja, maka dapat dituliskan sebagai berikut. \\int^{a}_{b} f(x) dx =I= \\dfrac{b-a}{2}[f(a) + f(b)] Keterangan : I = Hasil pengintegralan f(x) = Fungsi yang diintegralkan a = Batas atas integral b = Batas bawah integral Untuk lebih jelasnya perhatikan contoh berikut. Tentukan nilai aproksimasi integral dari fungsi f(x) = 4x^{3} dari x = 0 hingga x = 4 dengan menggunakan metode trapesium. jawab: Jika dikerjakan secara analitik, maka hasilnya sebagai berikut. \\int^{4}_{0} 4x^{3} dx = x^{4}I^{4}_{0} = 4^{4} - 4^{0} = 256 - 0 = 256 Sedangkan jika dikerjakan dengan menggunakan metode trapesium hasilnya sebagai berikut. \\int^{4}_{0} 4x^{3} dx = \\dfrac{4-0}{2}[4\\times0^{3} + 4\\times4^{3}] =2[4\\times0 + 4\\times64] = 2[0 + 256] = 512 Dari hasil yang didapatkan dari metode trapesium didapatkan eror yang sangat besar yaitu sebagai berikut. e = \\dfrac{256-512}{256} \\times 100 = -100 Untuk mengurangi nilai kesalahan ( eror ) tersebut, maka kurva lengkung didekati oleh sejumlah garis lurus , sehingga terbentuk banyak pias yang dideskripsikan pada gambar berikut. 2 Maka integral totalnya dapat ditulis dalam bentuk : \\int^{x1}_{x0}f(x)dx + \\int^{x2}_{x1}f(x)dx+...+\\int^{xn}_{n-1}f(x)dx Apabila terdapat n pias, berarti panjang setiap pias adalah : \\Delta x = \\dfrac{a-b}{n} Sehingga didapat persamaan sebagai berikut : \\int^{a}_{b} f(x) dx = \\dfrac{\\Delta x}{2}[f(x_{1})+f(x_{0})] + \\dfrac{\\Delta x}{2}[f(x_{2})+f(x_{1})]++...+\\dfrac{\\Delta x}{2}[f(x_{n})+f(x_{n-1})] atau \\int^{a}_{b} f(x) dx =I =\\dfrac{\\Delta x}{2}[f(b)+f(a)+2\\sum ^{n-1}_{i=1}f(x_{i})] Keterangan : I = Hasil pengintegralan f(x) = Fungsi yang diintegralkan a = Batas atas integral b = Batas bawah integral \\Delta x = Panjang setiap pias/segmen n = Banyak pias/segmen Untuk lebih jelasnya perhatikan contoh berikut. Tentukan nilai aproksimasi integral dari fungsi f(x) = 4x^{3} dari x = 0 hingga x = 4 dengan menggunakan metode trapesium empat pias. jawab: Dari soal diperoleh a = 0, b = 4 dan n = 4, maka panjang pias : \\Delta x = \\dfrac {4-0}{4} = 1 Sehingga nilai I : I =\\dfrac{1}{2}[(4 \\times 0^{3})+(4\\times4^{3})+2((4\\times1^{3})+(4\\times2^{3})+4\\times3^{3})] \\dfrac{1}{2}[0+256+2(4+32+108)] \\dfrac{1}{2}[256+2(144)] \\dfrac{1}{2}[256+288] \\dfrac{1}{2}[544]=272 Dari hasil yang didapatkan nilai erornya semakin kecil yaitu : e = \\dfrac{256-272}{256} \\times 100\\% = -6,25\\% Dari sini dapat ditarik kesimpulan bahwa di dalam metode trapesium semakin banyak pias maka nilai kesalahan ( eror ) yang didapat semakin kecil. Dan algoritma program dari untuk metode trapesium dapat dinyatakan sebagai berikut. Mendefinisikan fungsi yang akan diintegrasikan, Menentukan batas atas a dan batas bawah b , Menginputkan banyaknya iterasi (pias/segmen) yaitu n , Menghitung lebar segmen/pias yaitu h =(b-a)/n , Deklarasi nilai awal x = 0 dan sigma = 0 , Update nilai x = x + h setiap melakukan perulangan Mengupdate nilai sigma dimulai dari n = 1 sampai n = n - 1 , Menghitung nilai I dengan menjumlahkan nilai sigma dari n = 1 sampai n = n -1 dengan nilai f(a) dan f(b) , Cetak hasil perhitungannya. Kemudian implementasi dari algoritma tersebut sebagai berikut. 4 def f ( x ): #deklarasi fungsi y = 4 * x ** 3 #nilai fungsi return y true = 256 #nilai analitik a = 4 #batas atas b = 0 #batas bawah n = int ( input ( \"Masukkan banyak iterasi : \" )) #inputkan banyak iterasi(segmen/pias) h = ( a - b ) / n #hitung lebar segmen/pias x = b #inisialisasi awal nilai x sigma = 0 #inisialisasi awal nilai sigma I = ( h / 2 ) * ( f ( b ) + sigma + f ( a )) #menghitung nilai I e = ( true - I ) / true * 100 # menghitung eror print ( \"===========================================================================\" ) print ( \">>>>>>>>>>>>>>>>>>>>>>>>>>>- METODE TRAPESIUM -<<<<<<<<<<<<<<<<<<<<<<<<<<<<\" ) print ( \"===========================================================================\" ) print ( '|iterasi|' , 'nilai xi' , ' \\t |' , 'nilai f(xi)' , ' \\t |' , 'nilai I'' \\t |' , 'nilai eror|' ) print ( \"| %d \" % 1 , ' \\t |' , \" %f \" % x , ' \\t |' , \" %f \" % f ( a ), ' \\t |' , \" %f \" % I , ' \\t |' , \" %f |\" % e ) for i in range ( 1 , n ): x = x + h #nilai x diupdate y = i + 1 sigma = sigma + 2 * f ( x ) #nilai I dari n=1 hingga n=n-1 I = ( h / 2 ) * ( f ( b ) + sigma + f ( a )) #menghitung nilai I e = ( true - I ) / true * 100 # menghitung eror print ( \"| %d \" % y , ' \\t |' , \" %f \" % x , ' \\t |' , \" %f \" % f ( x ), ' \\t |' , \" %f \" % I , ' \\t |' , \" %f |\" % e ) #menampilkan nilai keseluruhan print ( \"===========================================================================\" ) print ( \"Hasil integral numerik dari METODE TRAPESIUM ialah : %f \" % I ) #menampilkan nilai I print ( \"Dan nilai eror yang dihasilkan dari METODE TRAPESIUM ialah : %f \" % e ) #menampilkan nilai eror Dan hasil dari source code program tersebut sebagai berikut. Masukkan banyak iterasi : 4 =========================================================================== >>>>>>>>>>>>>>>>>>>>>>>>>>>- METODE TRAPESIUM -<<<<<<<<<<<<<<<<<<<<<<<<<<<< =========================================================================== |iterasi| nilai xi | nilai f(xi) | nilai I | nilai eror| |1 | 0.000000 | 256.000000 | 128.000000 | 50.000000| |2 | 1.000000 | 4.000000 | 132.000000 | 48.437500| |3 | 2.000000 | 32.000000 | 164.000000 | 35.937500| |4 | 3.000000 | 108.000000 | 272.000000 | -6.250000| =========================================================================== Hasil integral numerik dari METODE TRAPESIUM ialah : 272.000000 Dan nilai eror yang dihasilkan dari METODE TRAPESIUM ialah : -6.250000","title":"1. Metode Trapesium"},{"location":"#2_metode_simpson_13","text":"\u200b Metode simpson 1/3 merupakan metode integrasi numerik yang dilakukan dengan menggunakan polinomial orde 2, yang melalui 3 titik data agar memperoleh ketelitian yang lebih tinggi.Metode simpson 1/3 memerlukan langkah yang genap untuk menerapkan metodenya.Dengan kata lain, jumlah langkah untuk metode Simpson 1/3 harus dapat dibagi dengan 2. 3 Metode simpson 1/3 dideskripsikan oleh gambar berikut. Persamaan metode simpson 1/3 dengan 1 segmen dapat dituliskan sebagai berikut. \\int^{a}_{b} f(x) dx= \\dfrac{\\Delta x}{3}[f(a) + 4f(c) + f(b)] I = \\dfrac{b-a}{6}[f(a) + 4f(c) + f(b)] Keterangan : I = Hasil pengintegralan f(x) = Fungsi yang diintegralkan a = Batas atas integral b = Batas bawah integral c = Nilai tengah (b-a/2) Untuk lebih jelasnya selesaikan contoh berikut. Tentukan nilai aproksimasi integral dari fungsi f(x) = 4x^{3} dari x = 0 hingga x = 4 dengan menggunakan metode simpson1/3. jawab : I = \\dfrac{4-0}{6}[4\\times0^{3}+4(4\\times2^{3})+4\\times4^{3}] =\\dfrac{4}{6}[0+4(32)+4\\times64] =\\dfrac{4}{6}[0+128+256] =\\dfrac{4}{6}[384]=256 Untuk eror yang dihasilkan dari metode simpson 1/3 yaitu sebagai berikut. e = \\dfrac{256-256}{256} \\times 100\\% = 0\\% Sama halnya dengan metode trapesium, metode simpson1/3 juga dapat menggunakan banyak segmen/pias yang dideskripsikan pada gambar berikut. 2 Metode simpson 1/3 banyak pias dapat dinyatakan sebagai berikut. \\int^{a}_{b} f(x) dx= I = \\dfrac{\\Delta x}{3}[f(a)+f(b)+4\\sum^{n-1}_{i=1,3,5}f(x_{i})+2\\sum^{n-2}_{i=2,3,6}f(x_{i})] Keterangan : I = Hasil pengintegralan f(x) = Fungsi yang diintegralkan a = Batas atas integral b = Batas bawah integral n = Banyak pias/segmen Untuk lebih jelasnya perhatikan contoh berikut. Tentukan nilai aproksimasi integral dari fungsi f(x) = 4x^{3} dari x = 0 hingga x = 4 dengan menggunakan metode simpson 1/3 empat pias. jawab: Dengan menggunakan metode simpson 1/3 diperoleh I = \\dfrac{1}{3}[4\\times0^{3}+4\\times4^{3}+4((4\\times1^{3})+(4\\times3^{3}))+2(4\\times2^{3})] \\dfrac{1}{3}[0+256+4(4+108)+2(32)] \\dfrac{1}{3}[256+4(112)+64] \\dfrac{1}{3}[256+448+64] \\dfrac{1}{3}[768]=256 Untuk eror yang dihasilkan dari metode simpson 1/3 dengan 4 segmen/pias yaitu sebagai berikut. e = \\dfrac{256-256}{256} \\times 100\\% = 0\\% Algoritma program untuk metode simpson 1/3 dinyatakan sebagai berikut. Mendefinisikan fungsi yang akan diintegrasikan, Menentukan batas atas a dan batas bawah b , Menginputkan banyaknya iterasi (pias/segmen) yaitu n , Menghitung lebar segmen/pias yaitu h =(b-a)/n , Deklarasi nilai awal x = 0 dan sigma = 0 , Update nilai x = x + h setiap melakukan perulangan Mengupdate nilai sigma mulai dari n = 1 hingga n = n -1 dengan ketentuan : Jika i = ganjil maka sigma = sigma + 4 \\times f(x) jika i = genap maka sigma = sigma + 2 \\times f(x) Menghitung nilai I dengan menjumlahkan nilai sigma dari n = 1 sampai n = n -1 dengan nilai f(a) dan f(b) , Cetak hasil perhitungannya. Dan implementasi dari algoritma tersebut terangkum dalam source code berikut. 5 def f ( x ): #deklarasi fungsi y = 4 * x ** 3 #nilai fungsi return y true = 256 #nilai analitik a = 4 #batas atas b = 0 #batas bawah n = int ( input ( \"Masukkan banyak iterasi : \" )) #inputkan banyak iterasi(segmen/pias) h = ( a - b ) / n #hitung lebar segmen/pias x = b #inisialisasi awal nilai x sigma = 0 #inisialisasi awal nilai sigma I = ( h / 3 ) * ( f ( b ) + sigma + f ( a )) #menghitung nilai I e = ( true - I ) / true * 100 # menghitung eror print ( \"===========================================================================\" ) print ( \">>>>>>>>>>>>>>>>>>>>>>>>>>- METODE 1/3 RAMPSON -<<<<<<<<<<<<<<<<<<<<<<<<<<<\" ) print ( \"===========================================================================\" ) print ( '|iterasi|' , 'nilai xi' , ' \\t |' , 'nilai f(xi)' , ' \\t |' , 'nilai I'' \\t |' , 'nilai eror|' ) print ( \"| %d \" % 1 , ' \\t |' , \" %f \" % x , ' \\t |' , \" %f \" % f ( x ), ' \\t |' , \" %f \" % I , ' \\t |' , \" %f |\" % e ) for i in range ( 1 , n ): x = x + h #update nilai x y = i + 1 if ( i % 2 ) == 1 : #kondisi jika ganjil sigma = sigma + 4 * f ( x ) #update nilai sigma 4*f(x) else : #kondisi jika genap sigma = sigma + 2 * f ( x ) #update nilai sigma 2*f(x) I = ( h / 3 ) * ( f ( b ) + sigma + f ( a )) #menghitung nilai I e = ( true - I ) / true * 100 # menghitung eror print ( \"| %d \" % y , ' \\t |' , \" %f \" % x , ' \\t |' , \" %f \" % f ( x ), ' \\t |' , \" %f \" % I , ' \\t |' , \" %f |\" % e ) #menampilkan nilai keseluruhan print ( \"===========================================================================\" ) print ( \"Hasil integral numerik dari METODE SIMPSON 1/3 ialah : %f \" % I ) #menampilkan nilai I print ( \"Dan nilai eror yang dihasilkan dari METODE SIMPSON 1/3 ialah : %f \" % e ) #menampilkan nilai eror Dan hasil output dari source code tersebut ialah sebagai berikut. Masukkan banyak iterasi : 4 =========================================================================== >>>>>>>>>>>>>>>>>>>>>>>>>>- METODE 1/3 RAMPSON -<<<<<<<<<<<<<<<<<<<<<<<<<<< =========================================================================== |iterasi| nilai xi | nilai f(xi) | nilai I | nilai eror| |1 | 0.000000 | 0.000000 | 85.333333 | 66.666667| |2 | 1.000000 | 4.000000 | 90.666667 | 64.583333| |3 | 2.000000 | 32.000000 | 112.000000 | 56.250000| |4 | 3.000000 | 108.000000 | 256.000000 | 0.000000| =========================================================================== Hasil integral numerik dari METODE SIMPSON 1/3 ialah : 256.000000 Dan nilai eror yang dihasilkan dari METODE SIMPSON 1/3 ialah : 0.000000","title":"2. Metode Simpson 1/3"},{"location":"#3_metode_simpson_38","text":"\u200b Metode simpson3/8 merupakan metode integrasi numerik yang dilakukan dengan menggunakan polinomial orde 3, yang melalui 4 titik data 2 Lain halnya dengan metode Simpson 1/3, metode simpson 3/8 tidak mensyaratkan jumlah langkah yang genap ataupun ganjil melainkan mensyaratkan jumlah langkah yang dapat dibagi dengan 3. Ungkapan metode Simpson 3/8 untuk 3 segmen dinyatakan sebagai berikut. 3 \\int^{a}_{b} f(x) dx=I = \\dfrac{3\\Delta x}{8}[f(x_{0})+3f(x_{1})+3f(x_{2})+f(x_{3})] atau \\int^{a}_{b} f(x) dx=I = {3\\Delta x}\\dfrac{[f(x_{0})+3f(x_{1})+3f(x_{2})+f(x_{3})]}{8} Keterangan : I = Hasil pengintegralan f(x) = Fungsi yang diintegralkan a = Batas atas integral b = Batas bawah integral \\Delta x = Panjang setiap pias/segmen Contoh: Tentukan nilai aproksimasi integral dari fungsi f(x) = 4x^{3} dari x = 0 hingga x = 4 dengan menggunakan metode simpson 3/8. jawab: Dengan menggunakan metode simpson 3/8 diperoleh I = (4-0)\\dfrac{[4\\times0^{3}+3(4\\times1,3333^{3})+3(4\\times2,6666^{3})+4\\times4^{3}]}{8} 4\\dfrac{[0+3(4\\times2,37)+3(4\\times18,96)+4\\times64]}{8} 4\\dfrac{[3(9,48)+3(75,85)+4\\times64]}{8} 4\\dfrac{[28,4+227,6+256]}{8} 4\\dfrac{[512]}{8} = 256 Dari hasil tersebut diperoleh nilai eror e = \\dfrac{256-256}{256} \\times 100\\% = 0\\% Sedangkan untuk metode simpson 3/8 banyak segmen/pias dapat didefinisikan sebagai berikut. \\int^{a}_{b} f(x) dx=I = \\dfrac{3\\times h}{8}[f(a)+3\\sum^{n-1}_{i=1}f(x_{i})+2\\sum^{n-3}_{i=3,6,9,...}f(x_{i}) + f(b)] Keterangan : I = Hasil pengintegralan f(x) = Fungsi yang diintegralkan a = Batas atas integral b = Batas bawah integral h = Panjang setiap pias/segmen n = Banyak pias/segmen Contoh: Tentukan nilai aproksimasi integral dari fungsi f(x) = 4x^{3} dari x = 0 hingga x = 4 dengan menggunakan metode simpson 3/8 6 pias. Jawab: I = \\dfrac{3\\times0,67}{8}[4\\times0^{3}+3(4\\times0,67^{3})+3(4\\times1,33^{3})+2(4\\times2^{3})+3(4\\times2,67^{3}) +3(4\\times3,33^{3})+4\\times4^{3}] \\dfrac{2}{8}[0+3(4\\times0,296)+3(4\\times2,37)+2(4\\times8)+3(4\\times18,96)+3(4\\times37,037)+4\\times64] \\dfrac{1}{4}[0+3(1,185)+3(9,481)+2(32)+3(75,85)+3(148,128)+256] \\dfrac{1}{4}[0+3,55+28,44+64+227,55+444,384+256] \\dfrac{1}{4}[1024] = 256 Dari hasil tersebut diperoleh nilai eror e = \\dfrac{256-256}{256} \\times 100\\% = 0\\% Berikut ini merupakan algoritma program metode simpson 3/8 Mendefinisikan fungsi yang akan diintegrasikan, Menentukan batas atas a dan batas bawah b , Menginputkan banyaknya iterasi (pias/segmen) yaitu n , Menghitung lebar segmen/pias yaitu h =(b-a)/n , Deklarasi nilai awal x = 0 dan sigma = 0 , Update nilai x = x + h setiap melakukan perulangan Mengupdate nilai sigma mulai dari n = 1 hingga n = n -1 dengan ketentuan : Jika i habis dibagi 3 maka sigma = sigma + 2 \\times f(x) Jika tidak maka sigma = sigma + 3 \\times f(x) Menghitung nilai I dengan menjumlahkan nilai sigma dari n = 1 sampai n = n -1 dengan nilai f(a) dan f(b) , Cetak hasil perhitungannya. Dan implementasi dari algoritma tersebut terangkum dalam source code berikut. 6 def f ( x ): #deklarasi fungsi y = 4 * x ** 3 #nilai fungsi return y true = 256 #nilai analitik a = 4 #batas atas b = 0 #batas bawah n = int ( input ( \"Masukkan banyak iterasi : \" )) #inputkan banyak iterasi(segmen/pias) h = ( a - b ) / n #hitung lebar segmen/pias x = b #inisialisasi awal nilai x sigma = 0 #inisialisasi awal nilai sigma I = ( 3 * h / 8 ) * ( f ( b ) + sigma + f ( a )) #menghitung nilai I e = ( true - I ) / true * 100 # menghitung eror print ( \"===========================================================================\" ) print ( \">>>>>>>>>>>>>>>>>>>>>>>>>>- METODE 3/8 RAMPSON -<<<<<<<<<<<<<<<<<<<<<<<<<<<\" ) print ( \"===========================================================================\" ) print ( '|iterasi|' , 'nilai xi' , ' \\t |' , 'nilai f(xi)' , ' \\t |' , 'nilai I'' \\t |' , 'nilai eror|' ) print ( \"| %d \" % 1 , ' \\t |' , \" %f \" % x , ' \\t |' , \" %f \" % f ( x ), ' \\t |' , \" %f \" % I , ' \\t |' , \" %f |\" % e ) for i in range ( 1 , n ): x = x + h #nilai x diupdate y = i + 1 if ( i % 3 ) == 0 : #kondisi jika habis dibagi 3 sigma = sigma + 2 * f ( x ) #update nilai sigma + 2*f(x) else : #jika tidak memenuhi sigma = sigma + 3 * f ( x ) #update nilai sigma + 3*f(x) I = ( 3 * h / 8 ) * ( f ( b ) + sigma + f ( a )) #menghitung nilai I e = ( true - I ) / true * 100 # menghitung eror print ( \"| %d \" % y , ' \\t |' , \" %f \" % x , ' \\t |' , \" %f \" % f ( x ), ' \\t |' , \" %f \" % I , ' \\t |' , \" %f |\" % e ) #menampilkan nilai keseluruhanprint print ( \"===========================================================================\" ) print ( \"Hasil integral dari METODE SIMPSON 3/8 ialah : %f \" % I ) #menampilkan nilai I print ( \"Dan nilai eror yang dihasilkan dari METODE SIMPSON 3/8 ialah : %f \" % e ) #menampilkan nilai eror Dan hasil output dari source code tersebut sebagai berikut Masukkan banyak iterasi : 6 =========================================================================== >>>>>>>>>>>>>>>>>>>>>>>>>>- METODE 3/8 RAMPSON -<<<<<<<<<<<<<<<<<<<<<<<<<<< =========================================================================== |iterasi| nilai xi | nilai f(xi) | nilai I | nilai eror| |1 | 0.000000 | 0.000000 | 64.000000 | 75.000000| |2 | 0.666667 | 1.185185 | 64.888889 | 74.652778| |3 | 1.333333 | 9.481481 | 72.000000 | 71.875000| |4 | 2.000000 | 32.000000 | 88.000000 | 65.625000| |5 | 2.666667 | 75.851852 | 144.888889 | 43.402778| |6 | 3.333333 | 148.148148 | 256.000000 | 0.000000 | =========================================================================== Hasil integral dari METODE SIMPSON 3/8 ialah : 256.000000 Dan nilai eror yang dihasilkan dari METODE SIMPSON 3/8 ialah : 0.000000","title":"3. Metode Simpson 3/8"},{"location":"#4_aturan_titik_tengah","text":"\u200b Aturan titik tengah merupakan metode integrasi numerik yang diperoleh degan cara yang sama dengan aturan trapesium. Dengan mengevaluasi fungsi f(x) di titik tengah pada setiap interval, maka kesalahannya akan jauh lebih kecil dibandingkan dengan metode trapesium. Gambar berikut memberikan deskripsi grafis terhadap pendekatan ini. 3 \u200b Untuk dapat mereduksi kesalahan dari metode ini adalah dengan cara membagi interval x_{0} hingga x_{1} menjadi n segmen yang lebih kecil. Aturan titik tengah banyak segmen ini dapat dinyatakan sebagai berikut. 3 \\int^{a}_{b} f(x)dx = I = h\\sum^{n-1}_{i=0}f(x_{(a+1/2)}h) Keterangan : I = Hasil pengintegralan f(x) = Fungsi yang diintegralkan a = Batas atas integral b = Batas bawah integral h = Panjang setiap pias/segmen n = Banyak pias/segmen Contoh : Tentukan nilai aproksimasi integral dari fungsi f(x) = 4x^{3} dari x = 0 hingga x = 4 dengan menggunakan aturan titik tengah empat pias/segmen. \u200b Jawab : \\int^{4}_{0}4x^{3} = 1[4\\times((0+0.5)1)^{3} + 4\\times((1+0.5)1)^{3} + 4\\times((2+0.5)1)^{3} + 4\\times((3+0.5)1)^{3}] 1[4(0.5^{3})+4(1,5^{3})+4(2,5^{3})+4(3,5^{3})] 1[4(0,125)+4(3,375)+4(15,625)+4(42,875)] 1[0,5+13,5+62,5+171,5] = 248 Dari hasil tersebut diperoleh nilai eror sebesar e = \\dfrac{256-248}{256} \\times 100\\% = 3,125\\% Algoritma program untuk aturan titik tengah dapat dinyatakan sebagai berikut. Mendefinisikan fungsi yang akan diintegrasikan, Menentukan batas atas a dan batas bawah b , Menginputkan banyaknya iterasi (pias/segmen) yaitu n , Menghitung lebar segmen/pias yaitu h =(b-a)/n , Menghitung nilai x = a + (h/2) Inisialisasi nilai sigma sama dengan nilai fungsi f(x) Update nilai x = x + h setiap melakukan perulangan Update nilai sigma = sigma + f(x) Hitung nilai I = h \\times sigma Cetak hasil perhitungannya. Kemudian implementasi dari algoritma tersebut terangkum dalam source code berikut. 7 def f ( x ): #deklarasi fungsi y = 4 * x ** 3 #nilai fungsi return y true = 256 #nilai analitik a = 4 #batas atas b = 0 #batas bawah n = int ( input ( \"Masukkan banyak iterasi : \" )) #inputkan banyak iterasi(segmen/pias) h = ( a - b ) / n #hitung lebar segmen/pias x = b + h / 2 #inisialisasi awal nilai x sigma = f ( x ) #inisialisasi awal nilai sigma I = h * sigma e = ( true - I ) / true * 100 # menghitung eror print ( \"===========================================================================\" ) print ( \">>>>>>>>>>>>>>>>>>>>>>>>>>>- ATURAN TITIK TENGAH -<<<<<<<<<<<<<<<<<<<<<<<<<\" ) print ( \"===========================================================================\" ) print ( \"banyak iterasi : \" , n ) print ( '|iterssi|' , 'nilai xi' , ' \\t |' , 'nilai f(xi)' , ' \\t |' , 'nilai I'' \\t |' , 'nilai eror|' ) print ( \"| %d \" % 1 , ' \\t |' , \" %f \" % x , ' \\t |' , \" %f \" % f ( x ), ' \\t |' , \" %f \" % I , ' \\t |' , \" %f |\" % e ) for i in range ( 1 , n ): x = x + h #nilai x diupdate y = i + 1 sigma = sigma + f ( x ) #nilai I dari n=1 hingga n=n-1 I = h * sigma #menghitung nilai I e = ( true - I ) / true * 100 # menghitung eror print ( \"| %d \" % y , ' \\t |' , \" %f \" % x , ' \\t |' , \" %f \" % f ( x ), ' \\t |' , \" %f \" % I , ' \\t |' , \" %f |\" % e ) #menampilkan nilai keseluruhan print ( \"===========================================================================\" ) print ( \"Hasil integral numerik dari ATURAN TITIK TENGAH ialah : %f \" % I ) #menampilkan nilai print ( \"Dan nilai eror yang dihasilkan dari ATURAN TITIK TENGAH ialah : %f \" % e ) #menampilkan nilai eror Dan hasil output dari source code tersebut sebagai berikut. Masukkan banyak iterasi : 4 =========================================================================== >>>>>>>>>>>>>>>>>>>>>>>>>>>- ATURAN TITIK TENGAH -<<<<<<<<<<<<<<<<<<<<<<<<< =========================================================================== banyak iterasi : 4 |iterssi| nilai xi | nilai f(xi) | nilai I | nilai eror| |1 | 0.500000 | 0.500000 | 0.500000 | 99.804688| |2 | 1.500000 | 13.500000 | 14.000000 | 94.531250| |3 | 2.500000 | 62.500000 | 76.500000 | 70.117188| |4 | 3.500000 | 171.500000 | 248.000000 | 3.125000| =========================================================================== Hasil integral numerik dari ATURAN TITIK TENGAH ialah : 248.000000 Dan nilai eror yang dihasilkan dari ATURAN TITIK TENGAH ialah : 3.125000","title":"4. Aturan Titik Tengah"},{"location":"#referensi","text":"http://ishaq.staff.gunadarma.ac.id/Downloads/files/43838/Integrasi+Numerik.pdf \u21a9 \u21a9 https://youtu.be/0UcJbiFHiT4 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 http://staffnew.uny.ac.id/upload/132206562/pendidikan/Integrasi+Numerik.pdf \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 https://youtu.be/iAszeC2_1cU \u21a9 https://youtu.be/U8dttZ5MMsA \u21a9 https://youtu.be/lY8e3DysYSs \u21a9 https://youtu.be/qOaWNCBnePk \u21a9","title":"Referensi"},{"location":"Differensial/","text":"PERSAMAAN DIFFERENSIAL BIASA (PDB) \u00b6 A. Definisi Persamaan Differensial Biasa (PDB) \u00b6 \u200b Persamaan Differensial Biasa (PDB) merupakan persamaan differensial yang terdiri dari beberapa turunan biasa dari fungsi yang tidak diketahui dari variabel bebas tunggal. 1 Dan variabel bebas tersebut biasanya disimbolkan dengan x. Berikut merupakan contoh contoh persamaan differensial biasa. 2 Contoh : 1.\\ \\dfrac{dy}{dx} = x +y\\\\ 2.\\ y^{'} = x^{2}+y^{2}\\\\ 3.\\ \\dfrac{2dy}{dx} +x^{2}y-y = 0\\\\ 4.\\ y^{''} + y^{'}cos\\ x -3y = sin\\ 2x\\\\ 5.\\ 2y^{'''}-23y^{'} = 1 -y^{''} \u200b Variabel bebas dari contoh 1 hingga 5 adalah x dan variabel terikatnya ialah y yang merupakan fungsi dari x atau bisa ditulis y = f(x) . Berdasarkan turunnan tertinggi yang ada di persamaannya, PDB dikelompokkan lagi berdasarkan ordenya yaitu : 2 PDB orde 1 yaitu turunan tertingginya ialah turunan pertama, contohnya pada contoh nomor 1,2 dan 3 di atas. PDB orde 2 yaitu turunan tertingginya ialah turunan kedua, contohnya pada contoh nomor 4 di atas. PDB orde 3 yaitu turunan tertingginya ialah turunan ketiga, contohnya pada contoh nomor 5 diatas. Dan untuk PDB selanjutnya yang lebih tinggi dinamakan PDB orde lanjut. 2 Metode numerik dapat digunakan untuk menyelesaikan persamaan differensial biasa karena sebagian besar persamaan differensial tidak dapat diselesaikan secara analitik. Berikut ini pembahasan tentang metode numerik untuk menyelesaikan persamaan differensial biasa orde satu. B. Metode Persamaan Differensial Biasa (PDB) \u00b6 \u200b Bentuk baku PDB orde satu dengan nilai awal dapat ditulis : y^{'} = f(x,y)\\ \\ \\ \\ \\ \\ atau\\ \\ \\ \\ \\ \\ \\dfrac{dy}{dx} = f(x,y) dengan nilai awal y(x0) = y PDB orde satu yang tidak mengikuti bentuk tersebut harus ditulis ulang seperti bentuk baku diatas agar dapat diselesaikan secara numerik. Penyelesaian PDB secara numerik berarti menghitung nilai fungsi di x_{i+1} = h , dengan h adalah ukuran langkah setiap lelaran. Pada metode analiti nilai awal berfungsi untuk memperoleh solusi yang unik, sedangkan pada metode numerik nilai awal berfungsi untuk memulai lelaran. Terdapat beberapa metode numerik yang digunakan untuk menyelesaikan PDB , mulai dari mrtode yang paling dasar hingga metode yang lebih teliti, diantanya ialah sebagai berikut. 2 1. Metode Euler \u00b6 \u200b Metode Euler adalah metode yang digunakan untuk menyelesaikan PDB yang dihasilkan dari turunan deret Taylor. Metode euler juga disebut metode orde-pertama dikarenakan hanya mengambil sampai suku pertama saja dari deret Taylor. Selain menggunakan bantuan deret Taylor, metode Euler juga dapat diturunkan dengan menggunakan metode aturan segiempat untuk mengintegrasikan f(x,y) pada persamaan diferensial. Tafsiran geometri penurunan metode Euler digambarkan sebagai berikut. 2 Sehingga bentuk metode Euler dari penurunan tersebut sebagai berikut. y(x_{i+1}) - y(x_{i}) = hf(x_{i},y(x_{i}))\\\\ atau\\\\ y(x_{i+1}) = y(x_{i}) + hf(x_{i},y(x_{i})) Contoh : Diketahui PDB \\dfrac{dy}{dt} = x + y dan y(0) = 1 gunakan metode Euler untuk menghitung y(0,10) dengan ukuran langkah h = 0.02 . Dan diketahui solusi PDB sejatinya = 1,1103 Jawab : Diketahui x_{0} = 0\\\\ y_{0} = 1\\\\ x_{b} = 0,10\\\\ h = 0,02\\\\ f(x,y) = x + y\\\\ hasil\\ analitik = 1,1103 Sehingga nilai n = (x_{b} - x_{0})/h = (0,10-0)/0,02 = 5 (banyaknya langkah) dan penerapan metode Euler pada PDB tersebut menjadi y_{i+1} = y_{i} + 0,02(x_{i}+y{i}) langkah-langkah: x_{0} = 0 \\Rightarrow y_{0} = 1\\\\ x_{1} = 0,02 \\Rightarrow y_{1} = y_{0}+0,02(x_{0}+y_{0}) = 1 + (0,02)(0+1) = 1,0200\\\\ x_{2} = 0,04 \\Rightarrow y_{2} = y_{1}+0,02(x_{1}+y_{1}) = 1,0200 + (0,02)(0,02+1,0200) = 1,0408\\\\ x_{3} = 0,06 \\Rightarrow y_{3} = y_{2}+0,02(x_{2}+y_{2}) = 1,0408 + (0,02)(0,04+1,0408) = 1,0624\\\\ x_{4} = 0,08 \\Rightarrow y_{4} = y_{3}+0,02(x_{3}+y_{3}) = 1,0624 + (0,02)(0,06+1,0624) = 1,0848\\\\ x_{5} = 0,10 \\Rightarrow y_{5} = y_{4}+0,02(x_{4}+y_{4}) = 1,0848 + (0,02)(0,08+1,0848) = 1,1081 Jadi solusi numerik dengan menggunakan metode Euler di y(0,10) = 1,1081 dan nilai error yang dihasilkan ialah e = hasil analitik - solusi numerik = 1,1103 - 1,1081 = 0,0022 Algoritma Metode Euler Deklarasi fungsi PDB yang akan di selesaikan, Masukkan inputan yang dibutuhkan seperti x_{0},y_{0},xb , dan h , Hitung perulangan yang diperlukan dengan menggunakan rumus n = (x_{b} - x_{0})/h , Inisialisasi nilai x dan y awal sama dengan x_{o} dan y_{0} , Tentukan nilai analitiknya untuk menghitung nilai error Lakukan perulangan sebanyak n, Setiap melakukan perulangan update nilai y dan x dengan menggunakan persamaan metode Euler, dan menghitung nilai erornya kemudian cetak hasilnya. Sorce Code Metode Euler def f ( x , y ): return x + y print ( \"Penyelesaian Persamaan Differensial Biasa Menggunakan Metode Euler\" ) x0 = float ( input ( \"Masukkan Nilai X0 : \" )) y0 = float ( input ( \"Masukkan Nilai y0 : \" )) xb = float ( input ( \"Masukkan Nilai X yang dicari : \" )) h = float ( input ( \"Masukkan Nilai h : \" )) n = ( xb - x0 ) / h iterasi = int ( n ) x = x0 y = y0 true = 1.1103 e = abs ( true - y ) print ( \"==================================================\" ) print ( \">>>>>>>>>>>>>>>>>>- METODE EULER -<<<<<<<<<<<<<<<<\" ) print ( \"==================================================\" ) print ( '|i' , ' \\t |' , 'x(i)' , ' \\t\\t |' , 'y(i) \\t\\t |e' ) print ( \"| %d \" % x0 , ' \\t |' , \" %f \" % x , ' \\t |' , \" %f \\t |\" % y , \" %f \" % e ) for i in range ( iterasi ): y = y + h * f ( x , y ) x = x + h e = abs ( true - y ) print ( \"| %d \" % ( i + 1 ), ' \\t |' , \" %f \" % x , ' \\t |' , \" %f \\t |\" % y , \" %f \" % e ) print ( \"==================================================\" ) Output hasil program sebagai berikut Penyelesaian Persamaan Differensial Biasa Menggunakan Metode Euler Masukkan Nilai X0 : 0 Masukkan Nilai y0 : 1 Masukkan Nilai X yang dicari : 0.1 Masukkan Nilai h : 0.02 ================================================== >>>>>>>>>>>>>>>>>>- METODE EULER -<<<<<<<<<<<<<<<< ================================================== |i | x(i) | y(i) |e |0 | 0.000000 | 1.000000 | 0.110300 |1 | 0.020000 | 1.020000 | 0.090300 |2 | 0.040000 | 1.040800 | 0.069500 |3 | 0.060000 | 1.062416 | 0.047884 |4 | 0.080000 | 1.084864 | 0.025436 |5 | 0.100000 | 1.108162 | 0.002138 ================================================== 2. Metode Heun \u00b6 \u200b Metode Heun merupakan metode perbaikan dari metode Euler yang memiliki nilai error yang tinggi. Pada metode Heun solusi dari metode Euler dijadikan sebagai solusi perkiraan awal( predictor ), selanjutnya solusi perkiraan awal tersebut diperbaiki dengan metode Heun( corrector ). 2 Sehingga persamaan metode Heun dituliskan sebagai berikut. Predictor= y^{0}_{i+1} = y_{i} + hf(x_{i},y_{i})\\\\ Corrector = y_{i+1} = y_{i}+\\dfrac{h}{2}[f(x_{i},y{i})+f(x_i+1),y^{0}_{i+1}] Sehingga tafsiran geometri metode Heun digambarkan sebagai berikut. Contoh : Diketahui PDB \\dfrac{dy}{dt} = x + y dan y(0) = 1 gunakan metode Heun untuk menghitung y(0,10) dengan ukuran langkah h = 0.02 . Dan diketahui solusi PDB sejatinya = 1,1103 Jawab : Diketahui x_{0} = 0\\\\ y_{0} = 1\\\\ x_{b} = 0,10\\\\ h = 0,02\\\\ f(x,y) = x + y\\\\ hasil\\ analitik = 1,1103 Maka nilai n = (x_{b} - x_{0})/h = (0,10-0)/0,02 = 5 (banyaknya langkah) dan penerapan metode Heun pada PDB tersebut menjadi : y_{i+1} = y_{i} + \\dfrac{0,02}{2}[(x_{i}+y{i})+((x_{i}+0,02)+y_{eu})] Langkah-langkah : x_{0} = 0\\Rightarrow y^{0} = 1\\\\ x_{1} = 0,02\\Rightarrow y_{1}= 1 +(\\dfrac{0,02}{2})(0+1+0,02+1,0200) = 1,0204\\\\ x_{2} = 0,04\\Rightarrow y_{2} = 1,0204 +(\\dfrac{0,02}{2})(0,02+1,0204+0,04+1,0412)=1,0416\\\\ x_{3} = 0,04\\Rightarrow y_{3} = 1,0416 +(\\dfrac{0,02}{2})(0,04+1,0204+0,06+1,0632)=1,0636\\\\ x_{4} = 0,04\\Rightarrow y_{4} = 1,0636 +(\\dfrac{0,02}{2})(0,06+1,0204+0,08+1,0861)=1,0865\\\\ x_{5} = 0,04\\Rightarrow y_{5} = 1,0865 +(\\dfrac{0,02}{2})(0,08+1,0204+0,10+1,1098)=1,1103\\\\ Jadi solusi numerik dengan menggunakan metode Heun di y(0,10) = 1,1103 dan nilai error yang dihasilkan ialah e = hasil analitik - solusi numerik = 1,1103 - 1,1103 = 0,0 . Algoritma Metode Heun Deklarasi fungsi PDB yang akan di selesaikan, Masukkan inputan yang dibutuhkan seperti x_{0},y_{0},xb , dan h , Hitung perulangan yang diperlukan dengan menggunakan rumus n = (x_{b} - x_{0})/h , Inisialisasi nilai x dan y awal sama dengan x_{o} dan y_{0} , Tentukan nilai analitiknya untuk menghitung nilai error Lakukan perulangan sebanyak n, Setiap melakukan perulangan update nilai y predictor dan y corrector serta x dengan menggunakan persamaan metode Heun, dan menghitung nilai erornya kemudian cetak hasilnya. Source Code Metode Heun def f ( x , y ): return x + y print ( \"Penyelesaian Persamaan Differensial Biasa Menggunakan Metode Heun\" ) x0 = float ( input ( \"Masukkan Nilai X0 : \" )) y0 = float ( input ( \"Masukkan Nilai y0 : \" )) xb = float ( input ( \"Masukkan Nilai X yang dicari : \" )) h = float ( input ( \"Masukkan Nilai h : \" )) iterasi = ( xb - x0 ) / h n = int ( iterasi ) x = x0 y = y0 true = 1.1103 e = abs ( true - y ) print ( \"==================================================\" ) print ( \">>>>>>>>>>>>>>>>>>- METODE HEUN -<<<<<<<<<<<<<<<<<\" ) print ( \"==================================================\" ) print ( '|i' , ' \\t |' , 'x(i)' , ' \\t\\t |' , 'y(i) \\t\\t |e' ) print ( \"| %d \" % x0 , ' \\t |' , \" %f \" % x , ' \\t |' , \" %f \\t |\" % y , \" %f \" % e ) for i in range ( n ): ypre = y + h * f ( x , y ) y = y + h / 2 * ( f ( x , y ) + f ( x + h , ypre )) x = x + h e = abs ( true - y ) print ( \"| %d \" % ( i + 1 ), ' \\t |' , \" %f \" % x , ' \\t |' , \" %f \\t |\" % y , \" %f \" % e ) print ( \"==================================================\" ) Ouput yang dihasilkan dari program di atas ialah sebagai berikut. Penyelesaian Persamaan Differensial Biasa Menggunakan Metode Heun Masukkan Nilai X0 : 0 Masukkan Nilai y0 : 1 Masukkan Nilai X yang dicari : 0.1 Masukkan Nilai h : 0.02 ================================================== >>>>>>>>>>>>>>>>>>- METODE HEUN -<<<<<<<<<<<<<<<<< ================================================== |i | x(i) | y(i) |e |0 | 0.000000 | 1.000000 | 0.110300 |1 | 0.020000 | 1.020400 | 0.089900 |2 | 0.040000 | 1.041616 | 0.068684 |3 | 0.060000 | 1.063665 | 0.046635 |4 | 0.080000 | 1.086563 | 0.023737 |5 | 0.100000 | 1.110327 | 0.000027 ================================================== 3. Metode Runge-Kutta \u00b6 \u200b Metode Runge-Kutta merupakan metode untuk menyelesaikan persamaan differensial biasa dengan ketelitian yang lebih tinggi, dan menghindarkan mencari turunan yang lebih tinggi dengan jalan mengevaluasi fungsi f(x,y) pada titik terpilih dalam setiap langkah. Metode ini merupakan metode yang paling poopuler dikarenakan banyak dipakai dalam praktek. 2 \u200b Bentuk umum metode runge-Kutta orde-n ialah: y_{i+1} = y_{i}+a_{1}k_{1}+a_{2}k_{2}+\\ldots+a_{n}k_{n} dengan a_{1},a_{2},...,a_{n} adalah tetapan dan k_{1} = hf(x_{i},y_{i})\\\\ k_{2} = hf(x_{i}+p_{1}h,y_{i}+q_{11}k_{1})\\\\ k_{3} = hf(x_{i}+p_{2}h,y_{i}+q_{21}k_{1}+q_{22}k_{2}\\\\ \\cdots\\\\ k_{n} = hf(x_{i}+p_{n-1}h,y_{i}+q_{n-1,1}k_{1}+q_{n-1,2}k_{2}+\\cdots+q_{n-1,n-1} k_{n-1} Dimana nilai a_{i}, p_{i}, q_{ij} dipilih sedemikian rupa sehingga meminimumkan galat perlangkah. Dan berikut ini metode Runge-Kutta berdasarkan ordenya 1. Metode Runge-Kutta Orde Satu \u00b6 Metode Runge-Kutta orde satu berbentuk k_{1} = hf(x_{i},y_{i})\\\\ y_{i+1} = y_{i}+k_{1}\\\\ atau\\\\ y_{i+1} = y_{i} +hf(x_i,y_{i}) Salah satu bentuk contoh dari metode Runge-Kutta orde 1 ialah metode Euler yang dapat dilihat dari bentuk persamaannya. Contoh : Diketahui PDB \\dfrac{dy}{dt} = x + y dan y(0) = 1 gunakan metode Runge-Kutta orde 1 untuk menghitung y(0,10) dengan ukuran langkah h = 0.02 . Dan diketahui solusi PDB sejatinya = 1,1103 Jawab : Diketahui x_{0} = 0\\\\ y_{0} = 1\\\\ x_{b} = 0,10\\\\ h = 0,02\\\\ f(x,y) = x + y\\\\ hasil\\ analitik = 1,1103 Maka nilai n = (x_{b} - x_{0})/h = (0,10-0)/0,02 = 5 (banyaknya langkah) dan penerapan metode Runge-Kutta orde satu pada PDB tersebut menjadi : y_{i+1} = y_{i} +k_{i} Langkah-langkah : x_{0} = 0 \\Rightarrow y_{0} = 1\\\\ x_{1} = 0,02 \\Rightarrow y_{1} = 1 + 0,0200 = 1,0200\\\\ x_{2} = 0,04 \\Rightarrow y_{2} = 1,0200+0,0208 = 1,0404\\\\ x_{3} = 0,06 \\Rightarrow y_{3} = 1,0404+0,0216 = 1,0624\\\\ x_{4} = 0,08 \\Rightarrow y_{4} = 1,0624+0,0254 = 1,0848\\\\ x_{5} = 0,10 \\Rightarrow y_{5} = 1,0848+0,0232 = 1,1081 Jadi solusi numerik dengan menggunakan metode Runge-Kutta orde 1 di y(0,10) = 1,1081 dan nilai error yang dihasilkan ialah e = hasil analitik - solusi numerik = 1,1103 - 1,1081 = 0,0022 Algoritma Metode Runge-Kutta Orde Satu Deklarasi fungsi PDB yang akan di selesaikan, Masukkan inputan yang dibutuhkan seperti x_{0},y_{0},xb , dan h , Hitung perulangan yang diperlukan dengan menggunakan rumus n = (x_{b} - x_{0})/h , Inisialisasi nilai x dan y awal sama dengan x_{o} dan y_{0} , Tentukan nilai analitiknya untuk menghitung nilai error Lakukan perulangan sebanyak n, Update nilai k_{1} , nilai y dan nilai x serta nilai e kemudian cetak nilai nilai tersebut setiap melakukan peulangan. Source Code Metode Runge-Kutta Orde Satu def f ( x , y ): return x + y print ( \"Penyelesaian Sistem Persamaan Differensial Biasa Menggunakan Metode Runge-Kutta Orde1\" ) x0 = float ( input ( \"Masukkan Nilai X0 : \" )) y0 = float ( input ( \"Masukkan Nilai y0 : \" )) xb = float ( input ( \"Masukkan Nilai X yang dicari : \" )) h = float ( input ( \"Masukkan Nilai h : \" )) iterasi = ( xb - x0 ) / h n = int ( iterasi ) x = x0 y = y0 true = 1.1103 e = abs ( true - y ) print ( \"==================================================================\" ) print ( \">>>>>>>>>>>>>>>>>>>>>>- METODE RUNGE-KUTTA1 -<<<<<<<<<<<<<<<<<<<<<\" ) print ( \"==================================================================\" ) print ( '|i' , ' \\t |' , 'x(i)' , ' \\t\\t |' , 'y(i) \\t\\t |e \\t\\t |k1' ) print ( \"| %d \" % x0 , ' \\t |' , \" %f \" % x , ' \\t |' , \" %f \\t |\" % y , \" %f \" % e , \" \\t |0\" ) for i in range ( n ): k1 = h * f ( x , y ) y = y + k1 x = x + h e = abs ( true - y ) print ( \"| %d \" % ( i + 1 ), ' \\t |' , \" %f \" % x , ' \\t |' , \" %f \\t |\" % y , \" %f \\t |\" % e , \" %f \" % k1 ) print ( \"==================================================================\" ) Dan hasil output program diatas sebagai berikut Penyelesaian Sistem Persamaan Differensial Biasa Menggunakan Metode Runge-Kutta Orde1 Masukkan Nilai X0 : 0 Masukkan Nilai y0 : 1 Masukkan Nilai X yang dicari : 0.1 Masukkan Nilai h : 0.02 ================================================================== >>>>>>>>>>>>>>>>>>>>>>- METODE RUNGE-KUTTA1 -<<<<<<<<<<<<<<<<<<<<< ================================================================== |i | x(i) | y(i) |e |k1 |0 | 0.000000 | 1.000000 | 0.110300 |0 |1 | 0.020000 | 1.020000 | 0.090300 | 0.020000 |2 | 0.040000 | 1.040800 | 0.069500 | 0.020800 |3 | 0.060000 | 1.062416 | 0.047884 | 0.021616 |4 | 0.080000 | 1.084864 | 0.025436 | 0.022448 |5 | 0.100000 | 1.108162 | 0.002138 | 0.023297 ================================================================== 2. Metode Runge-Kutta Orde Dua \u00b6 Metode Runge-Kutta orde dua berbentuk k_{1} = hf(x_{i},y_{i})\\\\ k_{2} = hf(x_{i}+h,y_{i}+k_{1})\\\\ y_{i+1}= y_{i}+\\dfrac{1}{2}h(k1+k2) Salah satu bentuk contoh dari metode Runge-Kutta orde 2 ialah metode Heun yang dapat dilihat dari bentuk persamaannya. Contoh : Diketahui PDB \\dfrac{dy}{dt} = x + y dan y(0) = 1 gunakan metode Runge-Kutta orde 2 untuk menghitung y(0,10) dengan ukuran langkah h = 0.02 . Dan diketahui solusi PDB sejatinya = 1,1103 Jawab : Diketahui x_{0} = 0\\\\ y_{0} = 1\\\\ x_{b} = 0,10\\\\ h = 0,02\\\\ f(x,y) = x + y\\\\ hasil\\ analitik = 1,1103 Maka nilai n = (x_{b} - x_{0})/h = (0,10-0)/0,02 = 5 (banyaknya langkah) dan penerapan metode Runge-Kutta orde satu pada PDB tersebut menjadi : y_{i+1}= y_{i}+\\dfrac{1}{2}0,02(k1+k2) Langkah-langkah : x_{0} = 0 \\Rightarrow y_{0} = 1\\\\ x_{1} = 0,02 \\Rightarrow y_{1} 1 + \\dfrac{1}{2}0,02(0,0200+0,0208) = 1,0204\\\\ x_{2} = 0,04 \\Rightarrow y_{2} 1,0204 + \\dfrac{1}{2}0,02(0,0208+0,0216) = 1,0416\\\\ x_{3} = 0,06 \\Rightarrow y_{3} 1,0416 + \\dfrac{1}{2}0,02(0,0216+0,0224) = 1,0636\\\\ x_{4} = 0,08 \\Rightarrow y_{4} 1,0636 + \\dfrac{1}{2}0,02(0,0224+0,0233) = 1,0865\\\\ x_{5} = 0,10 \\Rightarrow y_{1} 1,0865 + \\dfrac{1}{2}0,02(0,0233+0,0241) = 1,1103\\\\ Jadi solusi numerik dengan menggunakan metode Runge-Kutta orde 2 di y(0,10) = 1,1081 dan nilai error yang dihasilkan ialah e = hasil analitik - solusi numerik = 1,1103 - 1,1103 = 0,0 Algoritma Metode Runge-Kutta Orde Dua Deklarasi fungsi PDB yang akan di selesaikan, Masukkan inputan yang dibutuhkan seperti x_{0},y_{0},xb , dan h , Hitung perulangan yang diperlukan dengan menggunakan rumus n = (x_{b} - x_{0})/h , Inisialisasi nilai x dan y awal sama dengan x_{o} dan y_{0} , Tentukan nilai analitiknya untuk menghitung nilai error Lakukan perulangan sebanyak n, Update nilai k_{1} dan k_{2} , nilai y dan nilai x serta nilai e kemudian cetak nilai nilai tersebut setiap melakukan peulangan. Source Code Metode Runge-Kutta Orde Dua def f ( x , y ): return x + y print ( \"Penyelesaian Sistem Persamaan Differensial Biasa Menggunakan Metode Runge-Kutta Orde2\" ) x0 = float ( input ( \"Masukkan Nilai X0 : \" )) y0 = float ( input ( \"Masukkan Nilai y0 : \" )) xb = float ( input ( \"Masukkan Nilai X yang dicari : \" )) h = float ( input ( \"Masukkan Nilai h : \" )) iterasi = ( xb - x0 ) / h n = int ( iterasi ) x = x0 y = y0 true = 1.1103 e = abs ( true - y ) print ( \"==================================================================================\" ) print ( \">>>>>>>>>>>>>>>>>>>>>>>>>>>>>- METODE RUNGE-KUTTA2 -<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\" ) print ( \"==================================================================================\" ) print ( '|i' , ' \\t |' , 'x(i)' , ' \\t\\t |' , 'y(i) \\t\\t |e \\t\\t |k1 \\t\\t |k2' ) print ( \"| %d \" % x0 , ' \\t |' , \" %f \" % x , ' \\t |' , \" %f \\t |\" % y , \" %f \" % e , \" \\t |0 \\t\\t |0\" ) for i in range ( n ): k1 = h * f ( x , y ) k2 = h * f ( x + h , y + k1 ) y = y + ( k1 + k2 ) / 2 x = x + h e = abs ( true - y ) print ( \"| %d \" % ( i + 1 ), ' \\t |' , \" %f \" % x , ' \\t |' , \" %f \\t |\" % y , \" %f \\t |\" % e , \" %f \\t |\" % k1 , \" %f \" % k2 ) print ( \"==================================================================================\" ) Dan hasil output dari program diatas sebagai berikut Penyelesaian Sistem Persamaan Differensial Biasa Menggunakan Metode Runge-Kutta Orde2 Masukkan Nilai X0 : 0 Masukkan Nilai y0 : 1 Masukkan Nilai X yang dicari : 0.1 Masukkan Nilai h : 0.02 ================================================================================== >>>>>>>>>>>>>>>>>>>>>>>>>>>>>- METODE RUNGE-KUTTA2 -<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< ================================================================================== |i | x(i) | y(i) |e |k1 |k2 |0 | 0.000000 | 1.000000 | 0.110300 |0 |0 |1 | 0.020000 | 1.020400 | 0.089900 | 0.020000 | 0.020800 |2 | 0.040000 | 1.041616 | 0.068684 | 0.020808 | 0.021624 |3 | 0.060000 | 1.063665 | 0.046635 | 0.021632 | 0.022465 |4 | 0.080000 | 1.086563 | 0.023737 | 0.022473 | 0.023323 |5 | 0.100000 | 1.110327 | 0.000027 | 0.023331 | 0.024198 ================================================================================== 3. Metode Runge-Kutta Orde Tiga \u00b6 Metode Runge-Kutta orde tiga metode yang terkenal dikarenakan tingkat ketelitian solusinya tinggi dibandingkan metode Runge-Kutta sebelumnya. Bentuk metode Runge-Kutta orde tiga berbentuk k_{1} = hf(x_{i},y_{i})\\\\ k_{2} = hf(x_{i}+\\dfrac{h}{2},y_{i}+\\dfrac{k_{1}}{2})\\\\ k_{3} = hf(x_{i}+h,y_{i}-k{1}+2k_{2})\\\\ y_{i+1} = y_{i}+\\dfrac{(k_{1}+k_{2}+k_{3})}{6} Contoh : Diketahui PDB \\dfrac{dy}{dt} = x + y dan y(0) = 1 gunakan metode Runge-Kutta orde 3 untuk menghitung y(0,10) dengan ukuran langkah h = 0.02 . Dan diketahui solusi PDB sejatinya = 1,1103 Jawab : Diketahui x_{0} = 0\\\\ y_{0} = 1\\\\ x_{b} = 0,10\\\\ h = 0,02\\\\ f(x,y) = x + y\\\\ hasil\\ analitik = 1,1103 Maka nilai n = (x_{b} - x_{0})/h = (0,10-0)/0,02 = 5 (banyaknya langkah) dan penerapan metode Runge-Kutta orde tiga pada PDB tersebut menjadi : y_{i+1} = y_{i}+\\dfrac{(k_{1}+k_{2}+k_{3})}{6} Langkah-langkah: x_{0} = 0 \\Rightarrow y_{0} = 1\\\\ x_{1} = 0,02 \\Rightarrow y_{1} = 1 + \\dfrac{(0,0200+0,0204+0,0208)}{6} = 1,0204\\\\ x_{2} = 0,04 \\Rightarrow y_{2} = 1,0204 +\\dfrac{(0,0208+0,0212+0,0216)}{6}=1,0416\\\\ x_{3} = 0,06 \\Rightarrow y_{3} = 1,0416 +\\dfrac{(0,0216+0,0220+0,0224)}{6}=1,0636\\\\ x_{4} = 0,08 \\Rightarrow y_{4}= 1,0636 +\\dfrac{(0,0224+0,0228+0,0233)}{6}=1,0865\\\\ x_{5} = 0,10 \\Rightarrow y_{5} = 1,0865 +\\dfrac{(0,0233+0,0237+0,0242)}{6}=1,1103 Jadi solusi numerik dengan menggunakan metode Runge-Kutta orde tiga di y(0,10) = 1,1103 dan nilai error yang dihasilkan ialah e = hasil analitik - solusi numerik = 1,1103 - 1,1103 = 0,0 . Algoritma Metode Runge-Kutta Orde Tiga Deklarasi fungsi PDB yang akan di selesaikan, Masukkan inputan yang dibutuhkan seperti x_{0},y_{0},xb , dan h , Hitung perulangan yang diperlukan dengan menggunakan rumus n = (x_{b} - x_{0})/h , Inisialisasi nilai x dan y awal sama dengan x_{o} dan y_{0} , Tentukan nilai analitiknya untuk menghitung nilai error Lakukan perulangan sebanyak n, Update nilai k_{1} hinga k_{3} , nilai y dan nilai x serta nilai e kemudian cetak nilai nilai tersebut setiap melakukan peulangan. Source Code Metode Runge Kutta Orde Tiga def f ( x , y ): return x + y print ( \"Penyelesaian Persamaan Differensial Biasa Menggunakan Metode Runge-Kutta Orde3\" ) x0 = float ( input ( \"Masukkan Nilai X0 : \" )) y0 = float ( input ( \"Masukkan Nilai y0 : \" )) xb = float ( input ( \"Masukkan Nilai X yang dicari : \" )) h = float ( input ( \"Masukkan Nilai h : \" )) iterasi = ( xb - x0 ) / h n = int ( iterasi ) x = x0 y = y0 true = 1.1103 e = abs ( true - y ) print ( \"==================================================================================================\" ) print ( \">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>- METODE RUNGE-KUTTA ORDE 3 -<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\" ) print ( \"==================================================================================================\" ) print ( '|i \\t |x(i) \\t\\t |y(i) \\t\\t |e \\t\\t |k1 \\t\\t |k2 \\t\\t |k3' ) print ( \"| %d \" % x0 , ' \\t | %f ' % x , ' \\t | %f |' % y , ' \\t | %f ' % e , ' \\t |0' , ' \\t\\t |0' , ' \\t\\t |0' ) for i in range ( n ): k1 = h * f ( x , y ) k2 = h * f ( x + h / 2 , y + k1 / 2 ) k3 = h * f ( x + h , y - k1 + 2 * k2 ) y = y + ( k1 + 4 * k2 + k3 ) / 6 x = x + h e = abs ( true - y ) print ( \"| %d \" % ( i + 1 ), ' \\t |' , \" %f \" % x , ' \\t |' , \" %f \\t |\" % y , \" %f \\t |\" % e , \" %f \\t |\" % k1 , \" %f \\t |\" % k2 , \" %f \" % k3 ) print ( \"==================================================================================================\" ) Dan hasil output program diatas sebagai berikut. Penyelesaian Persamaan Differensial Biasa Menggunakan Metode Runge-Kutta Orde3 Masukkan Nilai X0 : 0 Masukkan Nilai y0 : 1 Masukkan Nilai X yang dicari : 0.1 Masukkan Nilai h : 0.02 ================================================================================================== >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>- METODE RUNGE-KUTTA ORDE 3 -<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< ================================================================================================== |i |x(i) |y(i) |e |k1 |k2 |k3 |0 |0.000000 |1.000000| |0.110300 |0 |0 |0 |1 | 0.020000 | 1.020403 | 0.089897 | 0.020000 | 0.020400 | 0.020816 |2 | 0.040000 | 1.041622 | 0.068678 | 0.020808 | 0.021216 | 0.021641 |3 | 0.060000 | 1.063673 | 0.046627 | 0.021632 | 0.022049 | 0.022482 |4 | 0.080000 | 1.086574 | 0.023726 | 0.022473 | 0.022898 | 0.023340 |5 | 0.100000 | 1.110342 | 0.000042 | 0.023331 | 0.023765 | 0.024215 ================================================================================================== 4. Metode Runge-Kutta Orde Empat \u00b6 Metode Runge-Kutta orde empat merupakan penyelesaian persamaaan differensial biasa dengan tingkat ketelitian yang tinggi. Bentuk Runge-Kutta orde empat berbentuk k_{1} = hf(x_{i},y_{i})\\\\ k_{2} = hf(x_{i}+\\dfrac{h}{2},y_{i}+\\dfrac{k1}{2})\\\\ k_{3} = hf(x_{i}+\\dfrac{h}{2},y_{i}+\\dfrac {k_{2}}{2})\\\\ k_{4} = hf(x_{i}+h,y_{i}+k_{3})\\\\ y_{i+1} = y_{i}+\\dfrac{k_{1}+2k_{2}+2k_{3}+k_{4}}{6} Contoh : Diketahui PDB \\dfrac{dy}{dt} = x + y dan y(0) = 1 gunakan metode Runge-Kutta orde 4 untuk menghitung y(0,10) dengan ukuran langkah h = 0.02 . Dan diketahui solusi PDB sejatinya = 1,1103 Jawab : Diketahui x_{0} = 0\\\\ y_{0} = 1\\\\ x_{b} = 0,10\\\\ h = 0,02\\\\ f(x,y) = x + y\\\\ hasil\\ analitik = 1,1103 Maka nilai n = (x_{b} - x_{0})/h = (0,10-0)/0,02 = 5 (banyaknya langkah) dan penerapan metode Runge-Kutta orde tiga pada PDB tersebut menjadi : y_{i+1} = y_{i}+\\dfrac{(k_{1}+2k_{2}+2k_{3}+k_{4})}{6} Langkah-langkah: x_{0} = 0 \\Rightarrow y_{0} = 1\\\\ x_{1} = 0,02 \\Rightarrow y_{1} = 1 +\\dfrac{0,0200+2(0,0204)+2(0,0204)+0,0208}{6}= 1,0204\\\\ x_{2} = 0,04 \\Rightarrow y_{2} = 1,0204 +\\dfrac{0,0208+2(0,0212)+2(0,0212)+0,0216}{6}= 1,0416\\\\ x_{3} = 0,06 \\Rightarrow y_{3} = 1,0416 +\\dfrac{0,0216+2(0,0220)+2(0,0220)+0,0224}{6}= 1,0636\\\\ x_{4} = 0,08 \\Rightarrow y_{4} = 1,0636 +\\dfrac{0,0224+2(0,0228)+2(0,0229)+0,0233}{6}= 1,0865\\\\ x_{5} = 0,10 \\Rightarrow y_{2} = 1,0204 +\\dfrac{0,0233+2(0,0237)+2(0,0237)+0,0242}{6}= 1,1103 Jadi solusi numerik dengan menggunakan metode Runge-Kutta orde empat di y(0,10) = 1,1103 dan nilai error yang dihasilkan ialah e = hasil analitik - solusi numerik = 1,1103 - 1,1103 = 0,0 . Algoritma Metode Runge-Kutta Orde Empat Deklarasi fungsi PDB yang akan di selesaikan, Masukkan inputan yang dibutuhkan seperti x_{0},y_{0},xb , dan h , Hitung perulangan yang diperlukan dengan menggunakan rumus n = (x_{b} - x_{0})/h , Inisialisasi nilai x dan y awal sama dengan x_{o} dan y_{0} , Tentukan nilai analitiknya untuk menghitung nilai error Lakukan perulangan sebanyak n, Update nilai k_{1} hinga k_{4} , nilai y dan nilai x serta nilai e kemudian cetak nilai nilai tersebut setiap melakukan peulangan. Source Code Metode Runge Kutta Orde Empat def f ( x , y ): return x + y print ( \"Penyelesaian Sistem Persamaan Differensial Biasa Menggunakan Metode Runge-Kutta Orde4\" ) x0 = float ( input ( \"Masukkan Nilai X0 : \" )) y0 = float ( input ( \"Masukkan Nilai y0 : \" )) xb = float ( input ( \"Masukkan Nilai X yang dicari : \" )) h = float ( input ( \"Masukkan Nilai h : \" )) iterasi = ( xb - x0 ) / h n = int ( iterasi ) x = x0 y = y0 true = 1.1103 e = abs ( true - y ) print ( \"==================================================================================================================\" ) print ( \">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>- METODE RUNGE-KUTTA ORDE 4 -<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\" ) print ( \"==================================================================================================================\" ) print ( '|i \\t |x(i) \\t\\t |y(i) \\t\\t |e \\t\\t |k1 \\t\\t |k2 \\t\\t |k3 \\t\\t |k4' ) print ( \"| %d \" % x0 , ' \\t | %f ' % x , ' \\t | %f |' % y , ' \\t | %f ' % e , ' \\t |0' , ' \\t\\t |0' , ' \\t\\t |0' , ' \\t\\t |0' ) for i in range ( n ): k1 = h * f ( x , y ) k2 = h * f ( x + h / 2 , y + k1 / 2 ) k3 = h * f ( x + h / 2 , y + k2 / 2 ) k4 = h * f ( x + h , y + k3 ) y = y + ( k1 + 2 * k2 + 2 * k3 + k4 ) / 6 x = x + h e = abs ( true - y ) print ( \"| %d \" % ( i + 1 ), ' \\t |' , \" %f \" % x , ' \\t |' , \" %f \\t |\" % y , \" %f \\t |\" % e , \" %f \\t |\" % k1 , \" %f \\t |\" % k2 , \" %f \\t |\" % k3 , \" %f \" % k4 ) print ( \"==================================================================================================================\" ) Dan output dari source code diatas ialah Penyelesaian Sistem Persamaan Differensial Biasa Menggunakan Metode Runge-Kutta Orde4 Masukkan Nilai X0 : 0 Masukkan Nilai y0 : 1 Masukkan Nilai X yang dicari : 0.1 Masukkan Nilai h : 0.02 ================================================================================================================== >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>- METODE RUNGE-KUTTA ORDE 3 -<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< ================================================================================================================== |i |x(i) |y(i) |e |k1 |k2 |k3 |k4 |0 |0.000000 |1.000000| |0.110300 |0 |0 |0 |0 |1 | 0.020000 | 1.020403 | 0.089897 | 0.020000 | 0.020400 | 0.020404 | 0.020808 |2 | 0.040000 | 1.041622 | 0.068678 | 0.020808 | 0.021216 | 0.021220 | 0.021632 |3 | 0.060000 | 1.063673 | 0.046627 | 0.021632 | 0.022049 | 0.022053 | 0.022473 |4 | 0.080000 | 1.086574 | 0.023726 | 0.022473 | 0.022898 | 0.022902 | 0.023332 |5 | 0.100000 | 1.110342 | 0.000042 | 0.023331 | 0.023765 | 0.023769 | 0.024207 ================================================================================================================== Referensi \u00b6 https://app.schoology.com/course/4711478201/materials/gp/4905811750 \u21a9 http://iffatul.staff.gunadarma.ac.id/Downloads/files/46564/BAb-+08+Solusi+Persamaan+Diferensial+Bi \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9","title":"Solusi Numerik Persamaan Differensial Biasa"},{"location":"Differensial/#persamaan_differensial_biasa_pdb","text":"","title":"PERSAMAAN DIFFERENSIAL BIASA (PDB)"},{"location":"Differensial/#a_definisi_persamaan_differensial_biasa_pdb","text":"\u200b Persamaan Differensial Biasa (PDB) merupakan persamaan differensial yang terdiri dari beberapa turunan biasa dari fungsi yang tidak diketahui dari variabel bebas tunggal. 1 Dan variabel bebas tersebut biasanya disimbolkan dengan x. Berikut merupakan contoh contoh persamaan differensial biasa. 2 Contoh : 1.\\ \\dfrac{dy}{dx} = x +y\\\\ 2.\\ y^{'} = x^{2}+y^{2}\\\\ 3.\\ \\dfrac{2dy}{dx} +x^{2}y-y = 0\\\\ 4.\\ y^{''} + y^{'}cos\\ x -3y = sin\\ 2x\\\\ 5.\\ 2y^{'''}-23y^{'} = 1 -y^{''} \u200b Variabel bebas dari contoh 1 hingga 5 adalah x dan variabel terikatnya ialah y yang merupakan fungsi dari x atau bisa ditulis y = f(x) . Berdasarkan turunnan tertinggi yang ada di persamaannya, PDB dikelompokkan lagi berdasarkan ordenya yaitu : 2 PDB orde 1 yaitu turunan tertingginya ialah turunan pertama, contohnya pada contoh nomor 1,2 dan 3 di atas. PDB orde 2 yaitu turunan tertingginya ialah turunan kedua, contohnya pada contoh nomor 4 di atas. PDB orde 3 yaitu turunan tertingginya ialah turunan ketiga, contohnya pada contoh nomor 5 diatas. Dan untuk PDB selanjutnya yang lebih tinggi dinamakan PDB orde lanjut. 2 Metode numerik dapat digunakan untuk menyelesaikan persamaan differensial biasa karena sebagian besar persamaan differensial tidak dapat diselesaikan secara analitik. Berikut ini pembahasan tentang metode numerik untuk menyelesaikan persamaan differensial biasa orde satu.","title":"A. Definisi Persamaan Differensial Biasa (PDB)"},{"location":"Differensial/#b_metode_persamaan_differensial_biasa_pdb","text":"\u200b Bentuk baku PDB orde satu dengan nilai awal dapat ditulis : y^{'} = f(x,y)\\ \\ \\ \\ \\ \\ atau\\ \\ \\ \\ \\ \\ \\dfrac{dy}{dx} = f(x,y) dengan nilai awal y(x0) = y PDB orde satu yang tidak mengikuti bentuk tersebut harus ditulis ulang seperti bentuk baku diatas agar dapat diselesaikan secara numerik. Penyelesaian PDB secara numerik berarti menghitung nilai fungsi di x_{i+1} = h , dengan h adalah ukuran langkah setiap lelaran. Pada metode analiti nilai awal berfungsi untuk memperoleh solusi yang unik, sedangkan pada metode numerik nilai awal berfungsi untuk memulai lelaran. Terdapat beberapa metode numerik yang digunakan untuk menyelesaikan PDB , mulai dari mrtode yang paling dasar hingga metode yang lebih teliti, diantanya ialah sebagai berikut. 2","title":"B. Metode Persamaan Differensial Biasa (PDB)"},{"location":"Differensial/#1_metode_euler","text":"\u200b Metode Euler adalah metode yang digunakan untuk menyelesaikan PDB yang dihasilkan dari turunan deret Taylor. Metode euler juga disebut metode orde-pertama dikarenakan hanya mengambil sampai suku pertama saja dari deret Taylor. Selain menggunakan bantuan deret Taylor, metode Euler juga dapat diturunkan dengan menggunakan metode aturan segiempat untuk mengintegrasikan f(x,y) pada persamaan diferensial. Tafsiran geometri penurunan metode Euler digambarkan sebagai berikut. 2 Sehingga bentuk metode Euler dari penurunan tersebut sebagai berikut. y(x_{i+1}) - y(x_{i}) = hf(x_{i},y(x_{i}))\\\\ atau\\\\ y(x_{i+1}) = y(x_{i}) + hf(x_{i},y(x_{i})) Contoh : Diketahui PDB \\dfrac{dy}{dt} = x + y dan y(0) = 1 gunakan metode Euler untuk menghitung y(0,10) dengan ukuran langkah h = 0.02 . Dan diketahui solusi PDB sejatinya = 1,1103 Jawab : Diketahui x_{0} = 0\\\\ y_{0} = 1\\\\ x_{b} = 0,10\\\\ h = 0,02\\\\ f(x,y) = x + y\\\\ hasil\\ analitik = 1,1103 Sehingga nilai n = (x_{b} - x_{0})/h = (0,10-0)/0,02 = 5 (banyaknya langkah) dan penerapan metode Euler pada PDB tersebut menjadi y_{i+1} = y_{i} + 0,02(x_{i}+y{i}) langkah-langkah: x_{0} = 0 \\Rightarrow y_{0} = 1\\\\ x_{1} = 0,02 \\Rightarrow y_{1} = y_{0}+0,02(x_{0}+y_{0}) = 1 + (0,02)(0+1) = 1,0200\\\\ x_{2} = 0,04 \\Rightarrow y_{2} = y_{1}+0,02(x_{1}+y_{1}) = 1,0200 + (0,02)(0,02+1,0200) = 1,0408\\\\ x_{3} = 0,06 \\Rightarrow y_{3} = y_{2}+0,02(x_{2}+y_{2}) = 1,0408 + (0,02)(0,04+1,0408) = 1,0624\\\\ x_{4} = 0,08 \\Rightarrow y_{4} = y_{3}+0,02(x_{3}+y_{3}) = 1,0624 + (0,02)(0,06+1,0624) = 1,0848\\\\ x_{5} = 0,10 \\Rightarrow y_{5} = y_{4}+0,02(x_{4}+y_{4}) = 1,0848 + (0,02)(0,08+1,0848) = 1,1081 Jadi solusi numerik dengan menggunakan metode Euler di y(0,10) = 1,1081 dan nilai error yang dihasilkan ialah e = hasil analitik - solusi numerik = 1,1103 - 1,1081 = 0,0022 Algoritma Metode Euler Deklarasi fungsi PDB yang akan di selesaikan, Masukkan inputan yang dibutuhkan seperti x_{0},y_{0},xb , dan h , Hitung perulangan yang diperlukan dengan menggunakan rumus n = (x_{b} - x_{0})/h , Inisialisasi nilai x dan y awal sama dengan x_{o} dan y_{0} , Tentukan nilai analitiknya untuk menghitung nilai error Lakukan perulangan sebanyak n, Setiap melakukan perulangan update nilai y dan x dengan menggunakan persamaan metode Euler, dan menghitung nilai erornya kemudian cetak hasilnya. Sorce Code Metode Euler def f ( x , y ): return x + y print ( \"Penyelesaian Persamaan Differensial Biasa Menggunakan Metode Euler\" ) x0 = float ( input ( \"Masukkan Nilai X0 : \" )) y0 = float ( input ( \"Masukkan Nilai y0 : \" )) xb = float ( input ( \"Masukkan Nilai X yang dicari : \" )) h = float ( input ( \"Masukkan Nilai h : \" )) n = ( xb - x0 ) / h iterasi = int ( n ) x = x0 y = y0 true = 1.1103 e = abs ( true - y ) print ( \"==================================================\" ) print ( \">>>>>>>>>>>>>>>>>>- METODE EULER -<<<<<<<<<<<<<<<<\" ) print ( \"==================================================\" ) print ( '|i' , ' \\t |' , 'x(i)' , ' \\t\\t |' , 'y(i) \\t\\t |e' ) print ( \"| %d \" % x0 , ' \\t |' , \" %f \" % x , ' \\t |' , \" %f \\t |\" % y , \" %f \" % e ) for i in range ( iterasi ): y = y + h * f ( x , y ) x = x + h e = abs ( true - y ) print ( \"| %d \" % ( i + 1 ), ' \\t |' , \" %f \" % x , ' \\t |' , \" %f \\t |\" % y , \" %f \" % e ) print ( \"==================================================\" ) Output hasil program sebagai berikut Penyelesaian Persamaan Differensial Biasa Menggunakan Metode Euler Masukkan Nilai X0 : 0 Masukkan Nilai y0 : 1 Masukkan Nilai X yang dicari : 0.1 Masukkan Nilai h : 0.02 ================================================== >>>>>>>>>>>>>>>>>>- METODE EULER -<<<<<<<<<<<<<<<< ================================================== |i | x(i) | y(i) |e |0 | 0.000000 | 1.000000 | 0.110300 |1 | 0.020000 | 1.020000 | 0.090300 |2 | 0.040000 | 1.040800 | 0.069500 |3 | 0.060000 | 1.062416 | 0.047884 |4 | 0.080000 | 1.084864 | 0.025436 |5 | 0.100000 | 1.108162 | 0.002138 ==================================================","title":"1. Metode Euler"},{"location":"Differensial/#2_metode_heun","text":"\u200b Metode Heun merupakan metode perbaikan dari metode Euler yang memiliki nilai error yang tinggi. Pada metode Heun solusi dari metode Euler dijadikan sebagai solusi perkiraan awal( predictor ), selanjutnya solusi perkiraan awal tersebut diperbaiki dengan metode Heun( corrector ). 2 Sehingga persamaan metode Heun dituliskan sebagai berikut. Predictor= y^{0}_{i+1} = y_{i} + hf(x_{i},y_{i})\\\\ Corrector = y_{i+1} = y_{i}+\\dfrac{h}{2}[f(x_{i},y{i})+f(x_i+1),y^{0}_{i+1}] Sehingga tafsiran geometri metode Heun digambarkan sebagai berikut. Contoh : Diketahui PDB \\dfrac{dy}{dt} = x + y dan y(0) = 1 gunakan metode Heun untuk menghitung y(0,10) dengan ukuran langkah h = 0.02 . Dan diketahui solusi PDB sejatinya = 1,1103 Jawab : Diketahui x_{0} = 0\\\\ y_{0} = 1\\\\ x_{b} = 0,10\\\\ h = 0,02\\\\ f(x,y) = x + y\\\\ hasil\\ analitik = 1,1103 Maka nilai n = (x_{b} - x_{0})/h = (0,10-0)/0,02 = 5 (banyaknya langkah) dan penerapan metode Heun pada PDB tersebut menjadi : y_{i+1} = y_{i} + \\dfrac{0,02}{2}[(x_{i}+y{i})+((x_{i}+0,02)+y_{eu})] Langkah-langkah : x_{0} = 0\\Rightarrow y^{0} = 1\\\\ x_{1} = 0,02\\Rightarrow y_{1}= 1 +(\\dfrac{0,02}{2})(0+1+0,02+1,0200) = 1,0204\\\\ x_{2} = 0,04\\Rightarrow y_{2} = 1,0204 +(\\dfrac{0,02}{2})(0,02+1,0204+0,04+1,0412)=1,0416\\\\ x_{3} = 0,04\\Rightarrow y_{3} = 1,0416 +(\\dfrac{0,02}{2})(0,04+1,0204+0,06+1,0632)=1,0636\\\\ x_{4} = 0,04\\Rightarrow y_{4} = 1,0636 +(\\dfrac{0,02}{2})(0,06+1,0204+0,08+1,0861)=1,0865\\\\ x_{5} = 0,04\\Rightarrow y_{5} = 1,0865 +(\\dfrac{0,02}{2})(0,08+1,0204+0,10+1,1098)=1,1103\\\\ Jadi solusi numerik dengan menggunakan metode Heun di y(0,10) = 1,1103 dan nilai error yang dihasilkan ialah e = hasil analitik - solusi numerik = 1,1103 - 1,1103 = 0,0 . Algoritma Metode Heun Deklarasi fungsi PDB yang akan di selesaikan, Masukkan inputan yang dibutuhkan seperti x_{0},y_{0},xb , dan h , Hitung perulangan yang diperlukan dengan menggunakan rumus n = (x_{b} - x_{0})/h , Inisialisasi nilai x dan y awal sama dengan x_{o} dan y_{0} , Tentukan nilai analitiknya untuk menghitung nilai error Lakukan perulangan sebanyak n, Setiap melakukan perulangan update nilai y predictor dan y corrector serta x dengan menggunakan persamaan metode Heun, dan menghitung nilai erornya kemudian cetak hasilnya. Source Code Metode Heun def f ( x , y ): return x + y print ( \"Penyelesaian Persamaan Differensial Biasa Menggunakan Metode Heun\" ) x0 = float ( input ( \"Masukkan Nilai X0 : \" )) y0 = float ( input ( \"Masukkan Nilai y0 : \" )) xb = float ( input ( \"Masukkan Nilai X yang dicari : \" )) h = float ( input ( \"Masukkan Nilai h : \" )) iterasi = ( xb - x0 ) / h n = int ( iterasi ) x = x0 y = y0 true = 1.1103 e = abs ( true - y ) print ( \"==================================================\" ) print ( \">>>>>>>>>>>>>>>>>>- METODE HEUN -<<<<<<<<<<<<<<<<<\" ) print ( \"==================================================\" ) print ( '|i' , ' \\t |' , 'x(i)' , ' \\t\\t |' , 'y(i) \\t\\t |e' ) print ( \"| %d \" % x0 , ' \\t |' , \" %f \" % x , ' \\t |' , \" %f \\t |\" % y , \" %f \" % e ) for i in range ( n ): ypre = y + h * f ( x , y ) y = y + h / 2 * ( f ( x , y ) + f ( x + h , ypre )) x = x + h e = abs ( true - y ) print ( \"| %d \" % ( i + 1 ), ' \\t |' , \" %f \" % x , ' \\t |' , \" %f \\t |\" % y , \" %f \" % e ) print ( \"==================================================\" ) Ouput yang dihasilkan dari program di atas ialah sebagai berikut. Penyelesaian Persamaan Differensial Biasa Menggunakan Metode Heun Masukkan Nilai X0 : 0 Masukkan Nilai y0 : 1 Masukkan Nilai X yang dicari : 0.1 Masukkan Nilai h : 0.02 ================================================== >>>>>>>>>>>>>>>>>>- METODE HEUN -<<<<<<<<<<<<<<<<< ================================================== |i | x(i) | y(i) |e |0 | 0.000000 | 1.000000 | 0.110300 |1 | 0.020000 | 1.020400 | 0.089900 |2 | 0.040000 | 1.041616 | 0.068684 |3 | 0.060000 | 1.063665 | 0.046635 |4 | 0.080000 | 1.086563 | 0.023737 |5 | 0.100000 | 1.110327 | 0.000027 ==================================================","title":"2. Metode Heun"},{"location":"Differensial/#3_metode_runge-kutta","text":"\u200b Metode Runge-Kutta merupakan metode untuk menyelesaikan persamaan differensial biasa dengan ketelitian yang lebih tinggi, dan menghindarkan mencari turunan yang lebih tinggi dengan jalan mengevaluasi fungsi f(x,y) pada titik terpilih dalam setiap langkah. Metode ini merupakan metode yang paling poopuler dikarenakan banyak dipakai dalam praktek. 2 \u200b Bentuk umum metode runge-Kutta orde-n ialah: y_{i+1} = y_{i}+a_{1}k_{1}+a_{2}k_{2}+\\ldots+a_{n}k_{n} dengan a_{1},a_{2},...,a_{n} adalah tetapan dan k_{1} = hf(x_{i},y_{i})\\\\ k_{2} = hf(x_{i}+p_{1}h,y_{i}+q_{11}k_{1})\\\\ k_{3} = hf(x_{i}+p_{2}h,y_{i}+q_{21}k_{1}+q_{22}k_{2}\\\\ \\cdots\\\\ k_{n} = hf(x_{i}+p_{n-1}h,y_{i}+q_{n-1,1}k_{1}+q_{n-1,2}k_{2}+\\cdots+q_{n-1,n-1} k_{n-1} Dimana nilai a_{i}, p_{i}, q_{ij} dipilih sedemikian rupa sehingga meminimumkan galat perlangkah. Dan berikut ini metode Runge-Kutta berdasarkan ordenya","title":"3. Metode Runge-Kutta"},{"location":"Differensial/#1_metode_runge-kutta_orde_satu","text":"Metode Runge-Kutta orde satu berbentuk k_{1} = hf(x_{i},y_{i})\\\\ y_{i+1} = y_{i}+k_{1}\\\\ atau\\\\ y_{i+1} = y_{i} +hf(x_i,y_{i}) Salah satu bentuk contoh dari metode Runge-Kutta orde 1 ialah metode Euler yang dapat dilihat dari bentuk persamaannya. Contoh : Diketahui PDB \\dfrac{dy}{dt} = x + y dan y(0) = 1 gunakan metode Runge-Kutta orde 1 untuk menghitung y(0,10) dengan ukuran langkah h = 0.02 . Dan diketahui solusi PDB sejatinya = 1,1103 Jawab : Diketahui x_{0} = 0\\\\ y_{0} = 1\\\\ x_{b} = 0,10\\\\ h = 0,02\\\\ f(x,y) = x + y\\\\ hasil\\ analitik = 1,1103 Maka nilai n = (x_{b} - x_{0})/h = (0,10-0)/0,02 = 5 (banyaknya langkah) dan penerapan metode Runge-Kutta orde satu pada PDB tersebut menjadi : y_{i+1} = y_{i} +k_{i} Langkah-langkah : x_{0} = 0 \\Rightarrow y_{0} = 1\\\\ x_{1} = 0,02 \\Rightarrow y_{1} = 1 + 0,0200 = 1,0200\\\\ x_{2} = 0,04 \\Rightarrow y_{2} = 1,0200+0,0208 = 1,0404\\\\ x_{3} = 0,06 \\Rightarrow y_{3} = 1,0404+0,0216 = 1,0624\\\\ x_{4} = 0,08 \\Rightarrow y_{4} = 1,0624+0,0254 = 1,0848\\\\ x_{5} = 0,10 \\Rightarrow y_{5} = 1,0848+0,0232 = 1,1081 Jadi solusi numerik dengan menggunakan metode Runge-Kutta orde 1 di y(0,10) = 1,1081 dan nilai error yang dihasilkan ialah e = hasil analitik - solusi numerik = 1,1103 - 1,1081 = 0,0022 Algoritma Metode Runge-Kutta Orde Satu Deklarasi fungsi PDB yang akan di selesaikan, Masukkan inputan yang dibutuhkan seperti x_{0},y_{0},xb , dan h , Hitung perulangan yang diperlukan dengan menggunakan rumus n = (x_{b} - x_{0})/h , Inisialisasi nilai x dan y awal sama dengan x_{o} dan y_{0} , Tentukan nilai analitiknya untuk menghitung nilai error Lakukan perulangan sebanyak n, Update nilai k_{1} , nilai y dan nilai x serta nilai e kemudian cetak nilai nilai tersebut setiap melakukan peulangan. Source Code Metode Runge-Kutta Orde Satu def f ( x , y ): return x + y print ( \"Penyelesaian Sistem Persamaan Differensial Biasa Menggunakan Metode Runge-Kutta Orde1\" ) x0 = float ( input ( \"Masukkan Nilai X0 : \" )) y0 = float ( input ( \"Masukkan Nilai y0 : \" )) xb = float ( input ( \"Masukkan Nilai X yang dicari : \" )) h = float ( input ( \"Masukkan Nilai h : \" )) iterasi = ( xb - x0 ) / h n = int ( iterasi ) x = x0 y = y0 true = 1.1103 e = abs ( true - y ) print ( \"==================================================================\" ) print ( \">>>>>>>>>>>>>>>>>>>>>>- METODE RUNGE-KUTTA1 -<<<<<<<<<<<<<<<<<<<<<\" ) print ( \"==================================================================\" ) print ( '|i' , ' \\t |' , 'x(i)' , ' \\t\\t |' , 'y(i) \\t\\t |e \\t\\t |k1' ) print ( \"| %d \" % x0 , ' \\t |' , \" %f \" % x , ' \\t |' , \" %f \\t |\" % y , \" %f \" % e , \" \\t |0\" ) for i in range ( n ): k1 = h * f ( x , y ) y = y + k1 x = x + h e = abs ( true - y ) print ( \"| %d \" % ( i + 1 ), ' \\t |' , \" %f \" % x , ' \\t |' , \" %f \\t |\" % y , \" %f \\t |\" % e , \" %f \" % k1 ) print ( \"==================================================================\" ) Dan hasil output program diatas sebagai berikut Penyelesaian Sistem Persamaan Differensial Biasa Menggunakan Metode Runge-Kutta Orde1 Masukkan Nilai X0 : 0 Masukkan Nilai y0 : 1 Masukkan Nilai X yang dicari : 0.1 Masukkan Nilai h : 0.02 ================================================================== >>>>>>>>>>>>>>>>>>>>>>- METODE RUNGE-KUTTA1 -<<<<<<<<<<<<<<<<<<<<< ================================================================== |i | x(i) | y(i) |e |k1 |0 | 0.000000 | 1.000000 | 0.110300 |0 |1 | 0.020000 | 1.020000 | 0.090300 | 0.020000 |2 | 0.040000 | 1.040800 | 0.069500 | 0.020800 |3 | 0.060000 | 1.062416 | 0.047884 | 0.021616 |4 | 0.080000 | 1.084864 | 0.025436 | 0.022448 |5 | 0.100000 | 1.108162 | 0.002138 | 0.023297 ==================================================================","title":"1. Metode Runge-Kutta Orde Satu"},{"location":"Differensial/#2_metode_runge-kutta_orde_dua","text":"Metode Runge-Kutta orde dua berbentuk k_{1} = hf(x_{i},y_{i})\\\\ k_{2} = hf(x_{i}+h,y_{i}+k_{1})\\\\ y_{i+1}= y_{i}+\\dfrac{1}{2}h(k1+k2) Salah satu bentuk contoh dari metode Runge-Kutta orde 2 ialah metode Heun yang dapat dilihat dari bentuk persamaannya. Contoh : Diketahui PDB \\dfrac{dy}{dt} = x + y dan y(0) = 1 gunakan metode Runge-Kutta orde 2 untuk menghitung y(0,10) dengan ukuran langkah h = 0.02 . Dan diketahui solusi PDB sejatinya = 1,1103 Jawab : Diketahui x_{0} = 0\\\\ y_{0} = 1\\\\ x_{b} = 0,10\\\\ h = 0,02\\\\ f(x,y) = x + y\\\\ hasil\\ analitik = 1,1103 Maka nilai n = (x_{b} - x_{0})/h = (0,10-0)/0,02 = 5 (banyaknya langkah) dan penerapan metode Runge-Kutta orde satu pada PDB tersebut menjadi : y_{i+1}= y_{i}+\\dfrac{1}{2}0,02(k1+k2) Langkah-langkah : x_{0} = 0 \\Rightarrow y_{0} = 1\\\\ x_{1} = 0,02 \\Rightarrow y_{1} 1 + \\dfrac{1}{2}0,02(0,0200+0,0208) = 1,0204\\\\ x_{2} = 0,04 \\Rightarrow y_{2} 1,0204 + \\dfrac{1}{2}0,02(0,0208+0,0216) = 1,0416\\\\ x_{3} = 0,06 \\Rightarrow y_{3} 1,0416 + \\dfrac{1}{2}0,02(0,0216+0,0224) = 1,0636\\\\ x_{4} = 0,08 \\Rightarrow y_{4} 1,0636 + \\dfrac{1}{2}0,02(0,0224+0,0233) = 1,0865\\\\ x_{5} = 0,10 \\Rightarrow y_{1} 1,0865 + \\dfrac{1}{2}0,02(0,0233+0,0241) = 1,1103\\\\ Jadi solusi numerik dengan menggunakan metode Runge-Kutta orde 2 di y(0,10) = 1,1081 dan nilai error yang dihasilkan ialah e = hasil analitik - solusi numerik = 1,1103 - 1,1103 = 0,0 Algoritma Metode Runge-Kutta Orde Dua Deklarasi fungsi PDB yang akan di selesaikan, Masukkan inputan yang dibutuhkan seperti x_{0},y_{0},xb , dan h , Hitung perulangan yang diperlukan dengan menggunakan rumus n = (x_{b} - x_{0})/h , Inisialisasi nilai x dan y awal sama dengan x_{o} dan y_{0} , Tentukan nilai analitiknya untuk menghitung nilai error Lakukan perulangan sebanyak n, Update nilai k_{1} dan k_{2} , nilai y dan nilai x serta nilai e kemudian cetak nilai nilai tersebut setiap melakukan peulangan. Source Code Metode Runge-Kutta Orde Dua def f ( x , y ): return x + y print ( \"Penyelesaian Sistem Persamaan Differensial Biasa Menggunakan Metode Runge-Kutta Orde2\" ) x0 = float ( input ( \"Masukkan Nilai X0 : \" )) y0 = float ( input ( \"Masukkan Nilai y0 : \" )) xb = float ( input ( \"Masukkan Nilai X yang dicari : \" )) h = float ( input ( \"Masukkan Nilai h : \" )) iterasi = ( xb - x0 ) / h n = int ( iterasi ) x = x0 y = y0 true = 1.1103 e = abs ( true - y ) print ( \"==================================================================================\" ) print ( \">>>>>>>>>>>>>>>>>>>>>>>>>>>>>- METODE RUNGE-KUTTA2 -<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\" ) print ( \"==================================================================================\" ) print ( '|i' , ' \\t |' , 'x(i)' , ' \\t\\t |' , 'y(i) \\t\\t |e \\t\\t |k1 \\t\\t |k2' ) print ( \"| %d \" % x0 , ' \\t |' , \" %f \" % x , ' \\t |' , \" %f \\t |\" % y , \" %f \" % e , \" \\t |0 \\t\\t |0\" ) for i in range ( n ): k1 = h * f ( x , y ) k2 = h * f ( x + h , y + k1 ) y = y + ( k1 + k2 ) / 2 x = x + h e = abs ( true - y ) print ( \"| %d \" % ( i + 1 ), ' \\t |' , \" %f \" % x , ' \\t |' , \" %f \\t |\" % y , \" %f \\t |\" % e , \" %f \\t |\" % k1 , \" %f \" % k2 ) print ( \"==================================================================================\" ) Dan hasil output dari program diatas sebagai berikut Penyelesaian Sistem Persamaan Differensial Biasa Menggunakan Metode Runge-Kutta Orde2 Masukkan Nilai X0 : 0 Masukkan Nilai y0 : 1 Masukkan Nilai X yang dicari : 0.1 Masukkan Nilai h : 0.02 ================================================================================== >>>>>>>>>>>>>>>>>>>>>>>>>>>>>- METODE RUNGE-KUTTA2 -<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< ================================================================================== |i | x(i) | y(i) |e |k1 |k2 |0 | 0.000000 | 1.000000 | 0.110300 |0 |0 |1 | 0.020000 | 1.020400 | 0.089900 | 0.020000 | 0.020800 |2 | 0.040000 | 1.041616 | 0.068684 | 0.020808 | 0.021624 |3 | 0.060000 | 1.063665 | 0.046635 | 0.021632 | 0.022465 |4 | 0.080000 | 1.086563 | 0.023737 | 0.022473 | 0.023323 |5 | 0.100000 | 1.110327 | 0.000027 | 0.023331 | 0.024198 ==================================================================================","title":"2. Metode Runge-Kutta Orde Dua"},{"location":"Differensial/#3_metode_runge-kutta_orde_tiga","text":"Metode Runge-Kutta orde tiga metode yang terkenal dikarenakan tingkat ketelitian solusinya tinggi dibandingkan metode Runge-Kutta sebelumnya. Bentuk metode Runge-Kutta orde tiga berbentuk k_{1} = hf(x_{i},y_{i})\\\\ k_{2} = hf(x_{i}+\\dfrac{h}{2},y_{i}+\\dfrac{k_{1}}{2})\\\\ k_{3} = hf(x_{i}+h,y_{i}-k{1}+2k_{2})\\\\ y_{i+1} = y_{i}+\\dfrac{(k_{1}+k_{2}+k_{3})}{6} Contoh : Diketahui PDB \\dfrac{dy}{dt} = x + y dan y(0) = 1 gunakan metode Runge-Kutta orde 3 untuk menghitung y(0,10) dengan ukuran langkah h = 0.02 . Dan diketahui solusi PDB sejatinya = 1,1103 Jawab : Diketahui x_{0} = 0\\\\ y_{0} = 1\\\\ x_{b} = 0,10\\\\ h = 0,02\\\\ f(x,y) = x + y\\\\ hasil\\ analitik = 1,1103 Maka nilai n = (x_{b} - x_{0})/h = (0,10-0)/0,02 = 5 (banyaknya langkah) dan penerapan metode Runge-Kutta orde tiga pada PDB tersebut menjadi : y_{i+1} = y_{i}+\\dfrac{(k_{1}+k_{2}+k_{3})}{6} Langkah-langkah: x_{0} = 0 \\Rightarrow y_{0} = 1\\\\ x_{1} = 0,02 \\Rightarrow y_{1} = 1 + \\dfrac{(0,0200+0,0204+0,0208)}{6} = 1,0204\\\\ x_{2} = 0,04 \\Rightarrow y_{2} = 1,0204 +\\dfrac{(0,0208+0,0212+0,0216)}{6}=1,0416\\\\ x_{3} = 0,06 \\Rightarrow y_{3} = 1,0416 +\\dfrac{(0,0216+0,0220+0,0224)}{6}=1,0636\\\\ x_{4} = 0,08 \\Rightarrow y_{4}= 1,0636 +\\dfrac{(0,0224+0,0228+0,0233)}{6}=1,0865\\\\ x_{5} = 0,10 \\Rightarrow y_{5} = 1,0865 +\\dfrac{(0,0233+0,0237+0,0242)}{6}=1,1103 Jadi solusi numerik dengan menggunakan metode Runge-Kutta orde tiga di y(0,10) = 1,1103 dan nilai error yang dihasilkan ialah e = hasil analitik - solusi numerik = 1,1103 - 1,1103 = 0,0 . Algoritma Metode Runge-Kutta Orde Tiga Deklarasi fungsi PDB yang akan di selesaikan, Masukkan inputan yang dibutuhkan seperti x_{0},y_{0},xb , dan h , Hitung perulangan yang diperlukan dengan menggunakan rumus n = (x_{b} - x_{0})/h , Inisialisasi nilai x dan y awal sama dengan x_{o} dan y_{0} , Tentukan nilai analitiknya untuk menghitung nilai error Lakukan perulangan sebanyak n, Update nilai k_{1} hinga k_{3} , nilai y dan nilai x serta nilai e kemudian cetak nilai nilai tersebut setiap melakukan peulangan. Source Code Metode Runge Kutta Orde Tiga def f ( x , y ): return x + y print ( \"Penyelesaian Persamaan Differensial Biasa Menggunakan Metode Runge-Kutta Orde3\" ) x0 = float ( input ( \"Masukkan Nilai X0 : \" )) y0 = float ( input ( \"Masukkan Nilai y0 : \" )) xb = float ( input ( \"Masukkan Nilai X yang dicari : \" )) h = float ( input ( \"Masukkan Nilai h : \" )) iterasi = ( xb - x0 ) / h n = int ( iterasi ) x = x0 y = y0 true = 1.1103 e = abs ( true - y ) print ( \"==================================================================================================\" ) print ( \">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>- METODE RUNGE-KUTTA ORDE 3 -<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\" ) print ( \"==================================================================================================\" ) print ( '|i \\t |x(i) \\t\\t |y(i) \\t\\t |e \\t\\t |k1 \\t\\t |k2 \\t\\t |k3' ) print ( \"| %d \" % x0 , ' \\t | %f ' % x , ' \\t | %f |' % y , ' \\t | %f ' % e , ' \\t |0' , ' \\t\\t |0' , ' \\t\\t |0' ) for i in range ( n ): k1 = h * f ( x , y ) k2 = h * f ( x + h / 2 , y + k1 / 2 ) k3 = h * f ( x + h , y - k1 + 2 * k2 ) y = y + ( k1 + 4 * k2 + k3 ) / 6 x = x + h e = abs ( true - y ) print ( \"| %d \" % ( i + 1 ), ' \\t |' , \" %f \" % x , ' \\t |' , \" %f \\t |\" % y , \" %f \\t |\" % e , \" %f \\t |\" % k1 , \" %f \\t |\" % k2 , \" %f \" % k3 ) print ( \"==================================================================================================\" ) Dan hasil output program diatas sebagai berikut. Penyelesaian Persamaan Differensial Biasa Menggunakan Metode Runge-Kutta Orde3 Masukkan Nilai X0 : 0 Masukkan Nilai y0 : 1 Masukkan Nilai X yang dicari : 0.1 Masukkan Nilai h : 0.02 ================================================================================================== >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>- METODE RUNGE-KUTTA ORDE 3 -<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< ================================================================================================== |i |x(i) |y(i) |e |k1 |k2 |k3 |0 |0.000000 |1.000000| |0.110300 |0 |0 |0 |1 | 0.020000 | 1.020403 | 0.089897 | 0.020000 | 0.020400 | 0.020816 |2 | 0.040000 | 1.041622 | 0.068678 | 0.020808 | 0.021216 | 0.021641 |3 | 0.060000 | 1.063673 | 0.046627 | 0.021632 | 0.022049 | 0.022482 |4 | 0.080000 | 1.086574 | 0.023726 | 0.022473 | 0.022898 | 0.023340 |5 | 0.100000 | 1.110342 | 0.000042 | 0.023331 | 0.023765 | 0.024215 ==================================================================================================","title":"3. Metode Runge-Kutta Orde Tiga"},{"location":"Differensial/#4_metode_runge-kutta_orde_empat","text":"Metode Runge-Kutta orde empat merupakan penyelesaian persamaaan differensial biasa dengan tingkat ketelitian yang tinggi. Bentuk Runge-Kutta orde empat berbentuk k_{1} = hf(x_{i},y_{i})\\\\ k_{2} = hf(x_{i}+\\dfrac{h}{2},y_{i}+\\dfrac{k1}{2})\\\\ k_{3} = hf(x_{i}+\\dfrac{h}{2},y_{i}+\\dfrac {k_{2}}{2})\\\\ k_{4} = hf(x_{i}+h,y_{i}+k_{3})\\\\ y_{i+1} = y_{i}+\\dfrac{k_{1}+2k_{2}+2k_{3}+k_{4}}{6} Contoh : Diketahui PDB \\dfrac{dy}{dt} = x + y dan y(0) = 1 gunakan metode Runge-Kutta orde 4 untuk menghitung y(0,10) dengan ukuran langkah h = 0.02 . Dan diketahui solusi PDB sejatinya = 1,1103 Jawab : Diketahui x_{0} = 0\\\\ y_{0} = 1\\\\ x_{b} = 0,10\\\\ h = 0,02\\\\ f(x,y) = x + y\\\\ hasil\\ analitik = 1,1103 Maka nilai n = (x_{b} - x_{0})/h = (0,10-0)/0,02 = 5 (banyaknya langkah) dan penerapan metode Runge-Kutta orde tiga pada PDB tersebut menjadi : y_{i+1} = y_{i}+\\dfrac{(k_{1}+2k_{2}+2k_{3}+k_{4})}{6} Langkah-langkah: x_{0} = 0 \\Rightarrow y_{0} = 1\\\\ x_{1} = 0,02 \\Rightarrow y_{1} = 1 +\\dfrac{0,0200+2(0,0204)+2(0,0204)+0,0208}{6}= 1,0204\\\\ x_{2} = 0,04 \\Rightarrow y_{2} = 1,0204 +\\dfrac{0,0208+2(0,0212)+2(0,0212)+0,0216}{6}= 1,0416\\\\ x_{3} = 0,06 \\Rightarrow y_{3} = 1,0416 +\\dfrac{0,0216+2(0,0220)+2(0,0220)+0,0224}{6}= 1,0636\\\\ x_{4} = 0,08 \\Rightarrow y_{4} = 1,0636 +\\dfrac{0,0224+2(0,0228)+2(0,0229)+0,0233}{6}= 1,0865\\\\ x_{5} = 0,10 \\Rightarrow y_{2} = 1,0204 +\\dfrac{0,0233+2(0,0237)+2(0,0237)+0,0242}{6}= 1,1103 Jadi solusi numerik dengan menggunakan metode Runge-Kutta orde empat di y(0,10) = 1,1103 dan nilai error yang dihasilkan ialah e = hasil analitik - solusi numerik = 1,1103 - 1,1103 = 0,0 . Algoritma Metode Runge-Kutta Orde Empat Deklarasi fungsi PDB yang akan di selesaikan, Masukkan inputan yang dibutuhkan seperti x_{0},y_{0},xb , dan h , Hitung perulangan yang diperlukan dengan menggunakan rumus n = (x_{b} - x_{0})/h , Inisialisasi nilai x dan y awal sama dengan x_{o} dan y_{0} , Tentukan nilai analitiknya untuk menghitung nilai error Lakukan perulangan sebanyak n, Update nilai k_{1} hinga k_{4} , nilai y dan nilai x serta nilai e kemudian cetak nilai nilai tersebut setiap melakukan peulangan. Source Code Metode Runge Kutta Orde Empat def f ( x , y ): return x + y print ( \"Penyelesaian Sistem Persamaan Differensial Biasa Menggunakan Metode Runge-Kutta Orde4\" ) x0 = float ( input ( \"Masukkan Nilai X0 : \" )) y0 = float ( input ( \"Masukkan Nilai y0 : \" )) xb = float ( input ( \"Masukkan Nilai X yang dicari : \" )) h = float ( input ( \"Masukkan Nilai h : \" )) iterasi = ( xb - x0 ) / h n = int ( iterasi ) x = x0 y = y0 true = 1.1103 e = abs ( true - y ) print ( \"==================================================================================================================\" ) print ( \">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>- METODE RUNGE-KUTTA ORDE 4 -<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\" ) print ( \"==================================================================================================================\" ) print ( '|i \\t |x(i) \\t\\t |y(i) \\t\\t |e \\t\\t |k1 \\t\\t |k2 \\t\\t |k3 \\t\\t |k4' ) print ( \"| %d \" % x0 , ' \\t | %f ' % x , ' \\t | %f |' % y , ' \\t | %f ' % e , ' \\t |0' , ' \\t\\t |0' , ' \\t\\t |0' , ' \\t\\t |0' ) for i in range ( n ): k1 = h * f ( x , y ) k2 = h * f ( x + h / 2 , y + k1 / 2 ) k3 = h * f ( x + h / 2 , y + k2 / 2 ) k4 = h * f ( x + h , y + k3 ) y = y + ( k1 + 2 * k2 + 2 * k3 + k4 ) / 6 x = x + h e = abs ( true - y ) print ( \"| %d \" % ( i + 1 ), ' \\t |' , \" %f \" % x , ' \\t |' , \" %f \\t |\" % y , \" %f \\t |\" % e , \" %f \\t |\" % k1 , \" %f \\t |\" % k2 , \" %f \\t |\" % k3 , \" %f \" % k4 ) print ( \"==================================================================================================================\" ) Dan output dari source code diatas ialah Penyelesaian Sistem Persamaan Differensial Biasa Menggunakan Metode Runge-Kutta Orde4 Masukkan Nilai X0 : 0 Masukkan Nilai y0 : 1 Masukkan Nilai X yang dicari : 0.1 Masukkan Nilai h : 0.02 ================================================================================================================== >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>- METODE RUNGE-KUTTA ORDE 3 -<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< ================================================================================================================== |i |x(i) |y(i) |e |k1 |k2 |k3 |k4 |0 |0.000000 |1.000000| |0.110300 |0 |0 |0 |0 |1 | 0.020000 | 1.020403 | 0.089897 | 0.020000 | 0.020400 | 0.020404 | 0.020808 |2 | 0.040000 | 1.041622 | 0.068678 | 0.020808 | 0.021216 | 0.021220 | 0.021632 |3 | 0.060000 | 1.063673 | 0.046627 | 0.021632 | 0.022049 | 0.022053 | 0.022473 |4 | 0.080000 | 1.086574 | 0.023726 | 0.022473 | 0.022898 | 0.022902 | 0.023332 |5 | 0.100000 | 1.110342 | 0.000042 | 0.023331 | 0.023765 | 0.023769 | 0.024207 ==================================================================================================================","title":"4. Metode Runge-Kutta Orde Empat"},{"location":"Differensial/#referensi","text":"https://app.schoology.com/course/4711478201/materials/gp/4905811750 \u21a9 http://iffatul.staff.gunadarma.ac.id/Downloads/files/46564/BAb-+08+Solusi+Persamaan+Diferensial+Bi \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9","title":"Referensi"},{"location":"SPL/","text":"SISTEM PERSAMAAN LINEAR (SPL) \u00b6 A. Definisi Sistem Persamaan Linear (SPL) \u00b6 \u200b Sistem persamaan linear (SPL) merupakan sekelompok persamaan linear yang terdiri dari beberapa variabel. 1 Sistem persamaan linear banyak dijumpai dalam berbagai disiplin ilmu, diantaranya matematika, fisika, statistika, teknik, biologi, dan ilmu-ilmu sosial serta bisnis. Sistem persamaan linear muncul secara langsung dari masalah-masalah nyata yang merupakan bagian dari proses penyelesaian masalah lain. 2 \u200b Bentuk umum sistem persamaan linear ialah sebagai berikut : Sistem Persamaan Linear Dua Variabel (SPLDV) \\begin{cases}ax+by = c\\\\ Px+qx = r \\end{cases} atau \\begin{cases}a_{1}x+b_{1}y = c_{1}\\\\ a_{2}x+b_{2}y = c_{2}\\end{cases} Sistem Persamaan Linear Tiga Variabel (SPLTV) \\begin{cases}ax+by+ cz= d\\\\ ex+fy+gz = h\\\\ ix+jy+kz = l \\end{cases} atau \\begin{cases}a_{1}x+b_{1}y + c_{1}z = d_{1}\\\\ a_{2}x+b_{2}y + c_{2}z = d_{2}\\\\a_{3}x+b_{3}y + c_{3}z = d_{3}\\end{cases} \u200b Untuk menyelesaikan bentuk sistem persamaan linear dengan 2 atau 3 variabel masih bisa diselesaikan dengan menggunakan metode analitik, namun bagaimana jika sistem persamaan linear tersebut terdiri dari banyak variabel/tak berhingga. Bentuk yang dimaksud ialah : \\begin{aligned}a_{11}x_{1}+a_{12}x_{2}+\\ldots + a_{1n}x_{n} = b_{1}\\\\ a_{21}x_{1}+a_{22}x_{2}+\\ldots +a_{2n}x_{n}=b_{2}\\\\ \\vdots \\\\a_{n1}x_{1}+a_{n2}x_{2}+\\ldots +a_{nn}x_{n}=b_{n}\\end{aligned} \u200b Untuk menyelesaikan persoalan tersebut dapat diselesaikan dengan menggunakan metode numerik, untuk lebih jelasnya perhatikan penjelasan berikut. B. Metode Penyelesaian Sistem Persamaan Linear (SPL) \u00b6 \u200b Untuk menyelesaikan sistem persamaan linear ialah dengan cara mencari nilai-nilai variabel tersebut sehingga memenuhi semua persamaan linear yang diberikan. 2 Dalam hal tersebut terdapat beberapa metode/cara untuk dapat menyelesaikan sistem persamaan linear diantaranya sebagai berikut. 1. Metode Eliminasi Gauss \u00b6 \u200b Metode eliminasi Gauss merupakan sebuah metode yang digunakan untuk menyelesaikan sistem persamaan linear dengan cara mengubah SPL tersebut ke dalam bentuk matrik yang berbentuk segitiga atas, yaitu semua koefisien di bawah diagonal utamanya bernilai nol. Kemudian bentuk segitiga atas tersebut dapat diselesaikan dengan cara mensubstitusi balik. Untuk mendapatkan bentuk segitiga atas tersebut dari SPL yang diberikan, metode eliminasi Gauss menggunakan Operasi Baris Elementer (OBE): 2 Menukar posisi dua buah persamaan. Menambah sebuah persamaan dengan suatu kelipatan persamaan lain. Mengalikan sebuah persamaan dengan sembarang konstanta tak nol. 2 Pemakaian OBE tersebut pada suatu SPL tidak akan mengubah SPL yang berkaitan, sudah jelas bahwa sebuah SPL tidak tergantung pada susunan persamaan, sehingga OBE nomor 1 dapat digunakan. Dan dalam setiap persamaan kedua ruas menyatakan nilai yang sama, sehingga OBE nomor 2 dapat dipakai. Demikian halnya OBE nomor 3 menghasilkan persamaan yang ekuivalen. Sehingga bentuk prosedur metode eliminasi gauss di asumsikan sebagai berikut. \\begin{bmatrix} a_{11}& a_{12}&a_{13}&:&b_{1}\\\\ a_{21}& a_{22}&a_{23}&:&b_{2} \\\\a_{31}& a_{32}&a_{33}&:&b_{3}\\end{bmatrix}\\Rightarrow\\begin{bmatrix} a_{11}& a_{12}&a_{13}&:&b_{1}\\\\ 0& a^{'}_{22}&a^{'}_{23}&:&b^{'}_{2} \\\\0& 0&a^{''}_{33}&:&b^{''}_{3}\\end{bmatrix} x_{3} = \\dfrac{b^{''}_{3}}{a^{''}_{33}}\\\\ x_{2} = \\dfrac{(b^{'}_{2}-a^{'}_{23}x_{3})}{a^{'}_{22}}\\\\ x_{1} = \\dfrac{(b_{1}-a_{12}x_{2}-a_{13}x_{3})}{a_{11}} Contoh : Selesaikan sistem persamaan linear berikut dengan menggunakan metode eliminasi gauss 6a - 2b + 2c + 4d = 16 12a - 8b + 6c + 10d = 26 3a - 13b + 9c + 3d = -19 -6a + 4b + c + -18d = -34 Jawab : Untuk menyelesaikan sistem persamaan tersebut ialah ubah bentuk persamaan tersebut kedalam bentuk matrik segitiga atas dengan cara eliminasi maju. Ubah persamaan tersebut kedalam bentuk matrik \\begin{bmatrix}6&-2&2&4\\\\12&-8&6&10\\\\3&-13&9&3\\\\-6&4&1&-18\\end{bmatrix}\\begin{bmatrix}x_{1}\\\\x_{2}\\\\x_{3}\\\\x_{4}\\end{bmatrix}=\\begin{bmatrix}16\\\\26\\\\-19\\\\-34\\end{bmatrix} Eliminasi x_{1} dari persamaan 2,3 dan 4 \\begin{bmatrix}6&-2&2&4\\\\0&-4&2&2\\\\0&-12&8&1\\\\0&2&3&-14\\end{bmatrix}\\begin{bmatrix}x_{1}\\\\x_{2}\\\\x_{3}\\\\x_{4}\\end{bmatrix}=\\begin{bmatrix}16\\\\-6\\\\-27\\\\-18\\end{bmatrix} Eliminasi x_{2} dari persamaan 3 dan 4 \\begin{bmatrix}6&-2&2&4\\\\0&-4&2&2\\\\0&0&2&-5\\\\0&0&4&-13\\end{bmatrix}\\begin{bmatrix}x_{1}\\\\x_{2}\\\\x_{3}\\\\x_{4}\\end{bmatrix}=\\begin{bmatrix}16\\\\-6\\\\-9\\\\-21\\end{bmatrix} Eliminasi x_{3} dari persamaan 4 \\begin{bmatrix}6&-2&2&4\\\\0&-4&2&2\\\\0&0&2&-5\\\\0&0&0&-3\\end{bmatrix}\\begin{bmatrix}x_{1}\\\\x_{2}\\\\x_{3}\\\\x_{4}\\end{bmatrix}=\\begin{bmatrix}16\\\\-6\\\\-9\\\\-3\\end{bmatrix} Hasil dari eliminasi maju sebagai berikut. \\begin{bmatrix}6&-2&2&4\\\\12&-8&6&10\\\\3&-13&9&3\\\\-6&4&1&-18\\end{bmatrix}\\begin{bmatrix}x_{1}\\\\x_{2}\\\\x_{3}\\\\x_{4}\\end{bmatrix}=\\begin{bmatrix}16\\\\26\\\\-19\\\\-34\\end{bmatrix}\\Rightarrow\\ \\begin{bmatrix}6&-2&2&4\\\\0&-4&2&2\\\\0&0&2&-5\\\\0&0&0&-3\\end{bmatrix}\\begin{bmatrix}x_{1}\\\\x_{2}\\\\x_{3}\\\\x_{4}\\end{bmatrix}=\\begin{bmatrix}16\\\\-6\\\\-9\\\\-3\\end{bmatrix} Setelah diperoleh bentuk matrik segitiga atas, langkah selanjutnya lakukan substitusi mundur mulai dari x_{4} hingga x_{1} x_{4} = \\dfrac{-3}{-3} = 1\\\\ x_{3} = \\dfrac{-9+5(1)}{-2} = \\dfrac{-4}{2}=-2\\\\ x_{2} = \\dfrac {-6-2(2)-2(1)}{-4} = \\dfrac{-4}{-4} = 1\\\\ x_{1} = \\dfrac{16-4(1)-2(-2)+2(1)}{6}= \\dfrac{18}{6}=3 Sehingga diperoleh nilai a = 3 , b = 1 , c = -2 dan d = 1 Algoritma Metode Eliminasi Gauss Deklarasikan SPL dalam bentuk matrik Membuat perulangan bersarang untuk melakukan eliminasi maju dengan struktur : Perulangan pertama untuk melakukan perulangan sebanyak panjang matrik yang dimulai dari 0. Perulangan kedua (di dalam perulangan pertama) untuk menentukan nilai faktor pembuat 0 dan mengubah nilai hasil SPL yang berbentuk matrik dengan cara dikurangi dengan nilai dari faktor yang dikalikan dengan nilai hasil sebelumnya pada matrik. Perulangan ketiga (di dalam perulangan kedua) untuk mengubah nilai matrik di indeks bawah diagonal menjadi nol dengan cara dikurangi dengan nilai faktor yang dikalikan dengan matrik di indeks atas diagonal. Perulangan keempat(di dalam perulangan kedua) untuk menampilkan perubahan nilai matrik. Membuat perulangan bersarang untuk melakukan substitusi mundur dengan struktur : Perulangan pertama sebanyak panjang matrik yang dimulai dari indeks terakhir untuk mengambil nilai hasil dari x_{n} hingga x_{1} dan mengubah nilai matrik di indeks yang menyimpan nilai x_{i} dengan nilai yang diperoleh di perulangan kedua yang dibagi dengan koefisien x_{i} . Perulangan kedua(di dalam perulangan pertama) untuk mengurangi nilai hasil dengan nilai korfisien yang dikalikan dengan nilai x_{i} . Perulangan ketiga(di dalam perulangan pertama) untuk menampilkan nilai matrik setelah diubah. Menampilkan nilai dari x_{1} hingga x_{n} . Kemudian implementasi dari algoritma tersebut ialah sebagai berikut Source Code Metode Eliminasi Gauss matrik = [ [[ 6 , - 2 , 2 , 4 ],[ \"X1\" ],[ 16 ]], [[ 12 , - 8 , 6 , 10 ],[ \"X2\" ],[ 26 ]], [[ 3 , - 13 , 9 , 3 ],[ \"X3\" ],[ - 19 ]], [[ - 6 , 4 , 1 , - 18 ],[ \"X4\" ],[ - 34 ]], ] print ( \"Penyelesaiaan Sistem Persamaan Linear Dari\" ) for u in matrik : print ( u ) print ( \"Menggunakan Metode Eliminasi Gauss\" ) print ( \"=======================================================\" ) print ( \">>>>>>>>>>>>>>- METODE ELIMINNASI GAUSS -<<<<<<<<<<<<<\" ) print ( \"=======================================================\" ) #untuk Eliminasi Maju for k in range ( 0 , len ( matrik ) - 1 ): for i in range ( k + 1 , len ( matrik )): faktor = matrik [ i ][ 0 ][ k ] / matrik [ k ][ 0 ][ k ] print ( \"faktor = \" , faktor ) for j in range ( k , len ( matrik )): matrik [ i ][ 0 ][ j ] = round ( matrik [ i ][ 0 ][ j ] - ( faktor * matrik [ k ][ 0 ][ j ]), 4 ) matrik [ i ][ 2 ][ 0 ] = round ( matrik [ i ][ 2 ][ 0 ] - ( faktor * matrik [ k ][ 2 ][ 0 ]), 2 ) for u in matrik : print ( u ) print ( \" \\n \" ) #Untuk Substitusi Mundur for i in range ( len ( matrik ) - 1 , - 1 , - 1 ): sum = matrik [ i ][ 2 ][ 0 ] for j in range ( i + 1 , len ( matrik )): sum = sum - round (( matrik [ i ][ 0 ][ j ] * matrik [ j ][ 1 ][ 0 ]), 4 ) matrik [ i ][ 1 ][ 0 ] = round ( sum / matrik [ i ][ 0 ][ i ], 4 ) for u in matrik : print ( u ) print ( \" \\n \" ) print ( \"Nilai Variabel yang diperoleh\" ) for u in range ( len ( matrik [ 0 ][ 0 ])): print ( f \"x { u + 1 } = { round ( matrik [ u ][ 1 ][ 0 ], 4 ) } \" ) print ( \"=======================================================\" ) Dan hasil output dari source code tersebut ialah sebagai berikut. Penyelesaiaan Sistem Persamaan Linear Dari [[6, -2, 2, 4], ['X1'], [16]] [[12, -8, 6, 10], ['X2'], [26]] [[3, -13, 9, 3], ['X3'], [-19]] [[-6, 4, 1, -18], ['X4'], [-34]] Menggunakan Metode Eliminasi Gauss ======================================================= >>>>>>>>>>>>>>- METODE ELIMINNASI GAUSS -<<<<<<<<<<<<< ======================================================= faktor = 2.0 [[6, -2, 2, 4], ['X1'], [16]] [[0.0, -4.0, 2.0, 2.0], ['X2'], [-6.0]] [[3, -13, 9, 3], ['X3'], [-19]] [[-6, 4, 1, -18], ['X4'], [-34]] faktor = 0.5 [[6, -2, 2, 4], ['X1'], [16]] [[0.0, -4.0, 2.0, 2.0], ['X2'], [-6.0]] [[0.0, -12.0, 8.0, 1.0], ['X3'], [-27.0]] [[-6, 4, 1, -18], ['X4'], [-34]] faktor = -1.0 [[6, -2, 2, 4], ['X1'], [16]] [[0.0, -4.0, 2.0, 2.0], ['X2'], [-6.0]] [[0.0, -12.0, 8.0, 1.0], ['X3'], [-27.0]] [[0.0, 2.0, 3.0, -14.0], ['X4'], [-18.0]] faktor = 3.0 [[6, -2, 2, 4], ['X1'], [16]] [[0.0, -4.0, 2.0, 2.0], ['X2'], [-6.0]] [[0.0, 0.0, 2.0, -5.0], ['X3'], [-9.0]] [[0.0, 2.0, 3.0, -14.0], ['X4'], [-18.0]] faktor = -0.5 [[6, -2, 2, 4], ['X1'], [16]] [[0.0, -4.0, 2.0, 2.0], ['X2'], [-6.0]] [[0.0, 0.0, 2.0, -5.0], ['X3'], [-9.0]] [[0.0, 0.0, 4.0, -13.0], ['X4'], [-21.0]] faktor = 2.0 [[6, -2, 2, 4], ['X1'], [16]] [[0.0, -4.0, 2.0, 2.0], ['X2'], [-6.0]] [[0.0, 0.0, 2.0, -5.0], ['X3'], [-9.0]] [[0.0, 0.0, 0.0, -3.0], ['X4'], [-3.0]] [[6, -2, 2, 4], ['X1'], [16]] [[0.0, -4.0, 2.0, 2.0], ['X2'], [-6.0]] [[0.0, 0.0, 2.0, -5.0], ['X3'], [-9.0]] [[0.0, 0.0, 0.0, -3.0], [1.0], [-3.0]] [[6, -2, 2, 4], ['X1'], [16]] [[0.0, -4.0, 2.0, 2.0], ['X2'], [-6.0]] [[0.0, 0.0, 2.0, -5.0], [-2.0], [-9.0]] [[0.0, 0.0, 0.0, -3.0], [1.0], [-3.0]] [[6, -2, 2, 4], ['X1'], [16]] [[0.0, -4.0, 2.0, 2.0], [1.0], [-6.0]] [[0.0, 0.0, 2.0, -5.0], [-2.0], [-9.0]] [[0.0, 0.0, 0.0, -3.0], [1.0], [-3.0]] [[6, -2, 2, 4], [3.0], [16]] [[0.0, -4.0, 2.0, 2.0], [1.0], [-6.0]] [[0.0, 0.0, 2.0, -5.0], [-2.0], [-9.0]] [[0.0, 0.0, 0.0, -3.0], [1.0], [-3.0]] Nilai Variabel yang diperoleh x1 = 3.0 x2 = 1.0 x3 = -2.0 x4 = 1.0 ======================================================= 2. Metode Jacobi \u00b6 \u200b Metode jacobi merupakan metode untuk menyelesaikan sistem persamaan linear dengan cara melakukan iterasi. Misalkan terdapat 3 persamaan dengan 3 bilangan tak diketahui : a_{11}x_{1}+a_{12}x_{2}+a_{13}x_{3}=b_{1}\\\\a_{21}x_{1}+a_{22}x_{2}+a_{23}x_{3}=b_{2}\\\\a_{31}x_{1}+a_{32}x_{2}+a_{33}x_{3}=b_{3} \u200b Dari sistem persamaan tersebut dengan menggunakan metode jacobi kita dapat menhitung nilai x_{1} dengan menggunakan persamaan pertama. Begitu pula dengan x_{2} dan x_{3} dapat dihitung dengan menggunakan persamaan kedua dan ketiga, sehingga didapat : x_{1} = \\dfrac{b_{1}-a_{12}x_{2}-a_{13}x_{3}}{a_{11}}\\\\x_{2} = \\dfrac{b_{2}-a_{21}x_{1}-a_{23}x_{3}}{a_{22}}\\\\x_{3} = \\dfrac{b_{3}-a_{31}x_{1}-a_{32}x_{2}}{a_{33}} \u200b Sehingga metode jacobi secara umum dapat dituliskan sebagai berikut:[^3] x^{(k+1)}_{i} =\\left( b_{i}-\\sum^{i-1}_{j=1}a_{ij}x^{k}_{j}-\\sum^{n}_{j=i+1}a_{ij}x^{k}_{j} \\right)/a_{ii} Contoh : Selesaikan sistem persamaan linear 4 variabel berikut menggunakan iterasi jacobi. 10a - b + 2c = 6 -a + 11b - c + 3d = 25 2a - b + 10c - d = -11 3b - c + 8d = 15 Jawab : Dari soal diperoleh : 10x_{1}-x_{2}+2x_{3} = 6\\\\ -x{1}+11x_{2}-x_{3}+3x_{4} = 25 \\\\ 2x_{1}-x_{2}+10_{x3}-x_{4}=11\\\\ 3x_{2}-x_{3}+8x_{4} = 15 Sehingga nilai x_{1} hingga x_{4} : x_{1} =(x_{2}-2x_{3}+6)/10\\\\ x_{2} =(x_{1}+x_{3}-3x_{4}+25)/11\\\\ x_{3} =(-2x_{1}+x_{2}+x_{4}-11)/10\\\\ x_{4} =(-3x_{2}+x_{3}+15)/8 Sehingga nilai x_{1} hingga x_{4} pada iterasi ke k dapat dituliskan sebagai berikut : x_{1}^{(k+1)} =(x_{2}^{k}-2x_{3}^{k}+6)/10\\\\ x_{2}^{(k+1)} =(x_{1}^{k}+x_{3}^{k}-3x_{4}^{k}+25)/11\\\\ x_{3}^{(k+1)} =(-2x_{1}^{k}+x_{2}^{k}+x_{4}^{k}-11)/10\\\\ x_{4}^{(k+1)} =(-3x_{2}^{k}+x_{3}^{k}+15)/8 Dan nilai yang diperoleh disajikan dalam tabel berikut : X_{i} K = 1 K = 2 K = 3 K = 4 K = 5 K = 6 K = 7 K = 8 K = 9 K = 10 x_{1} 0,6000 1,0473 0,9326 1,0152 0,9890 1,0032 0,9981 1,0006 0,9997 1,0001 x_{2} 2,2727 1,7159 2,0533 1,9537 2,0114 1,9922 2,0023 1,9987 2.0004 1,9998 x_{3} -1,1000 -0,8052 -1,0493 -0,9681 -1,0103 -0,9945 -1,0020 0,9990 -1,0004 -0,9998 x_{4} -1,8750 0,8852 1,1309 0,9738 1,0214 0,9944 1.0036 0,9989 1,0006 0,9998 Algoritma Metode Jacobi Deklarasikan SPL dalam bentuk matrik Deklarasi nilai X_{i} dari hasil analitik Deklarasi array yang kosong ( K = [ ] ) Buat perulangan untuk menampilkan SPL dalam bentuk matrik Tentukan banyak iterasi ( n ) Buat perulangan untuk membuat nilai awal x_{i} = 0 Buat perulangan bersarang dengan ketentuan : Perulangan pertama sebanyak n inputan untuk menentukan berapa kali melakukan iterasi. Dan menghapus nilai di dalam array kosong( K = [ ] ). Perulangan kedua(di dalam perulangan pertama) sebanyak panjang dari matrik untuk mengambil nilai hasil di dalam matrik. Dan menampung nilai yang dihasilkan dari perulangan ketiga kedalam array kosong . Perulangan ketiga(di dalam perulangan kedua) sebanyak panjang dari matrik untuk mengurangi nilai hasil dengan koefisien yang dikalikan dengan nilai x_{i} dengan mengambil nilai dari matrik. Perulangan keempat(di dalam perulangan pertama) sebanyak panjang matrik untuk mengubah nilai x_{i} dengan nilai yang ditampung di array kosong. Dan menghitung nilai error yang dihasilkan kemudian menampilkan nilai x_{i} dan error yang dihasilkan pada iterasi ke-k. Sehingga source code dari metode jacobi ialah sebagai berikut. Source Code Metode Jacobi matrik = [ [[ 10 , - 1 , 2 , 0 ],[ \"X1\" ],[ 6 ]], [[ - 1 , 11 , - 1 , 3 ],[ \"X2\" ],[ 25 ]], [[ 2 , - 1 , 10 , - 1 ],[ \"X3\" ],[ - 11 ]], [[ 0 , 3 , - 1 , 8 ],[ \"X4\" ],[ 15 ]], ] true = [ 1 , 2 , - 1 , 1 ] K = [] print ( \"Penyelesaiaan Sistem Persamaan Linear Dari\" ) for i in matrik : print ( i ) print ( \"Menggunakan Metode Jacobi\" ) n = int ( input ( \"Masukkan banyak iterasi : \" )) print ( \"=======================================================\" ) print ( \">>>>>>>>>>>>>>>>>>>>- METODE JACOBI -<<<<<<<<<<<<<<<<<<\" ) print ( \"=======================================================\" ) for i in range ( len ( matrik [ 0 ][ 0 ])): matrik [ i ][ 1 ][ 0 ] = 0 for k in range ( n ): for i in range ( len ( matrik )): sum = matrik [ i ][ 2 ][ 0 ] for j in range ( len ( matrik )): if i == j : continue sum = sum - matrik [ i ][ 0 ][ j ] * matrik [ j ][ 1 ][ 0 ] K . append ( sum / matrik [ i ][ 0 ][ i ]) print ( f \"iterasi { k + 1 } \" , ' \\t ' , \"|Xi\" , ' \\t\\t\\t ' , \"|errorXi\" ) for x in range ( len ( matrik )): matrik [ x ][ 1 ][ 0 ] = K [ x ] ea = abs (( true [ x ] - K [ x ]) / true [ x ]) * 100 print ( \"X\" + str ( x + 1 ), ' \\t\\t ' , \"| %.10f |\" % K [ x ], ' \\t ' , \" %.10f \" % ea ) K . clear () print ( \"=======================================================\" ) Dan output yang dihasilkan sebagai berikut. Penyelesaiaan Sistem Persamaan Linear Dari [[10, -1, 2, 0], ['X1'], [6]] [[-1, 11, -1, 3], ['X2'], [25]] [[2, -1, 10, -1], ['X3'], [-11]] [[0, 3, -1, 8], ['X4'], [15]] Menggunakan Metode Jacobi Masukkan banyak iterasi : 10 ======================================================= >>>>>>>>>>>>>>>>>>>>- METODE JACOBI -<<<<<<<<<<<<<<<<<< ======================================================= iterasi 1 |Xi |errorXi X1 |0.6000000000| 40.0000000000 X2 |2.2727272727| 13.6363636364 X3 |-1.1000000000| 10.0000000000 X4 |1.8750000000| 87.5000000000 iterasi 2 |Xi |errorXi X1 |1.0472727273| 4.7272727273 X2 |1.7159090909| 14.2045454545 X3 |-0.8052272727| 19.4772727273 X4 |0.8852272727| 11.4772727273 iterasi 3 |Xi |errorXi X1 |0.9326363636| 6.7363636364 X2 |2.0533057851| 2.6652892562 X3 |-1.0493409091| 4.9340909091 X4 |1.1308806818| 13.0880681818 iterasi 4 |Xi |errorXi X1 |1.0151987603| 1.5198760331 X2 |1.9536957645| 2.3152117769 X3 |-0.9681086260| 3.1891373967 X4 |0.9738427169| 2.6157283058 iterasi 5 |Xi |errorXi X1 |0.9889913017| 1.1008698347 X2 |2.0114147258| 0.5707362885 X3 |-1.0102859039| 1.0285903926 X4 |1.0213505101| 2.1350510072 iterasi 6 |Xi |errorXi X1 |1.0031986534| 0.3198653362 X2 |1.9922412607| 0.3879369659 X3 |-0.9945217367| 0.5478263254 X4 |0.9944337398| 0.5566260154 iterasi 7 |Xi |errorXi X1 |0.9981284734| 0.1871526582 X2 |2.0023068816| 0.1153440776 X3 |-1.0019722306| 0.1972230620 X4 |1.0035943102| 0.3594310151 iterasi 8 |Xi |errorXi X1 |1.0006251343| 0.0625134279 X2 |1.9986703011| 0.0664849439 X3 |-0.9990355755| 0.0964424487 X4 |0.9988883906| 0.1111609410 iterasi 9 |Xi |errorXi X1 |0.9996741452| 0.0325854785 X2 |2.0004476715| 0.0223835773 X3 |-1.0003691577| 0.0369157685 X4 |1.0006191901| 0.0619190140 iterasi 10 |Xi |errorXi X1 |1.0001185987| 0.0118598691 X2 |1.9997679470| 0.0116026495 X3 |-0.9998281429| 0.0171857126 X4 |0.9997859785| 0.0214021540 ======================================================= 3. Metode Gauss Seidel \u00b6 \u200b Metode Gauss Seidel merupakan metode penyelesaian sistem persamaan linear yang hampir sama dengan metode jacobi. Hanya saja di dalam metode jacobi nilai x_{1} yang didapat dari persamaan pertama tidak digunakan untuk menghitung nilai x_{2} dengan menggunakan persamaan kedua. Demikian halnya dengan nilai x_{2} tidak digunakan untuk mencari nilai x_{3} , begitu seterusnya. 2 Sedangkan didalam metode Gauss Seidel nilai x_{1} yang diperoleh dari persamaan sebelumnya akan dipakai untuk mencari nilai x_{2} begitupun seterusnya. Sehingga dapat disimpulkan metode Jacobi tidak menggunakan nilai yang terbaru sedangkan metode Gauss Seidel menggunakan nilai yang terbaru. \u200b Sehingga bentuk metoode Gauss Seidel secara umum dapat dituliskan sebagai berikut:[^3] x^{(k+1)}_{i} =\\left( b_{i}-\\sum^{i-1}_{j=1}a_{ij}x^{(k+1)}_{j}-\\sum^{n}_{j=i+1}a_{ij}x^{k}_{j} \\right)/a_{ii} Contoh : Selesaikan sistem persamaan linear 4 variabel berikut menggunakan iterasi Gauss Seidel. 10a - b + 2c = 6 -a + 11b - c + 3d = 25 2a - b + 10c - d = -11 3b - c + 8d = 15 Jawab : Dari soal diperoleh : 10x_{1}-x_{2}+2x_{3} = 6\\\\ -x{1}+11x_{2}-x_{3}+3x_{4} = 25 \\\\ 2x_{1}-x_{2}+10_{x3}-x_{4}=11\\\\ 3x_{2}-x_{3}+8x_{4} = 15 Sehingga nilai x_{1} hingga x_{4} : x_{1} =(x_{2}-2x_{3}+6)/10\\\\ x_{2} =(x_{1}+x_{3}-3x_{4}+25)/11\\\\ x_{3} =(-2x_{1}+x_{2}+x_{4}-11)/10\\\\ x_{4} =(-3x_{2}+x_{3}+15)/8 Sehingga nilai x_{1} hingga x_{4} pada iterasi ke k dapat dituliskan sebagai berikut : x_{1}^{(k+1)} =(x_{2}^{k}-2x_{3}^{k}+6)/10\\\\ x_{2}^{(k+1)} =(x_{1}^{(k+1)}+x_{3}^{k}-3x_{4}^{k}+25)/11\\\\ x_{3}^{(k+1)} =(-2x_{1}^{(k+1)}+x_{2}^{(k+1)}+x_{4}^{k}-11)/10\\\\ x_{4}^{(k+1)} =(-3x_{2}^{(k+1)}+x_{3}^{(k+1)}+15)/8 Dan nilai yang diperoleh disajikan dalam tabel berikut : K = 1 K = 2 K = 3 K = 4 K = 5 x_{1} 0,6000 1,0302 1,0066 1,0009 1,0001 x_{2} 2,3273 2,0369 2,0036 2,0003 2,0000 x_{3} -0,9873 -1,0145 -1,0025 -1,0003 -1,0000 x_{4} 0,8789 0,9843 0,9984 0,9998 1,0000 Algoritma Metode Jacobi Deklarasikan SPL dalam bentuk matrik Deklarasi nilai X_{i} dari hasil analitik Buat perulangan untuk menampilkan SPL dalam bentuk matrik Tentukan banyak iterasi ( n ) Buat perulangan untuk membuat nilai awal x_{i} = 0 Buat perulangan bersarang dengan ketentuan : Perulangan pertama sebanyak n inputan untuk menentukan berapa kali melakukan iterasi. Perulangan kedua(di dalam perulangan pertama) sebanyak panjang dari matrik untuk mengambil nilai hasil di dalam matrik. Dan mengubah nilai x_{i} menjadi nilai yang dihasilkan dari perulangan ketiga. Perulangan ketiga(di dalam perulangan kedua) sebanyak panjang dari matrik untuk mengurangi nilai hasil dengan koefisien yang dikalikan dengan nilai x_{i} dengan mengambil nilai dari matrik. Perulangan keempat(di dalam perulangan pertama) sebanyak panjang matrik untuk menghitung nilai error yang dihasilkan kemudian menampilkan nilai x_{i} dan error yang dihasilkan pada iterasi ke-k. Sehingga source code dari metode Gauss Seidel ialah sebagai berikut. Source Code Metode Gauss Seidel matrik = [ [[ 10 , - 1 , 2 , 0 ],[ \"X1\" ],[ 6 ]], [[ - 1 , 11 , - 1 , 3 ],[ \"X2\" ],[ 25 ]], [[ 2 , - 1 , 10 , - 1 ],[ \"X3\" ],[ - 11 ]], [[ 0 , 3 , - 1 , 8 ],[ \"X4\" ],[ 15 ]], ] true = [ 1 , 2 , - 1 , 1 ] print ( \"Penyelesaiaan Sistem Persamaan Linear Dari\" ) for i in matrik : print ( i ) print ( \"Menggunakan Metode Gauss Seidel\" ) n = int ( input ( \"Masukkan banyak iterasi : \" )) print ( \"=======================================================\" ) print ( \">>>>>>>>>>>>>>>>>- METODE GAUSS SEIDEL -<<<<<<<<<<<<<<<\" ) print ( \"=======================================================\" ) for i in range ( len ( matrik [ 0 ][ 0 ])): matrik [ i ][ 1 ][ 0 ] = 0 for k in range ( n ): for i in range ( len ( matrik )): Xi = matrik [ i ][ 1 ][ 0 ] sum = matrik [ i ][ 2 ][ 0 ] for j in range ( len ( matrik )): if j == i : continue sum = sum - matrik [ i ][ 0 ][ j ] * matrik [ j ][ 1 ][ 0 ] matrik [ i ][ 1 ][ 0 ] = sum / matrik [ i ][ 0 ][ i ] print ( f \"iterasi { k + 1 } \" , ' \\t ' , \"|Xi\" , ' \\t\\t\\t ' , \"|errorXi\" ) for x in range ( len ( matrik )): ea = abs (( matrik [ x ][ 1 ][ 0 ] - true [ x ]) / true [ x ]) * 100 print ( \"X\" + str ( x + 1 ), ' \\t\\t ' , \"| %.10f |\" % matrik [ x ][ 1 ][ 0 ], ' \\t ' , \" %.10f \" % ea ) print ( \"=======================================================\" ) Dan hasil ouput dari source code tersebut ialah sebagai berikut. Penyelesaiaan Sistem Persamaan Linear Dari [[10, -1, 2, 0], ['X1'], [6]] [[-1, 11, -1, 3], ['X2'], [25]] [[2, -1, 10, -1], ['X3'], [-11]] [[0, 3, -1, 8], ['X4'], [15]] Menggunakan Metode Gauss Seidel Masukkan banyak iterasi : 5 ======================================================= >>>>>>>>>>>>>>>>>- METODE GAUSS SEIDEL -<<<<<<<<<<<<<<< ======================================================= iterasi 1 |Xi |errorXi X1 |0.6000000000| 40.0000000000 X2 |2.3272727273| 16.3636363636 X3 |-0.9872727273| 1.2727272727 X4 |0.8788636364| 12.1136363636 iterasi 2 |Xi |errorXi X1 |1.0301818182| 3.0181818182 X2 |2.0369380165| 1.8469008264 X3 |-1.0144561983| 1.4456198347 X4 |0.9843412190| 1.5658780992 iterasi 3 |Xi |errorXi X1 |1.0065850413| 0.6585041322 X2 |2.0035550169| 0.1777508452 X3 |-1.0025273847| 0.2527384673 X4 |0.9983509456| 0.1649054423 iterasi 4 |Xi |errorXi X1 |1.0008609786| 0.0860978625 X2 |2.0002982507| 0.0149125328 X3 |-1.0003072761| 0.0307276102 X4 |0.9998497465| 0.0150253509 iterasi 5 |Xi |errorXi X1 |1.0000912803| 0.0091280286 X2 |2.0000213422| 0.0010671123 X3 |-1.0000311472| 0.0031147183 X4 |0.9999881033| 0.0011896740 ======================================================= Referensi \u00b6 https://id.m.wikipedia.org/wiki/Sistem_persamaan_linear \u21a9 https://www.slideshare.net/KhannalPakinde/makalah-metode-numerik-sistem-persamaan-linear \u21a9 \u21a9 \u21a9 \u21a9 \u21a9","title":"Solusi Numerik Sistem Persamaan Linear"},{"location":"SPL/#sistem_persamaan_linear_spl","text":"","title":"SISTEM PERSAMAAN LINEAR (SPL)"},{"location":"SPL/#a_definisi_sistem_persamaan_linear_spl","text":"\u200b Sistem persamaan linear (SPL) merupakan sekelompok persamaan linear yang terdiri dari beberapa variabel. 1 Sistem persamaan linear banyak dijumpai dalam berbagai disiplin ilmu, diantaranya matematika, fisika, statistika, teknik, biologi, dan ilmu-ilmu sosial serta bisnis. Sistem persamaan linear muncul secara langsung dari masalah-masalah nyata yang merupakan bagian dari proses penyelesaian masalah lain. 2 \u200b Bentuk umum sistem persamaan linear ialah sebagai berikut : Sistem Persamaan Linear Dua Variabel (SPLDV) \\begin{cases}ax+by = c\\\\ Px+qx = r \\end{cases} atau \\begin{cases}a_{1}x+b_{1}y = c_{1}\\\\ a_{2}x+b_{2}y = c_{2}\\end{cases} Sistem Persamaan Linear Tiga Variabel (SPLTV) \\begin{cases}ax+by+ cz= d\\\\ ex+fy+gz = h\\\\ ix+jy+kz = l \\end{cases} atau \\begin{cases}a_{1}x+b_{1}y + c_{1}z = d_{1}\\\\ a_{2}x+b_{2}y + c_{2}z = d_{2}\\\\a_{3}x+b_{3}y + c_{3}z = d_{3}\\end{cases} \u200b Untuk menyelesaikan bentuk sistem persamaan linear dengan 2 atau 3 variabel masih bisa diselesaikan dengan menggunakan metode analitik, namun bagaimana jika sistem persamaan linear tersebut terdiri dari banyak variabel/tak berhingga. Bentuk yang dimaksud ialah : \\begin{aligned}a_{11}x_{1}+a_{12}x_{2}+\\ldots + a_{1n}x_{n} = b_{1}\\\\ a_{21}x_{1}+a_{22}x_{2}+\\ldots +a_{2n}x_{n}=b_{2}\\\\ \\vdots \\\\a_{n1}x_{1}+a_{n2}x_{2}+\\ldots +a_{nn}x_{n}=b_{n}\\end{aligned} \u200b Untuk menyelesaikan persoalan tersebut dapat diselesaikan dengan menggunakan metode numerik, untuk lebih jelasnya perhatikan penjelasan berikut.","title":"A. Definisi Sistem Persamaan Linear (SPL)"},{"location":"SPL/#b_metode_penyelesaian_sistem_persamaan_linear_spl","text":"\u200b Untuk menyelesaikan sistem persamaan linear ialah dengan cara mencari nilai-nilai variabel tersebut sehingga memenuhi semua persamaan linear yang diberikan. 2 Dalam hal tersebut terdapat beberapa metode/cara untuk dapat menyelesaikan sistem persamaan linear diantaranya sebagai berikut.","title":"B. Metode Penyelesaian Sistem Persamaan Linear (SPL)"},{"location":"SPL/#1_metode_eliminasi_gauss","text":"\u200b Metode eliminasi Gauss merupakan sebuah metode yang digunakan untuk menyelesaikan sistem persamaan linear dengan cara mengubah SPL tersebut ke dalam bentuk matrik yang berbentuk segitiga atas, yaitu semua koefisien di bawah diagonal utamanya bernilai nol. Kemudian bentuk segitiga atas tersebut dapat diselesaikan dengan cara mensubstitusi balik. Untuk mendapatkan bentuk segitiga atas tersebut dari SPL yang diberikan, metode eliminasi Gauss menggunakan Operasi Baris Elementer (OBE): 2 Menukar posisi dua buah persamaan. Menambah sebuah persamaan dengan suatu kelipatan persamaan lain. Mengalikan sebuah persamaan dengan sembarang konstanta tak nol. 2 Pemakaian OBE tersebut pada suatu SPL tidak akan mengubah SPL yang berkaitan, sudah jelas bahwa sebuah SPL tidak tergantung pada susunan persamaan, sehingga OBE nomor 1 dapat digunakan. Dan dalam setiap persamaan kedua ruas menyatakan nilai yang sama, sehingga OBE nomor 2 dapat dipakai. Demikian halnya OBE nomor 3 menghasilkan persamaan yang ekuivalen. Sehingga bentuk prosedur metode eliminasi gauss di asumsikan sebagai berikut. \\begin{bmatrix} a_{11}& a_{12}&a_{13}&:&b_{1}\\\\ a_{21}& a_{22}&a_{23}&:&b_{2} \\\\a_{31}& a_{32}&a_{33}&:&b_{3}\\end{bmatrix}\\Rightarrow\\begin{bmatrix} a_{11}& a_{12}&a_{13}&:&b_{1}\\\\ 0& a^{'}_{22}&a^{'}_{23}&:&b^{'}_{2} \\\\0& 0&a^{''}_{33}&:&b^{''}_{3}\\end{bmatrix} x_{3} = \\dfrac{b^{''}_{3}}{a^{''}_{33}}\\\\ x_{2} = \\dfrac{(b^{'}_{2}-a^{'}_{23}x_{3})}{a^{'}_{22}}\\\\ x_{1} = \\dfrac{(b_{1}-a_{12}x_{2}-a_{13}x_{3})}{a_{11}} Contoh : Selesaikan sistem persamaan linear berikut dengan menggunakan metode eliminasi gauss 6a - 2b + 2c + 4d = 16 12a - 8b + 6c + 10d = 26 3a - 13b + 9c + 3d = -19 -6a + 4b + c + -18d = -34 Jawab : Untuk menyelesaikan sistem persamaan tersebut ialah ubah bentuk persamaan tersebut kedalam bentuk matrik segitiga atas dengan cara eliminasi maju. Ubah persamaan tersebut kedalam bentuk matrik \\begin{bmatrix}6&-2&2&4\\\\12&-8&6&10\\\\3&-13&9&3\\\\-6&4&1&-18\\end{bmatrix}\\begin{bmatrix}x_{1}\\\\x_{2}\\\\x_{3}\\\\x_{4}\\end{bmatrix}=\\begin{bmatrix}16\\\\26\\\\-19\\\\-34\\end{bmatrix} Eliminasi x_{1} dari persamaan 2,3 dan 4 \\begin{bmatrix}6&-2&2&4\\\\0&-4&2&2\\\\0&-12&8&1\\\\0&2&3&-14\\end{bmatrix}\\begin{bmatrix}x_{1}\\\\x_{2}\\\\x_{3}\\\\x_{4}\\end{bmatrix}=\\begin{bmatrix}16\\\\-6\\\\-27\\\\-18\\end{bmatrix} Eliminasi x_{2} dari persamaan 3 dan 4 \\begin{bmatrix}6&-2&2&4\\\\0&-4&2&2\\\\0&0&2&-5\\\\0&0&4&-13\\end{bmatrix}\\begin{bmatrix}x_{1}\\\\x_{2}\\\\x_{3}\\\\x_{4}\\end{bmatrix}=\\begin{bmatrix}16\\\\-6\\\\-9\\\\-21\\end{bmatrix} Eliminasi x_{3} dari persamaan 4 \\begin{bmatrix}6&-2&2&4\\\\0&-4&2&2\\\\0&0&2&-5\\\\0&0&0&-3\\end{bmatrix}\\begin{bmatrix}x_{1}\\\\x_{2}\\\\x_{3}\\\\x_{4}\\end{bmatrix}=\\begin{bmatrix}16\\\\-6\\\\-9\\\\-3\\end{bmatrix} Hasil dari eliminasi maju sebagai berikut. \\begin{bmatrix}6&-2&2&4\\\\12&-8&6&10\\\\3&-13&9&3\\\\-6&4&1&-18\\end{bmatrix}\\begin{bmatrix}x_{1}\\\\x_{2}\\\\x_{3}\\\\x_{4}\\end{bmatrix}=\\begin{bmatrix}16\\\\26\\\\-19\\\\-34\\end{bmatrix}\\Rightarrow\\ \\begin{bmatrix}6&-2&2&4\\\\0&-4&2&2\\\\0&0&2&-5\\\\0&0&0&-3\\end{bmatrix}\\begin{bmatrix}x_{1}\\\\x_{2}\\\\x_{3}\\\\x_{4}\\end{bmatrix}=\\begin{bmatrix}16\\\\-6\\\\-9\\\\-3\\end{bmatrix} Setelah diperoleh bentuk matrik segitiga atas, langkah selanjutnya lakukan substitusi mundur mulai dari x_{4} hingga x_{1} x_{4} = \\dfrac{-3}{-3} = 1\\\\ x_{3} = \\dfrac{-9+5(1)}{-2} = \\dfrac{-4}{2}=-2\\\\ x_{2} = \\dfrac {-6-2(2)-2(1)}{-4} = \\dfrac{-4}{-4} = 1\\\\ x_{1} = \\dfrac{16-4(1)-2(-2)+2(1)}{6}= \\dfrac{18}{6}=3 Sehingga diperoleh nilai a = 3 , b = 1 , c = -2 dan d = 1 Algoritma Metode Eliminasi Gauss Deklarasikan SPL dalam bentuk matrik Membuat perulangan bersarang untuk melakukan eliminasi maju dengan struktur : Perulangan pertama untuk melakukan perulangan sebanyak panjang matrik yang dimulai dari 0. Perulangan kedua (di dalam perulangan pertama) untuk menentukan nilai faktor pembuat 0 dan mengubah nilai hasil SPL yang berbentuk matrik dengan cara dikurangi dengan nilai dari faktor yang dikalikan dengan nilai hasil sebelumnya pada matrik. Perulangan ketiga (di dalam perulangan kedua) untuk mengubah nilai matrik di indeks bawah diagonal menjadi nol dengan cara dikurangi dengan nilai faktor yang dikalikan dengan matrik di indeks atas diagonal. Perulangan keempat(di dalam perulangan kedua) untuk menampilkan perubahan nilai matrik. Membuat perulangan bersarang untuk melakukan substitusi mundur dengan struktur : Perulangan pertama sebanyak panjang matrik yang dimulai dari indeks terakhir untuk mengambil nilai hasil dari x_{n} hingga x_{1} dan mengubah nilai matrik di indeks yang menyimpan nilai x_{i} dengan nilai yang diperoleh di perulangan kedua yang dibagi dengan koefisien x_{i} . Perulangan kedua(di dalam perulangan pertama) untuk mengurangi nilai hasil dengan nilai korfisien yang dikalikan dengan nilai x_{i} . Perulangan ketiga(di dalam perulangan pertama) untuk menampilkan nilai matrik setelah diubah. Menampilkan nilai dari x_{1} hingga x_{n} . Kemudian implementasi dari algoritma tersebut ialah sebagai berikut Source Code Metode Eliminasi Gauss matrik = [ [[ 6 , - 2 , 2 , 4 ],[ \"X1\" ],[ 16 ]], [[ 12 , - 8 , 6 , 10 ],[ \"X2\" ],[ 26 ]], [[ 3 , - 13 , 9 , 3 ],[ \"X3\" ],[ - 19 ]], [[ - 6 , 4 , 1 , - 18 ],[ \"X4\" ],[ - 34 ]], ] print ( \"Penyelesaiaan Sistem Persamaan Linear Dari\" ) for u in matrik : print ( u ) print ( \"Menggunakan Metode Eliminasi Gauss\" ) print ( \"=======================================================\" ) print ( \">>>>>>>>>>>>>>- METODE ELIMINNASI GAUSS -<<<<<<<<<<<<<\" ) print ( \"=======================================================\" ) #untuk Eliminasi Maju for k in range ( 0 , len ( matrik ) - 1 ): for i in range ( k + 1 , len ( matrik )): faktor = matrik [ i ][ 0 ][ k ] / matrik [ k ][ 0 ][ k ] print ( \"faktor = \" , faktor ) for j in range ( k , len ( matrik )): matrik [ i ][ 0 ][ j ] = round ( matrik [ i ][ 0 ][ j ] - ( faktor * matrik [ k ][ 0 ][ j ]), 4 ) matrik [ i ][ 2 ][ 0 ] = round ( matrik [ i ][ 2 ][ 0 ] - ( faktor * matrik [ k ][ 2 ][ 0 ]), 2 ) for u in matrik : print ( u ) print ( \" \\n \" ) #Untuk Substitusi Mundur for i in range ( len ( matrik ) - 1 , - 1 , - 1 ): sum = matrik [ i ][ 2 ][ 0 ] for j in range ( i + 1 , len ( matrik )): sum = sum - round (( matrik [ i ][ 0 ][ j ] * matrik [ j ][ 1 ][ 0 ]), 4 ) matrik [ i ][ 1 ][ 0 ] = round ( sum / matrik [ i ][ 0 ][ i ], 4 ) for u in matrik : print ( u ) print ( \" \\n \" ) print ( \"Nilai Variabel yang diperoleh\" ) for u in range ( len ( matrik [ 0 ][ 0 ])): print ( f \"x { u + 1 } = { round ( matrik [ u ][ 1 ][ 0 ], 4 ) } \" ) print ( \"=======================================================\" ) Dan hasil output dari source code tersebut ialah sebagai berikut. Penyelesaiaan Sistem Persamaan Linear Dari [[6, -2, 2, 4], ['X1'], [16]] [[12, -8, 6, 10], ['X2'], [26]] [[3, -13, 9, 3], ['X3'], [-19]] [[-6, 4, 1, -18], ['X4'], [-34]] Menggunakan Metode Eliminasi Gauss ======================================================= >>>>>>>>>>>>>>- METODE ELIMINNASI GAUSS -<<<<<<<<<<<<< ======================================================= faktor = 2.0 [[6, -2, 2, 4], ['X1'], [16]] [[0.0, -4.0, 2.0, 2.0], ['X2'], [-6.0]] [[3, -13, 9, 3], ['X3'], [-19]] [[-6, 4, 1, -18], ['X4'], [-34]] faktor = 0.5 [[6, -2, 2, 4], ['X1'], [16]] [[0.0, -4.0, 2.0, 2.0], ['X2'], [-6.0]] [[0.0, -12.0, 8.0, 1.0], ['X3'], [-27.0]] [[-6, 4, 1, -18], ['X4'], [-34]] faktor = -1.0 [[6, -2, 2, 4], ['X1'], [16]] [[0.0, -4.0, 2.0, 2.0], ['X2'], [-6.0]] [[0.0, -12.0, 8.0, 1.0], ['X3'], [-27.0]] [[0.0, 2.0, 3.0, -14.0], ['X4'], [-18.0]] faktor = 3.0 [[6, -2, 2, 4], ['X1'], [16]] [[0.0, -4.0, 2.0, 2.0], ['X2'], [-6.0]] [[0.0, 0.0, 2.0, -5.0], ['X3'], [-9.0]] [[0.0, 2.0, 3.0, -14.0], ['X4'], [-18.0]] faktor = -0.5 [[6, -2, 2, 4], ['X1'], [16]] [[0.0, -4.0, 2.0, 2.0], ['X2'], [-6.0]] [[0.0, 0.0, 2.0, -5.0], ['X3'], [-9.0]] [[0.0, 0.0, 4.0, -13.0], ['X4'], [-21.0]] faktor = 2.0 [[6, -2, 2, 4], ['X1'], [16]] [[0.0, -4.0, 2.0, 2.0], ['X2'], [-6.0]] [[0.0, 0.0, 2.0, -5.0], ['X3'], [-9.0]] [[0.0, 0.0, 0.0, -3.0], ['X4'], [-3.0]] [[6, -2, 2, 4], ['X1'], [16]] [[0.0, -4.0, 2.0, 2.0], ['X2'], [-6.0]] [[0.0, 0.0, 2.0, -5.0], ['X3'], [-9.0]] [[0.0, 0.0, 0.0, -3.0], [1.0], [-3.0]] [[6, -2, 2, 4], ['X1'], [16]] [[0.0, -4.0, 2.0, 2.0], ['X2'], [-6.0]] [[0.0, 0.0, 2.0, -5.0], [-2.0], [-9.0]] [[0.0, 0.0, 0.0, -3.0], [1.0], [-3.0]] [[6, -2, 2, 4], ['X1'], [16]] [[0.0, -4.0, 2.0, 2.0], [1.0], [-6.0]] [[0.0, 0.0, 2.0, -5.0], [-2.0], [-9.0]] [[0.0, 0.0, 0.0, -3.0], [1.0], [-3.0]] [[6, -2, 2, 4], [3.0], [16]] [[0.0, -4.0, 2.0, 2.0], [1.0], [-6.0]] [[0.0, 0.0, 2.0, -5.0], [-2.0], [-9.0]] [[0.0, 0.0, 0.0, -3.0], [1.0], [-3.0]] Nilai Variabel yang diperoleh x1 = 3.0 x2 = 1.0 x3 = -2.0 x4 = 1.0 =======================================================","title":"1. Metode Eliminasi Gauss"},{"location":"SPL/#2_metode_jacobi","text":"\u200b Metode jacobi merupakan metode untuk menyelesaikan sistem persamaan linear dengan cara melakukan iterasi. Misalkan terdapat 3 persamaan dengan 3 bilangan tak diketahui : a_{11}x_{1}+a_{12}x_{2}+a_{13}x_{3}=b_{1}\\\\a_{21}x_{1}+a_{22}x_{2}+a_{23}x_{3}=b_{2}\\\\a_{31}x_{1}+a_{32}x_{2}+a_{33}x_{3}=b_{3} \u200b Dari sistem persamaan tersebut dengan menggunakan metode jacobi kita dapat menhitung nilai x_{1} dengan menggunakan persamaan pertama. Begitu pula dengan x_{2} dan x_{3} dapat dihitung dengan menggunakan persamaan kedua dan ketiga, sehingga didapat : x_{1} = \\dfrac{b_{1}-a_{12}x_{2}-a_{13}x_{3}}{a_{11}}\\\\x_{2} = \\dfrac{b_{2}-a_{21}x_{1}-a_{23}x_{3}}{a_{22}}\\\\x_{3} = \\dfrac{b_{3}-a_{31}x_{1}-a_{32}x_{2}}{a_{33}} \u200b Sehingga metode jacobi secara umum dapat dituliskan sebagai berikut:[^3] x^{(k+1)}_{i} =\\left( b_{i}-\\sum^{i-1}_{j=1}a_{ij}x^{k}_{j}-\\sum^{n}_{j=i+1}a_{ij}x^{k}_{j} \\right)/a_{ii} Contoh : Selesaikan sistem persamaan linear 4 variabel berikut menggunakan iterasi jacobi. 10a - b + 2c = 6 -a + 11b - c + 3d = 25 2a - b + 10c - d = -11 3b - c + 8d = 15 Jawab : Dari soal diperoleh : 10x_{1}-x_{2}+2x_{3} = 6\\\\ -x{1}+11x_{2}-x_{3}+3x_{4} = 25 \\\\ 2x_{1}-x_{2}+10_{x3}-x_{4}=11\\\\ 3x_{2}-x_{3}+8x_{4} = 15 Sehingga nilai x_{1} hingga x_{4} : x_{1} =(x_{2}-2x_{3}+6)/10\\\\ x_{2} =(x_{1}+x_{3}-3x_{4}+25)/11\\\\ x_{3} =(-2x_{1}+x_{2}+x_{4}-11)/10\\\\ x_{4} =(-3x_{2}+x_{3}+15)/8 Sehingga nilai x_{1} hingga x_{4} pada iterasi ke k dapat dituliskan sebagai berikut : x_{1}^{(k+1)} =(x_{2}^{k}-2x_{3}^{k}+6)/10\\\\ x_{2}^{(k+1)} =(x_{1}^{k}+x_{3}^{k}-3x_{4}^{k}+25)/11\\\\ x_{3}^{(k+1)} =(-2x_{1}^{k}+x_{2}^{k}+x_{4}^{k}-11)/10\\\\ x_{4}^{(k+1)} =(-3x_{2}^{k}+x_{3}^{k}+15)/8 Dan nilai yang diperoleh disajikan dalam tabel berikut : X_{i} K = 1 K = 2 K = 3 K = 4 K = 5 K = 6 K = 7 K = 8 K = 9 K = 10 x_{1} 0,6000 1,0473 0,9326 1,0152 0,9890 1,0032 0,9981 1,0006 0,9997 1,0001 x_{2} 2,2727 1,7159 2,0533 1,9537 2,0114 1,9922 2,0023 1,9987 2.0004 1,9998 x_{3} -1,1000 -0,8052 -1,0493 -0,9681 -1,0103 -0,9945 -1,0020 0,9990 -1,0004 -0,9998 x_{4} -1,8750 0,8852 1,1309 0,9738 1,0214 0,9944 1.0036 0,9989 1,0006 0,9998 Algoritma Metode Jacobi Deklarasikan SPL dalam bentuk matrik Deklarasi nilai X_{i} dari hasil analitik Deklarasi array yang kosong ( K = [ ] ) Buat perulangan untuk menampilkan SPL dalam bentuk matrik Tentukan banyak iterasi ( n ) Buat perulangan untuk membuat nilai awal x_{i} = 0 Buat perulangan bersarang dengan ketentuan : Perulangan pertama sebanyak n inputan untuk menentukan berapa kali melakukan iterasi. Dan menghapus nilai di dalam array kosong( K = [ ] ). Perulangan kedua(di dalam perulangan pertama) sebanyak panjang dari matrik untuk mengambil nilai hasil di dalam matrik. Dan menampung nilai yang dihasilkan dari perulangan ketiga kedalam array kosong . Perulangan ketiga(di dalam perulangan kedua) sebanyak panjang dari matrik untuk mengurangi nilai hasil dengan koefisien yang dikalikan dengan nilai x_{i} dengan mengambil nilai dari matrik. Perulangan keempat(di dalam perulangan pertama) sebanyak panjang matrik untuk mengubah nilai x_{i} dengan nilai yang ditampung di array kosong. Dan menghitung nilai error yang dihasilkan kemudian menampilkan nilai x_{i} dan error yang dihasilkan pada iterasi ke-k. Sehingga source code dari metode jacobi ialah sebagai berikut. Source Code Metode Jacobi matrik = [ [[ 10 , - 1 , 2 , 0 ],[ \"X1\" ],[ 6 ]], [[ - 1 , 11 , - 1 , 3 ],[ \"X2\" ],[ 25 ]], [[ 2 , - 1 , 10 , - 1 ],[ \"X3\" ],[ - 11 ]], [[ 0 , 3 , - 1 , 8 ],[ \"X4\" ],[ 15 ]], ] true = [ 1 , 2 , - 1 , 1 ] K = [] print ( \"Penyelesaiaan Sistem Persamaan Linear Dari\" ) for i in matrik : print ( i ) print ( \"Menggunakan Metode Jacobi\" ) n = int ( input ( \"Masukkan banyak iterasi : \" )) print ( \"=======================================================\" ) print ( \">>>>>>>>>>>>>>>>>>>>- METODE JACOBI -<<<<<<<<<<<<<<<<<<\" ) print ( \"=======================================================\" ) for i in range ( len ( matrik [ 0 ][ 0 ])): matrik [ i ][ 1 ][ 0 ] = 0 for k in range ( n ): for i in range ( len ( matrik )): sum = matrik [ i ][ 2 ][ 0 ] for j in range ( len ( matrik )): if i == j : continue sum = sum - matrik [ i ][ 0 ][ j ] * matrik [ j ][ 1 ][ 0 ] K . append ( sum / matrik [ i ][ 0 ][ i ]) print ( f \"iterasi { k + 1 } \" , ' \\t ' , \"|Xi\" , ' \\t\\t\\t ' , \"|errorXi\" ) for x in range ( len ( matrik )): matrik [ x ][ 1 ][ 0 ] = K [ x ] ea = abs (( true [ x ] - K [ x ]) / true [ x ]) * 100 print ( \"X\" + str ( x + 1 ), ' \\t\\t ' , \"| %.10f |\" % K [ x ], ' \\t ' , \" %.10f \" % ea ) K . clear () print ( \"=======================================================\" ) Dan output yang dihasilkan sebagai berikut. Penyelesaiaan Sistem Persamaan Linear Dari [[10, -1, 2, 0], ['X1'], [6]] [[-1, 11, -1, 3], ['X2'], [25]] [[2, -1, 10, -1], ['X3'], [-11]] [[0, 3, -1, 8], ['X4'], [15]] Menggunakan Metode Jacobi Masukkan banyak iterasi : 10 ======================================================= >>>>>>>>>>>>>>>>>>>>- METODE JACOBI -<<<<<<<<<<<<<<<<<< ======================================================= iterasi 1 |Xi |errorXi X1 |0.6000000000| 40.0000000000 X2 |2.2727272727| 13.6363636364 X3 |-1.1000000000| 10.0000000000 X4 |1.8750000000| 87.5000000000 iterasi 2 |Xi |errorXi X1 |1.0472727273| 4.7272727273 X2 |1.7159090909| 14.2045454545 X3 |-0.8052272727| 19.4772727273 X4 |0.8852272727| 11.4772727273 iterasi 3 |Xi |errorXi X1 |0.9326363636| 6.7363636364 X2 |2.0533057851| 2.6652892562 X3 |-1.0493409091| 4.9340909091 X4 |1.1308806818| 13.0880681818 iterasi 4 |Xi |errorXi X1 |1.0151987603| 1.5198760331 X2 |1.9536957645| 2.3152117769 X3 |-0.9681086260| 3.1891373967 X4 |0.9738427169| 2.6157283058 iterasi 5 |Xi |errorXi X1 |0.9889913017| 1.1008698347 X2 |2.0114147258| 0.5707362885 X3 |-1.0102859039| 1.0285903926 X4 |1.0213505101| 2.1350510072 iterasi 6 |Xi |errorXi X1 |1.0031986534| 0.3198653362 X2 |1.9922412607| 0.3879369659 X3 |-0.9945217367| 0.5478263254 X4 |0.9944337398| 0.5566260154 iterasi 7 |Xi |errorXi X1 |0.9981284734| 0.1871526582 X2 |2.0023068816| 0.1153440776 X3 |-1.0019722306| 0.1972230620 X4 |1.0035943102| 0.3594310151 iterasi 8 |Xi |errorXi X1 |1.0006251343| 0.0625134279 X2 |1.9986703011| 0.0664849439 X3 |-0.9990355755| 0.0964424487 X4 |0.9988883906| 0.1111609410 iterasi 9 |Xi |errorXi X1 |0.9996741452| 0.0325854785 X2 |2.0004476715| 0.0223835773 X3 |-1.0003691577| 0.0369157685 X4 |1.0006191901| 0.0619190140 iterasi 10 |Xi |errorXi X1 |1.0001185987| 0.0118598691 X2 |1.9997679470| 0.0116026495 X3 |-0.9998281429| 0.0171857126 X4 |0.9997859785| 0.0214021540 =======================================================","title":"2. Metode Jacobi"},{"location":"SPL/#3_metode_gauss_seidel","text":"\u200b Metode Gauss Seidel merupakan metode penyelesaian sistem persamaan linear yang hampir sama dengan metode jacobi. Hanya saja di dalam metode jacobi nilai x_{1} yang didapat dari persamaan pertama tidak digunakan untuk menghitung nilai x_{2} dengan menggunakan persamaan kedua. Demikian halnya dengan nilai x_{2} tidak digunakan untuk mencari nilai x_{3} , begitu seterusnya. 2 Sedangkan didalam metode Gauss Seidel nilai x_{1} yang diperoleh dari persamaan sebelumnya akan dipakai untuk mencari nilai x_{2} begitupun seterusnya. Sehingga dapat disimpulkan metode Jacobi tidak menggunakan nilai yang terbaru sedangkan metode Gauss Seidel menggunakan nilai yang terbaru. \u200b Sehingga bentuk metoode Gauss Seidel secara umum dapat dituliskan sebagai berikut:[^3] x^{(k+1)}_{i} =\\left( b_{i}-\\sum^{i-1}_{j=1}a_{ij}x^{(k+1)}_{j}-\\sum^{n}_{j=i+1}a_{ij}x^{k}_{j} \\right)/a_{ii} Contoh : Selesaikan sistem persamaan linear 4 variabel berikut menggunakan iterasi Gauss Seidel. 10a - b + 2c = 6 -a + 11b - c + 3d = 25 2a - b + 10c - d = -11 3b - c + 8d = 15 Jawab : Dari soal diperoleh : 10x_{1}-x_{2}+2x_{3} = 6\\\\ -x{1}+11x_{2}-x_{3}+3x_{4} = 25 \\\\ 2x_{1}-x_{2}+10_{x3}-x_{4}=11\\\\ 3x_{2}-x_{3}+8x_{4} = 15 Sehingga nilai x_{1} hingga x_{4} : x_{1} =(x_{2}-2x_{3}+6)/10\\\\ x_{2} =(x_{1}+x_{3}-3x_{4}+25)/11\\\\ x_{3} =(-2x_{1}+x_{2}+x_{4}-11)/10\\\\ x_{4} =(-3x_{2}+x_{3}+15)/8 Sehingga nilai x_{1} hingga x_{4} pada iterasi ke k dapat dituliskan sebagai berikut : x_{1}^{(k+1)} =(x_{2}^{k}-2x_{3}^{k}+6)/10\\\\ x_{2}^{(k+1)} =(x_{1}^{(k+1)}+x_{3}^{k}-3x_{4}^{k}+25)/11\\\\ x_{3}^{(k+1)} =(-2x_{1}^{(k+1)}+x_{2}^{(k+1)}+x_{4}^{k}-11)/10\\\\ x_{4}^{(k+1)} =(-3x_{2}^{(k+1)}+x_{3}^{(k+1)}+15)/8 Dan nilai yang diperoleh disajikan dalam tabel berikut : K = 1 K = 2 K = 3 K = 4 K = 5 x_{1} 0,6000 1,0302 1,0066 1,0009 1,0001 x_{2} 2,3273 2,0369 2,0036 2,0003 2,0000 x_{3} -0,9873 -1,0145 -1,0025 -1,0003 -1,0000 x_{4} 0,8789 0,9843 0,9984 0,9998 1,0000 Algoritma Metode Jacobi Deklarasikan SPL dalam bentuk matrik Deklarasi nilai X_{i} dari hasil analitik Buat perulangan untuk menampilkan SPL dalam bentuk matrik Tentukan banyak iterasi ( n ) Buat perulangan untuk membuat nilai awal x_{i} = 0 Buat perulangan bersarang dengan ketentuan : Perulangan pertama sebanyak n inputan untuk menentukan berapa kali melakukan iterasi. Perulangan kedua(di dalam perulangan pertama) sebanyak panjang dari matrik untuk mengambil nilai hasil di dalam matrik. Dan mengubah nilai x_{i} menjadi nilai yang dihasilkan dari perulangan ketiga. Perulangan ketiga(di dalam perulangan kedua) sebanyak panjang dari matrik untuk mengurangi nilai hasil dengan koefisien yang dikalikan dengan nilai x_{i} dengan mengambil nilai dari matrik. Perulangan keempat(di dalam perulangan pertama) sebanyak panjang matrik untuk menghitung nilai error yang dihasilkan kemudian menampilkan nilai x_{i} dan error yang dihasilkan pada iterasi ke-k. Sehingga source code dari metode Gauss Seidel ialah sebagai berikut. Source Code Metode Gauss Seidel matrik = [ [[ 10 , - 1 , 2 , 0 ],[ \"X1\" ],[ 6 ]], [[ - 1 , 11 , - 1 , 3 ],[ \"X2\" ],[ 25 ]], [[ 2 , - 1 , 10 , - 1 ],[ \"X3\" ],[ - 11 ]], [[ 0 , 3 , - 1 , 8 ],[ \"X4\" ],[ 15 ]], ] true = [ 1 , 2 , - 1 , 1 ] print ( \"Penyelesaiaan Sistem Persamaan Linear Dari\" ) for i in matrik : print ( i ) print ( \"Menggunakan Metode Gauss Seidel\" ) n = int ( input ( \"Masukkan banyak iterasi : \" )) print ( \"=======================================================\" ) print ( \">>>>>>>>>>>>>>>>>- METODE GAUSS SEIDEL -<<<<<<<<<<<<<<<\" ) print ( \"=======================================================\" ) for i in range ( len ( matrik [ 0 ][ 0 ])): matrik [ i ][ 1 ][ 0 ] = 0 for k in range ( n ): for i in range ( len ( matrik )): Xi = matrik [ i ][ 1 ][ 0 ] sum = matrik [ i ][ 2 ][ 0 ] for j in range ( len ( matrik )): if j == i : continue sum = sum - matrik [ i ][ 0 ][ j ] * matrik [ j ][ 1 ][ 0 ] matrik [ i ][ 1 ][ 0 ] = sum / matrik [ i ][ 0 ][ i ] print ( f \"iterasi { k + 1 } \" , ' \\t ' , \"|Xi\" , ' \\t\\t\\t ' , \"|errorXi\" ) for x in range ( len ( matrik )): ea = abs (( matrik [ x ][ 1 ][ 0 ] - true [ x ]) / true [ x ]) * 100 print ( \"X\" + str ( x + 1 ), ' \\t\\t ' , \"| %.10f |\" % matrik [ x ][ 1 ][ 0 ], ' \\t ' , \" %.10f \" % ea ) print ( \"=======================================================\" ) Dan hasil ouput dari source code tersebut ialah sebagai berikut. Penyelesaiaan Sistem Persamaan Linear Dari [[10, -1, 2, 0], ['X1'], [6]] [[-1, 11, -1, 3], ['X2'], [25]] [[2, -1, 10, -1], ['X3'], [-11]] [[0, 3, -1, 8], ['X4'], [15]] Menggunakan Metode Gauss Seidel Masukkan banyak iterasi : 5 ======================================================= >>>>>>>>>>>>>>>>>- METODE GAUSS SEIDEL -<<<<<<<<<<<<<<< ======================================================= iterasi 1 |Xi |errorXi X1 |0.6000000000| 40.0000000000 X2 |2.3272727273| 16.3636363636 X3 |-0.9872727273| 1.2727272727 X4 |0.8788636364| 12.1136363636 iterasi 2 |Xi |errorXi X1 |1.0301818182| 3.0181818182 X2 |2.0369380165| 1.8469008264 X3 |-1.0144561983| 1.4456198347 X4 |0.9843412190| 1.5658780992 iterasi 3 |Xi |errorXi X1 |1.0065850413| 0.6585041322 X2 |2.0035550169| 0.1777508452 X3 |-1.0025273847| 0.2527384673 X4 |0.9983509456| 0.1649054423 iterasi 4 |Xi |errorXi X1 |1.0008609786| 0.0860978625 X2 |2.0002982507| 0.0149125328 X3 |-1.0003072761| 0.0307276102 X4 |0.9998497465| 0.0150253509 iterasi 5 |Xi |errorXi X1 |1.0000912803| 0.0091280286 X2 |2.0000213422| 0.0010671123 X3 |-1.0000311472| 0.0031147183 X4 |0.9999881033| 0.0011896740 =======================================================","title":"3. Metode Gauss Seidel"},{"location":"SPL/#referensi","text":"https://id.m.wikipedia.org/wiki/Sistem_persamaan_linear \u21a9 https://www.slideshare.net/KhannalPakinde/makalah-metode-numerik-sistem-persamaan-linear \u21a9 \u21a9 \u21a9 \u21a9 \u21a9","title":"Referensi"},{"location":"index/","text":"INTEGRASI NUMERIK \u00b6 A. Definisi Integrasi Numerik \u00b6 \u200b Integrasi numerik merupakan metode penyelesaian integral yang digunakan oleh ilmuwan agar memperoleh jawaban aproksimasi dari integral yang tidak dapat diselesaikan secara analitik yang didasarkan pada perhitungan perkiraan. 1 Dari pengertian tersebut dapat disimpulkan bahwa integrasi numerik dapat dilakukan apabila : Integral sulit/tidak dapat diselesaikan secara analitik, Fungsi yang diintegralkan yang diberikan berbentuk angka/tabel. 2 \u200b Metode numerik dilakukan untuk mencoba lebih cepat dan lebih mendekati jawaban eksak dengan cara melakukan penintegralan pada bagian - bagian kecil. Dalam kalkulus perhitungan integral adalah perhitungan dasar yang digunakan dalam banyak hal. Perhitungan dilakukan dengan cara membagi luasan dalam beberapa pias kecil yang dibatasi oleh fungsi y = f(x) dan sumbu x . Kemudian luas totalnya adalah jumlah dari luas semua pias. 1 \u200b Secara umum integral fungsi y(x) dapat dinyatakan sebagai berikut. I = \\int^{b}_{x=a} y(x) dx \u200b Persamaan diatas dapat diartikan sebagai integral dari fungsi y(x) terhadap peubah bebas x yang dievaluasi mulai dari x = a hingga x = b . Pendekatan numerik terhadap persamaan integral tersebut dapat dinyatakan sebagai berikut. 3 I = \\sum ^{N}_{i=1}w_{i}y\\left( x_{i}\\right) \u200b Dengan N menyatakan jumlah segmen, y(x_{i}) = y(a) dan y(x_{n}) = y(b) . Pendekatan numerik pada integral diatas merupakan penjumlahan dari deret suku-suku dengan titik-titik x_{i} yang terbentang dari x = a hingga x = b dan di setiap titik x_{i} dievaluasi menjadi fungsi y(x) . Faktor x_{i} ini biasanya disebut sebagai titik simpul ( node ). sedangkan faktor pengali w_{i} disebut faktor bobot. 3 B. Metode Integrasi Numerik \u00b6 \u200b Untuk menyelesaikan integrasi numerik terdapat beberapa metode diantaranya sebagai berikut. 1. Metode Trapesium \u00b6 \u200b Sesuai dengan namanya metode trapesium merupakan metode integrasi numerik yang didasarkan pada penjumlahan pias/segmen berbentuk trapesium 3 . Dalam metode ini grafik lengkung dari fungsi f(x) digantikan oleh garis lurus. Luasan bidang di bawah fungsi f(x) antara x = a hingga x = b pada gambar di bawah didekati oleh luas trapesium di bawah garis lurus yang menghubungkan f(a) dan f(b) . 2 \u200b Penggunaan garis lurus untuk mendekati grafik lengkung ini menyebabkan terjadinya kesalahan sebesar luasan yang tidak diarsir 2 . Apabila sebuah integral diselesaikan dengan menggunakan metode trapesium satu segmen saja, maka dapat dituliskan sebagai berikut. \\int^{a}_{b} f(x) dx =I= \\dfrac{b-a}{2}[f(a) + f(b)] Keterangan : I = Hasil pengintegralan f(x) = Fungsi yang diintegralkan a = Batas atas integral b = Batas bawah integral Untuk lebih jelasnya perhatikan contoh berikut. Tentukan nilai aproksimasi integral dari fungsi f(x) = 4x^{3} dari x = 0 hingga x = 4 dengan menggunakan metode trapesium. jawab: Jika dikerjakan secara analitik, maka hasilnya sebagai berikut. \\int^{4}_{0} 4x^{3} dx = x^{4}I^{4}_{0} = 4^{4} - 4^{0} = 256 - 0 = 256 Sedangkan jika dikerjakan dengan menggunakan metode trapesium hasilnya sebagai berikut. \\int^{4}_{0} 4x^{3} dx = \\dfrac{4-0}{2}[4\\times0^{3} + 4\\times4^{3}] =2[4\\times0 + 4\\times64] = 2[0 + 256] = 512 Dari hasil yang didapatkan dari metode trapesium didapatkan eror yang sangat besar yaitu sebagai berikut. e = \\dfrac{256-512}{256} \\times 100 = -100 Untuk mengurangi nilai kesalahan ( eror ) tersebut, maka kurva lengkung didekati oleh sejumlah garis lurus , sehingga terbentuk banyak pias yang dideskripsikan pada gambar berikut. 2 Maka integral totalnya dapat ditulis dalam bentuk : \\int^{x1}_{x0}f(x)dx + \\int^{x2}_{x1}f(x)dx+...+\\int^{xn}_{n-1}f(x)dx Apabila terdapat n pias, berarti panjang setiap pias adalah : \\Delta x = \\dfrac{a-b}{n} Sehingga didapat persamaan sebagai berikut : \\int^{a}_{b} f(x) dx = \\dfrac{\\Delta x}{2}[f(x_{1})+f(x_{0})] + \\dfrac{\\Delta x}{2}[f(x_{2})+f(x_{1})]++...+\\dfrac{\\Delta x}{2}[f(x_{n})+f(x_{n-1})] atau \\int^{a}_{b} f(x) dx =I =\\dfrac{\\Delta x}{2}[f(b)+f(a)+2\\sum ^{n-1}_{i=1}f(x_{i})] Keterangan : I = Hasil pengintegralan f(x) = Fungsi yang diintegralkan a = Batas atas integral b = Batas bawah integral \\Delta x = Panjang setiap pias/segmen n = Banyak pias/segmen Untuk lebih jelasnya perhatikan contoh berikut. Tentukan nilai aproksimasi integral dari fungsi f(x) = 4x^{3} dari x = 0 hingga x = 4 dengan menggunakan metode trapesium empat pias. jawab: Dari soal diperoleh a = 0, b = 4 dan n = 4, maka panjang pias : \\Delta x = \\dfrac {4-0}{4} = 1 Sehingga nilai I : I =\\dfrac{1}{2}[(4 \\times 0^{3})+(4\\times4^{3})+2((4\\times1^{3})+(4\\times2^{3})+4\\times3^{3})] \\dfrac{1}{2}[0+256+2(4+32+108)] \\dfrac{1}{2}[256+2(144)] \\dfrac{1}{2}[256+288] \\dfrac{1}{2}[544]=272 Dari hasil yang didapatkan nilai erornya semakin kecil yaitu : e = \\dfrac{256-272}{256} \\times 100\\% = -6,25\\% Dari sini dapat ditarik kesimpulan bahwa di dalam metode trapesium semakin banyak pias maka nilai kesalahan ( eror ) yang didapat semakin kecil. Dan algoritma program dari untuk metode trapesium dapat dinyatakan sebagai berikut. Mendefinisikan fungsi yang akan diintegrasikan, Menentukan batas atas a dan batas bawah b , Menginputkan banyaknya iterasi (pias/segmen) yaitu n , Menghitung lebar segmen/pias yaitu h =(b-a)/n , Deklarasi nilai awal x = 0 dan sigma = 0 , Update nilai x = x + h setiap melakukan perulangan Mengupdate nilai sigma dimulai dari n = 1 sampai n = n - 1 , Menghitung nilai I dengan menjumlahkan nilai sigma dari n = 1 sampai n = n -1 dengan nilai f(a) dan f(b) , Cetak hasil perhitungannya. Kemudian implementasi dari algoritma tersebut sebagai berikut. 4 def f ( x ): #deklarasi fungsi y = 4 * x ** 3 #nilai fungsi return y true = 256 #nilai analitik a = 4 #batas atas b = 0 #batas bawah n = int ( input ( \"Masukkan banyak iterasi : \" )) #inputkan banyak iterasi(segmen/pias) h = ( a - b ) / n #hitung lebar segmen/pias x = b #inisialisasi awal nilai x sigma = 0 #inisialisasi awal nilai sigma I = ( h / 2 ) * ( f ( b ) + sigma + f ( a )) #menghitung nilai I e = ( true - I ) / true * 100 # menghitung eror print ( \"===========================================================================\" ) print ( \">>>>>>>>>>>>>>>>>>>>>>>>>>>- METODE TRAPESIUM -<<<<<<<<<<<<<<<<<<<<<<<<<<<<\" ) print ( \"===========================================================================\" ) print ( '|iterasi|' , 'nilai xi' , ' \\t |' , 'nilai f(xi)' , ' \\t |' , 'nilai I'' \\t |' , 'nilai eror|' ) print ( \"| %d \" % 1 , ' \\t |' , \" %f \" % x , ' \\t |' , \" %f \" % f ( a ), ' \\t |' , \" %f \" % I , ' \\t |' , \" %f |\" % e ) for i in range ( 1 , n ): x = x + h #nilai x diupdate y = i + 1 sigma = sigma + 2 * f ( x ) #nilai I dari n=1 hingga n=n-1 I = ( h / 2 ) * ( f ( b ) + sigma + f ( a )) #menghitung nilai I e = ( true - I ) / true * 100 # menghitung eror print ( \"| %d \" % y , ' \\t |' , \" %f \" % x , ' \\t |' , \" %f \" % f ( x ), ' \\t |' , \" %f \" % I , ' \\t |' , \" %f |\" % e ) #menampilkan nilai keseluruhan print ( \"===========================================================================\" ) print ( \"Hasil integral numerik dari METODE TRAPESIUM ialah : %f \" % I ) #menampilkan nilai I print ( \"Dan nilai eror yang dihasilkan dari METODE TRAPESIUM ialah : %f \" % e ) #menampilkan nilai eror Dan hasil dari source code program tersebut sebagai berikut. Masukkan banyak iterasi : 4 =========================================================================== >>>>>>>>>>>>>>>>>>>>>>>>>>>- METODE TRAPESIUM -<<<<<<<<<<<<<<<<<<<<<<<<<<<< =========================================================================== |iterasi| nilai xi | nilai f(xi) | nilai I | nilai eror| |1 | 0.000000 | 256.000000 | 128.000000 | 50.000000| |2 | 1.000000 | 4.000000 | 132.000000 | 48.437500| |3 | 2.000000 | 32.000000 | 164.000000 | 35.937500| |4 | 3.000000 | 108.000000 | 272.000000 | -6.250000| =========================================================================== Hasil integral numerik dari METODE TRAPESIUM ialah : 272.000000 Dan nilai eror yang dihasilkan dari METODE TRAPESIUM ialah : -6.250000 2. Metode Simpson 1/3 \u00b6 \u200b Metode simpson 1/3 merupakan metode integrasi numerik yang dilakukan dengan menggunakan polinomial orde 2, yang melalui 3 titik data agar memperoleh ketelitian yang lebih tinggi.Metode simpson 1/3 memerlukan langkah yang genap untuk menerapkan metodenya.Dengan kata lain, jumlah langkah untuk metode Simpson 1/3 harus dapat dibagi dengan 2. 3 Metode simpson 1/3 dideskripsikan oleh gambar berikut. Persamaan metode simpson 1/3 dengan 1 segmen dapat dituliskan sebagai berikut. \\int^{a}_{b} f(x) dx= \\dfrac{\\Delta x}{3}[f(a) + 4f(c) + f(b)] I = \\dfrac{b-a}{6}[f(a) + 4f(c) + f(b)] Keterangan : I = Hasil pengintegralan f(x) = Fungsi yang diintegralkan a = Batas atas integral b = Batas bawah integral c = Nilai tengah (b-a/2) Untuk lebih jelasnya selesaikan contoh berikut. Tentukan nilai aproksimasi integral dari fungsi f(x) = 4x^{3} dari x = 0 hingga x = 4 dengan menggunakan metode simpson1/3. jawab : I = \\dfrac{4-0}{6}[4\\times0^{3}+4(4\\times2^{3})+4\\times4^{3}] =\\dfrac{4}{6}[0+4(32)+4\\times64] =\\dfrac{4}{6}[0+128+256] =\\dfrac{4}{6}[384]=256 Untuk eror yang dihasilkan dari metode simpson 1/3 yaitu sebagai berikut. e = \\dfrac{256-256}{256} \\times 100\\% = 0\\% Sama halnya dengan metode trapesium, metode simpson1/3 juga dapat menggunakan banyak segmen/pias yang dideskripsikan pada gambar berikut. 2 Metode simpson 1/3 banyak pias dapat dinyatakan sebagai berikut. \\int^{a}_{b} f(x) dx= I = \\dfrac{\\Delta x}{3}[f(a)+f(b)+4\\sum^{n-1}_{i=1,3,5}f(x_{i})+2\\sum^{n-2}_{i=2,3,6}f(x_{i})] Keterangan : I = Hasil pengintegralan f(x) = Fungsi yang diintegralkan a = Batas atas integral b = Batas bawah integral n = Banyak pias/segmen Untuk lebih jelasnya perhatikan contoh berikut. Tentukan nilai aproksimasi integral dari fungsi f(x) = 4x^{3} dari x = 0 hingga x = 4 dengan menggunakan metode simpson 1/3 empat pias. jawab: Dengan menggunakan metode simpson 1/3 diperoleh I = \\dfrac{1}{3}[4\\times0^{3}+4\\times4^{3}+4((4\\times1^{3})+(4\\times3^{3}))+2(4\\times2^{3})] \\dfrac{1}{3}[0+256+4(4+108)+2(32)] \\dfrac{1}{3}[256+4(112)+64] \\dfrac{1}{3}[256+448+64] \\dfrac{1}{3}[768]=256 Untuk eror yang dihasilkan dari metode simpson 1/3 dengan 4 segmen/pias yaitu sebagai berikut. e = \\dfrac{256-256}{256} \\times 100\\% = 0\\% Algoritma program untuk metode simpson 1/3 dinyatakan sebagai berikut. Mendefinisikan fungsi yang akan diintegrasikan, Menentukan batas atas a dan batas bawah b , Menginputkan banyaknya iterasi (pias/segmen) yaitu n , Menghitung lebar segmen/pias yaitu h =(b-a)/n , Deklarasi nilai awal x = 0 dan sigma = 0 , Update nilai x = x + h setiap melakukan perulangan Mengupdate nilai sigma mulai dari n = 1 hingga n = n -1 dengan ketentuan : Jika i = ganjil maka sigma = sigma + 4 \\times f(x) jika i = genap maka sigma = sigma + 2 \\times f(x) Menghitung nilai I dengan menjumlahkan nilai sigma dari n = 1 sampai n = n -1 dengan nilai f(a) dan f(b) , Cetak hasil perhitungannya. Dan implementasi dari algoritma tersebut terangkum dalam source code berikut. 5 def f ( x ): #deklarasi fungsi y = 4 * x ** 3 #nilai fungsi return y true = 256 #nilai analitik a = 4 #batas atas b = 0 #batas bawah n = int ( input ( \"Masukkan banyak iterasi : \" )) #inputkan banyak iterasi(segmen/pias) h = ( a - b ) / n #hitung lebar segmen/pias x = b #inisialisasi awal nilai x sigma = 0 #inisialisasi awal nilai sigma I = ( h / 3 ) * ( f ( b ) + sigma + f ( a )) #menghitung nilai I e = ( true - I ) / true * 100 # menghitung eror print ( \"===========================================================================\" ) print ( \">>>>>>>>>>>>>>>>>>>>>>>>>>- METODE 1/3 RAMPSON -<<<<<<<<<<<<<<<<<<<<<<<<<<<\" ) print ( \"===========================================================================\" ) print ( '|iterasi|' , 'nilai xi' , ' \\t |' , 'nilai f(xi)' , ' \\t |' , 'nilai I'' \\t |' , 'nilai eror|' ) print ( \"| %d \" % 1 , ' \\t |' , \" %f \" % x , ' \\t |' , \" %f \" % f ( x ), ' \\t |' , \" %f \" % I , ' \\t |' , \" %f |\" % e ) for i in range ( 1 , n ): x = x + h #update nilai x y = i + 1 if ( i % 2 ) == 1 : #kondisi jika ganjil sigma = sigma + 4 * f ( x ) #update nilai sigma 4*f(x) else : #kondisi jika genap sigma = sigma + 2 * f ( x ) #update nilai sigma 2*f(x) I = ( h / 3 ) * ( f ( b ) + sigma + f ( a )) #menghitung nilai I e = ( true - I ) / true * 100 # menghitung eror print ( \"| %d \" % y , ' \\t |' , \" %f \" % x , ' \\t |' , \" %f \" % f ( x ), ' \\t |' , \" %f \" % I , ' \\t |' , \" %f |\" % e ) #menampilkan nilai keseluruhan print ( \"===========================================================================\" ) print ( \"Hasil integral numerik dari METODE SIMPSON 1/3 ialah : %f \" % I ) #menampilkan nilai I print ( \"Dan nilai eror yang dihasilkan dari METODE SIMPSON 1/3 ialah : %f \" % e ) #menampilkan nilai eror Dan hasil output dari source code tersebut ialah sebagai berikut. Masukkan banyak iterasi : 4 =========================================================================== >>>>>>>>>>>>>>>>>>>>>>>>>>- METODE 1/3 RAMPSON -<<<<<<<<<<<<<<<<<<<<<<<<<<< =========================================================================== |iterasi| nilai xi | nilai f(xi) | nilai I | nilai eror| |1 | 0.000000 | 0.000000 | 85.333333 | 66.666667| |2 | 1.000000 | 4.000000 | 90.666667 | 64.583333| |3 | 2.000000 | 32.000000 | 112.000000 | 56.250000| |4 | 3.000000 | 108.000000 | 256.000000 | 0.000000| =========================================================================== Hasil integral numerik dari METODE SIMPSON 1/3 ialah : 256.000000 Dan nilai eror yang dihasilkan dari METODE SIMPSON 1/3 ialah : 0.000000 3. Metode Simpson 3/8 \u00b6 \u200b Metode simpson3/8 merupakan metode integrasi numerik yang dilakukan dengan menggunakan polinomial orde 3, yang melalui 4 titik data 2 Lain halnya dengan metode Simpson 1/3, metode simpson 3/8 tidak mensyaratkan jumlah langkah yang genap ataupun ganjil melainkan mensyaratkan jumlah langkah yang dapat dibagi dengan 3. Ungkapan metode Simpson 3/8 untuk 3 segmen dinyatakan sebagai berikut. 3 \\int^{a}_{b} f(x) dx=I = \\dfrac{3\\Delta x}{8}[f(x_{0})+3f(x_{1})+3f(x_{2})+f(x_{3})] atau \\int^{a}_{b} f(x) dx=I = {3\\Delta x}\\dfrac{[f(x_{0})+3f(x_{1})+3f(x_{2})+f(x_{3})]}{8} Keterangan : I = Hasil pengintegralan f(x) = Fungsi yang diintegralkan a = Batas atas integral b = Batas bawah integral \\Delta x = Panjang setiap pias/segmen Contoh: Tentukan nilai aproksimasi integral dari fungsi f(x) = 4x^{3} dari x = 0 hingga x = 4 dengan menggunakan metode simpson 3/8. jawab: Dengan menggunakan metode simpson 3/8 diperoleh I = (4-0)\\dfrac{[4\\times0^{3}+3(4\\times1,3333^{3})+3(4\\times2,6666^{3})+4\\times4^{3}]}{8} 4\\dfrac{[0+3(4\\times2,37)+3(4\\times18,96)+4\\times64]}{8} 4\\dfrac{[3(9,48)+3(75,85)+4\\times64]}{8} 4\\dfrac{[28,4+227,6+256]}{8} 4\\dfrac{[512]}{8} = 256 Dari hasil tersebut diperoleh nilai eror e = \\dfrac{256-256}{256} \\times 100\\% = 0\\% Sedangkan untuk metode simpson 3/8 banyak segmen/pias dapat didefinisikan sebagai berikut. \\int^{a}_{b} f(x) dx=I = \\dfrac{3\\times h}{8}[f(a)+3\\sum^{n-1}_{i=1}f(x_{i})+2\\sum^{n-3}_{i=3,6,9,...}f(x_{i}) + f(b)] Keterangan : I = Hasil pengintegralan f(x) = Fungsi yang diintegralkan a = Batas atas integral b = Batas bawah integral h = Panjang setiap pias/segmen n = Banyak pias/segmen Contoh: Tentukan nilai aproksimasi integral dari fungsi f(x) = 4x^{3} dari x = 0 hingga x = 4 dengan menggunakan metode simpson 3/8 6 pias. Jawab: I = \\dfrac{3\\times0,67}{8}[4\\times0^{3}+3(4\\times0,67^{3})+3(4\\times1,33^{3})+2(4\\times2^{3})+3(4\\times2,67^{3}) +3(4\\times3,33^{3})+4\\times4^{3}] \\dfrac{2}{8}[0+3(4\\times0,296)+3(4\\times2,37)+2(4\\times8)+3(4\\times18,96)+3(4\\times37,037)+4\\times64] \\dfrac{1}{4}[0+3(1,185)+3(9,481)+2(32)+3(75,85)+3(148,128)+256] \\dfrac{1}{4}[0+3,55+28,44+64+227,55+444,384+256] \\dfrac{1}{4}[1024] = 256 Dari hasil tersebut diperoleh nilai eror e = \\dfrac{256-256}{256} \\times 100\\% = 0\\% Berikut ini merupakan algoritma program metode simpson 3/8 Mendefinisikan fungsi yang akan diintegrasikan, Menentukan batas atas a dan batas bawah b , Menginputkan banyaknya iterasi (pias/segmen) yaitu n , Menghitung lebar segmen/pias yaitu h =(b-a)/n , Deklarasi nilai awal x = 0 dan sigma = 0 , Update nilai x = x + h setiap melakukan perulangan Mengupdate nilai sigma mulai dari n = 1 hingga n = n -1 dengan ketentuan : Jika i habis dibagi 3 maka sigma = sigma + 2 \\times f(x) Jika tidak maka sigma = sigma + 3 \\times f(x) Menghitung nilai I dengan menjumlahkan nilai sigma dari n = 1 sampai n = n -1 dengan nilai f(a) dan f(b) , Cetak hasil perhitungannya. Dan implementasi dari algoritma tersebut terangkum dalam source code berikut. 6 def f ( x ): #deklarasi fungsi y = 4 * x ** 3 #nilai fungsi return y true = 256 #nilai analitik a = 4 #batas atas b = 0 #batas bawah n = int ( input ( \"Masukkan banyak iterasi : \" )) #inputkan banyak iterasi(segmen/pias) h = ( a - b ) / n #hitung lebar segmen/pias x = b #inisialisasi awal nilai x sigma = 0 #inisialisasi awal nilai sigma I = ( 3 * h / 8 ) * ( f ( b ) + sigma + f ( a )) #menghitung nilai I e = ( true - I ) / true * 100 # menghitung eror print ( \"===========================================================================\" ) print ( \">>>>>>>>>>>>>>>>>>>>>>>>>>- METODE 3/8 RAMPSON -<<<<<<<<<<<<<<<<<<<<<<<<<<<\" ) print ( \"===========================================================================\" ) print ( '|iterasi|' , 'nilai xi' , ' \\t |' , 'nilai f(xi)' , ' \\t |' , 'nilai I'' \\t |' , 'nilai eror|' ) print ( \"| %d \" % 1 , ' \\t |' , \" %f \" % x , ' \\t |' , \" %f \" % f ( x ), ' \\t |' , \" %f \" % I , ' \\t |' , \" %f |\" % e ) for i in range ( 1 , n ): x = x + h #nilai x diupdate y = i + 1 if ( i % 3 ) == 0 : #kondisi jika habis dibagi 3 sigma = sigma + 2 * f ( x ) #update nilai sigma + 2*f(x) else : #jika tidak memenuhi sigma = sigma + 3 * f ( x ) #update nilai sigma + 3*f(x) I = ( 3 * h / 8 ) * ( f ( b ) + sigma + f ( a )) #menghitung nilai I e = ( true - I ) / true * 100 # menghitung eror print ( \"| %d \" % y , ' \\t |' , \" %f \" % x , ' \\t |' , \" %f \" % f ( x ), ' \\t |' , \" %f \" % I , ' \\t |' , \" %f |\" % e ) #menampilkan nilai keseluruhanprint print ( \"===========================================================================\" ) print ( \"Hasil integral dari METODE SIMPSON 3/8 ialah : %f \" % I ) #menampilkan nilai I print ( \"Dan nilai eror yang dihasilkan dari METODE SIMPSON 3/8 ialah : %f \" % e ) #menampilkan nilai eror Dan hasil output dari source code tersebut sebagai berikut Masukkan banyak iterasi : 6 =========================================================================== >>>>>>>>>>>>>>>>>>>>>>>>>>- METODE 3/8 RAMPSON -<<<<<<<<<<<<<<<<<<<<<<<<<<< =========================================================================== |iterasi| nilai xi | nilai f(xi) | nilai I | nilai eror| |1 | 0.000000 | 0.000000 | 64.000000 | 75.000000| |2 | 0.666667 | 1.185185 | 64.888889 | 74.652778| |3 | 1.333333 | 9.481481 | 72.000000 | 71.875000| |4 | 2.000000 | 32.000000 | 88.000000 | 65.625000| |5 | 2.666667 | 75.851852 | 144.888889 | 43.402778| |6 | 3.333333 | 148.148148 | 256.000000 | 0.000000 | =========================================================================== Hasil integral dari METODE SIMPSON 3/8 ialah : 256.000000 Dan nilai eror yang dihasilkan dari METODE SIMPSON 3/8 ialah : 0.000000 4. Aturan Titik Tengah \u00b6 \u200b Aturan titik tengah merupakan metode integrasi numerik yang diperoleh degan cara yang sama dengan aturan trapesium. Dengan mengevaluasi fungsi f(x) di titik tengah pada setiap interval, maka kesalahannya akan jauh lebih kecil dibandingkan dengan metode trapesium. Gambar berikut memberikan deskripsi grafis terhadap pendekatan ini. 3 \u200b Untuk dapat mereduksi kesalahan dari metode ini adalah dengan cara membagi interval x_{0} hingga x_{1} menjadi n segmen yang lebih kecil. Aturan titik tengah banyak segmen ini dapat dinyatakan sebagai berikut. 3 \\int^{a}_{b} f(x)dx = I = h\\sum^{n-1}_{i=0}f(x_{(a+1/2)}h) Keterangan : I = Hasil pengintegralan f(x) = Fungsi yang diintegralkan a = Batas atas integral b = Batas bawah integral h = Panjang setiap pias/segmen n = Banyak pias/segmen Contoh : Tentukan nilai aproksimasi integral dari fungsi f(x) = 4x^{3} dari x = 0 hingga x = 4 dengan menggunakan aturan titik tengah empat pias/segmen. \u200b Jawab : \\int^{4}_{0}4x^{3} = 1[4\\times((0+0.5)1)^{3} + 4\\times((1+0.5)1)^{3} + 4\\times((2+0.5)1)^{3} + 4\\times((3+0.5)1)^{3}] 1[4(0.5^{3})+4(1,5^{3})+4(2,5^{3})+4(3,5^{3})] 1[4(0,125)+4(3,375)+4(15,625)+4(42,875)] 1[0,5+13,5+62,5+171,5] = 248 Dari hasil tersebut diperoleh nilai eror sebesar e = \\dfrac{256-248}{256} \\times 100\\% = 3,125\\% Algoritma program untuk aturan titik tengah dapat dinyatakan sebagai berikut. Mendefinisikan fungsi yang akan diintegrasikan, Menentukan batas atas a dan batas bawah b , Menginputkan banyaknya iterasi (pias/segmen) yaitu n , Menghitung lebar segmen/pias yaitu h =(b-a)/n , Menghitung nilai x = a + (h/2) Inisialisasi nilai sigma sama dengan nilai fungsi f(x) Update nilai x = x + h setiap melakukan perulangan Update nilai sigma = sigma + f(x) Hitung nilai I = h \\times sigma Cetak hasil perhitungannya. Kemudian implementasi dari algoritma tersebut terangkum dalam source code berikut. 7 def f ( x ): #deklarasi fungsi y = 4 * x ** 3 #nilai fungsi return y true = 256 #nilai analitik a = 4 #batas atas b = 0 #batas bawah n = int ( input ( \"Masukkan banyak iterasi : \" )) #inputkan banyak iterasi(segmen/pias) h = ( a - b ) / n #hitung lebar segmen/pias x = b + h / 2 #inisialisasi awal nilai x sigma = f ( x ) #inisialisasi awal nilai sigma I = h * sigma e = ( true - I ) / true * 100 # menghitung eror print ( \"===========================================================================\" ) print ( \">>>>>>>>>>>>>>>>>>>>>>>>>>>- ATURAN TITIK TENGAH -<<<<<<<<<<<<<<<<<<<<<<<<<\" ) print ( \"===========================================================================\" ) print ( \"banyak iterasi : \" , n ) print ( '|iterssi|' , 'nilai xi' , ' \\t |' , 'nilai f(xi)' , ' \\t |' , 'nilai I'' \\t |' , 'nilai eror|' ) print ( \"| %d \" % 1 , ' \\t |' , \" %f \" % x , ' \\t |' , \" %f \" % f ( x ), ' \\t |' , \" %f \" % I , ' \\t |' , \" %f |\" % e ) for i in range ( 1 , n ): x = x + h #nilai x diupdate y = i + 1 sigma = sigma + f ( x ) #nilai I dari n=1 hingga n=n-1 I = h * sigma #menghitung nilai I e = ( true - I ) / true * 100 # menghitung eror print ( \"| %d \" % y , ' \\t |' , \" %f \" % x , ' \\t |' , \" %f \" % f ( x ), ' \\t |' , \" %f \" % I , ' \\t |' , \" %f |\" % e ) #menampilkan nilai keseluruhan print ( \"===========================================================================\" ) print ( \"Hasil integral numerik dari ATURAN TITIK TENGAH ialah : %f \" % I ) #menampilkan nilai print ( \"Dan nilai eror yang dihasilkan dari ATURAN TITIK TENGAH ialah : %f \" % e ) #menampilkan nilai eror Dan hasil output dari source code tersebut sebagai berikut. Masukkan banyak iterasi : 4 =========================================================================== >>>>>>>>>>>>>>>>>>>>>>>>>>>- ATURAN TITIK TENGAH -<<<<<<<<<<<<<<<<<<<<<<<<< =========================================================================== banyak iterasi : 4 |iterssi| nilai xi | nilai f(xi) | nilai I | nilai eror| |1 | 0.500000 | 0.500000 | 0.500000 | 99.804688| |2 | 1.500000 | 13.500000 | 14.000000 | 94.531250| |3 | 2.500000 | 62.500000 | 76.500000 | 70.117188| |4 | 3.500000 | 171.500000 | 248.000000 | 3.125000| =========================================================================== Hasil integral numerik dari ATURAN TITIK TENGAH ialah : 248.000000 Dan nilai eror yang dihasilkan dari ATURAN TITIK TENGAH ialah : 3.125000 Referensi \u00b6 http://ishaq.staff.gunadarma.ac.id/Downloads/files/43838/Integrasi+Numerik.pdf \u21a9 \u21a9 https://youtu.be/0UcJbiFHiT4 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 http://staffnew.uny.ac.id/upload/132206562/pendidikan/Integrasi+Numerik.pdf \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 https://youtu.be/iAszeC2_1cU \u21a9 https://youtu.be/U8dttZ5MMsA \u21a9 https://youtu.be/lY8e3DysYSs \u21a9 https://youtu.be/qOaWNCBnePk \u21a9","title":"\t\t\t\t\t\t\t\t\t\t\t INTEGRASI NUMERIK"},{"location":"index/#integrasi_numerik","text":"","title":"INTEGRASI NUMERIK"},{"location":"index/#a_definisi_integrasi_numerik","text":"\u200b Integrasi numerik merupakan metode penyelesaian integral yang digunakan oleh ilmuwan agar memperoleh jawaban aproksimasi dari integral yang tidak dapat diselesaikan secara analitik yang didasarkan pada perhitungan perkiraan. 1 Dari pengertian tersebut dapat disimpulkan bahwa integrasi numerik dapat dilakukan apabila : Integral sulit/tidak dapat diselesaikan secara analitik, Fungsi yang diintegralkan yang diberikan berbentuk angka/tabel. 2 \u200b Metode numerik dilakukan untuk mencoba lebih cepat dan lebih mendekati jawaban eksak dengan cara melakukan penintegralan pada bagian - bagian kecil. Dalam kalkulus perhitungan integral adalah perhitungan dasar yang digunakan dalam banyak hal. Perhitungan dilakukan dengan cara membagi luasan dalam beberapa pias kecil yang dibatasi oleh fungsi y = f(x) dan sumbu x . Kemudian luas totalnya adalah jumlah dari luas semua pias. 1 \u200b Secara umum integral fungsi y(x) dapat dinyatakan sebagai berikut. I = \\int^{b}_{x=a} y(x) dx \u200b Persamaan diatas dapat diartikan sebagai integral dari fungsi y(x) terhadap peubah bebas x yang dievaluasi mulai dari x = a hingga x = b . Pendekatan numerik terhadap persamaan integral tersebut dapat dinyatakan sebagai berikut. 3 I = \\sum ^{N}_{i=1}w_{i}y\\left( x_{i}\\right) \u200b Dengan N menyatakan jumlah segmen, y(x_{i}) = y(a) dan y(x_{n}) = y(b) . Pendekatan numerik pada integral diatas merupakan penjumlahan dari deret suku-suku dengan titik-titik x_{i} yang terbentang dari x = a hingga x = b dan di setiap titik x_{i} dievaluasi menjadi fungsi y(x) . Faktor x_{i} ini biasanya disebut sebagai titik simpul ( node ). sedangkan faktor pengali w_{i} disebut faktor bobot. 3","title":"A. Definisi Integrasi Numerik"},{"location":"index/#b_metode_integrasi_numerik","text":"\u200b Untuk menyelesaikan integrasi numerik terdapat beberapa metode diantaranya sebagai berikut.","title":"B. Metode Integrasi Numerik"},{"location":"index/#1_metode_trapesium","text":"\u200b Sesuai dengan namanya metode trapesium merupakan metode integrasi numerik yang didasarkan pada penjumlahan pias/segmen berbentuk trapesium 3 . Dalam metode ini grafik lengkung dari fungsi f(x) digantikan oleh garis lurus. Luasan bidang di bawah fungsi f(x) antara x = a hingga x = b pada gambar di bawah didekati oleh luas trapesium di bawah garis lurus yang menghubungkan f(a) dan f(b) . 2 \u200b Penggunaan garis lurus untuk mendekati grafik lengkung ini menyebabkan terjadinya kesalahan sebesar luasan yang tidak diarsir 2 . Apabila sebuah integral diselesaikan dengan menggunakan metode trapesium satu segmen saja, maka dapat dituliskan sebagai berikut. \\int^{a}_{b} f(x) dx =I= \\dfrac{b-a}{2}[f(a) + f(b)] Keterangan : I = Hasil pengintegralan f(x) = Fungsi yang diintegralkan a = Batas atas integral b = Batas bawah integral Untuk lebih jelasnya perhatikan contoh berikut. Tentukan nilai aproksimasi integral dari fungsi f(x) = 4x^{3} dari x = 0 hingga x = 4 dengan menggunakan metode trapesium. jawab: Jika dikerjakan secara analitik, maka hasilnya sebagai berikut. \\int^{4}_{0} 4x^{3} dx = x^{4}I^{4}_{0} = 4^{4} - 4^{0} = 256 - 0 = 256 Sedangkan jika dikerjakan dengan menggunakan metode trapesium hasilnya sebagai berikut. \\int^{4}_{0} 4x^{3} dx = \\dfrac{4-0}{2}[4\\times0^{3} + 4\\times4^{3}] =2[4\\times0 + 4\\times64] = 2[0 + 256] = 512 Dari hasil yang didapatkan dari metode trapesium didapatkan eror yang sangat besar yaitu sebagai berikut. e = \\dfrac{256-512}{256} \\times 100 = -100 Untuk mengurangi nilai kesalahan ( eror ) tersebut, maka kurva lengkung didekati oleh sejumlah garis lurus , sehingga terbentuk banyak pias yang dideskripsikan pada gambar berikut. 2 Maka integral totalnya dapat ditulis dalam bentuk : \\int^{x1}_{x0}f(x)dx + \\int^{x2}_{x1}f(x)dx+...+\\int^{xn}_{n-1}f(x)dx Apabila terdapat n pias, berarti panjang setiap pias adalah : \\Delta x = \\dfrac{a-b}{n} Sehingga didapat persamaan sebagai berikut : \\int^{a}_{b} f(x) dx = \\dfrac{\\Delta x}{2}[f(x_{1})+f(x_{0})] + \\dfrac{\\Delta x}{2}[f(x_{2})+f(x_{1})]++...+\\dfrac{\\Delta x}{2}[f(x_{n})+f(x_{n-1})] atau \\int^{a}_{b} f(x) dx =I =\\dfrac{\\Delta x}{2}[f(b)+f(a)+2\\sum ^{n-1}_{i=1}f(x_{i})] Keterangan : I = Hasil pengintegralan f(x) = Fungsi yang diintegralkan a = Batas atas integral b = Batas bawah integral \\Delta x = Panjang setiap pias/segmen n = Banyak pias/segmen Untuk lebih jelasnya perhatikan contoh berikut. Tentukan nilai aproksimasi integral dari fungsi f(x) = 4x^{3} dari x = 0 hingga x = 4 dengan menggunakan metode trapesium empat pias. jawab: Dari soal diperoleh a = 0, b = 4 dan n = 4, maka panjang pias : \\Delta x = \\dfrac {4-0}{4} = 1 Sehingga nilai I : I =\\dfrac{1}{2}[(4 \\times 0^{3})+(4\\times4^{3})+2((4\\times1^{3})+(4\\times2^{3})+4\\times3^{3})] \\dfrac{1}{2}[0+256+2(4+32+108)] \\dfrac{1}{2}[256+2(144)] \\dfrac{1}{2}[256+288] \\dfrac{1}{2}[544]=272 Dari hasil yang didapatkan nilai erornya semakin kecil yaitu : e = \\dfrac{256-272}{256} \\times 100\\% = -6,25\\% Dari sini dapat ditarik kesimpulan bahwa di dalam metode trapesium semakin banyak pias maka nilai kesalahan ( eror ) yang didapat semakin kecil. Dan algoritma program dari untuk metode trapesium dapat dinyatakan sebagai berikut. Mendefinisikan fungsi yang akan diintegrasikan, Menentukan batas atas a dan batas bawah b , Menginputkan banyaknya iterasi (pias/segmen) yaitu n , Menghitung lebar segmen/pias yaitu h =(b-a)/n , Deklarasi nilai awal x = 0 dan sigma = 0 , Update nilai x = x + h setiap melakukan perulangan Mengupdate nilai sigma dimulai dari n = 1 sampai n = n - 1 , Menghitung nilai I dengan menjumlahkan nilai sigma dari n = 1 sampai n = n -1 dengan nilai f(a) dan f(b) , Cetak hasil perhitungannya. Kemudian implementasi dari algoritma tersebut sebagai berikut. 4 def f ( x ): #deklarasi fungsi y = 4 * x ** 3 #nilai fungsi return y true = 256 #nilai analitik a = 4 #batas atas b = 0 #batas bawah n = int ( input ( \"Masukkan banyak iterasi : \" )) #inputkan banyak iterasi(segmen/pias) h = ( a - b ) / n #hitung lebar segmen/pias x = b #inisialisasi awal nilai x sigma = 0 #inisialisasi awal nilai sigma I = ( h / 2 ) * ( f ( b ) + sigma + f ( a )) #menghitung nilai I e = ( true - I ) / true * 100 # menghitung eror print ( \"===========================================================================\" ) print ( \">>>>>>>>>>>>>>>>>>>>>>>>>>>- METODE TRAPESIUM -<<<<<<<<<<<<<<<<<<<<<<<<<<<<\" ) print ( \"===========================================================================\" ) print ( '|iterasi|' , 'nilai xi' , ' \\t |' , 'nilai f(xi)' , ' \\t |' , 'nilai I'' \\t |' , 'nilai eror|' ) print ( \"| %d \" % 1 , ' \\t |' , \" %f \" % x , ' \\t |' , \" %f \" % f ( a ), ' \\t |' , \" %f \" % I , ' \\t |' , \" %f |\" % e ) for i in range ( 1 , n ): x = x + h #nilai x diupdate y = i + 1 sigma = sigma + 2 * f ( x ) #nilai I dari n=1 hingga n=n-1 I = ( h / 2 ) * ( f ( b ) + sigma + f ( a )) #menghitung nilai I e = ( true - I ) / true * 100 # menghitung eror print ( \"| %d \" % y , ' \\t |' , \" %f \" % x , ' \\t |' , \" %f \" % f ( x ), ' \\t |' , \" %f \" % I , ' \\t |' , \" %f |\" % e ) #menampilkan nilai keseluruhan print ( \"===========================================================================\" ) print ( \"Hasil integral numerik dari METODE TRAPESIUM ialah : %f \" % I ) #menampilkan nilai I print ( \"Dan nilai eror yang dihasilkan dari METODE TRAPESIUM ialah : %f \" % e ) #menampilkan nilai eror Dan hasil dari source code program tersebut sebagai berikut. Masukkan banyak iterasi : 4 =========================================================================== >>>>>>>>>>>>>>>>>>>>>>>>>>>- METODE TRAPESIUM -<<<<<<<<<<<<<<<<<<<<<<<<<<<< =========================================================================== |iterasi| nilai xi | nilai f(xi) | nilai I | nilai eror| |1 | 0.000000 | 256.000000 | 128.000000 | 50.000000| |2 | 1.000000 | 4.000000 | 132.000000 | 48.437500| |3 | 2.000000 | 32.000000 | 164.000000 | 35.937500| |4 | 3.000000 | 108.000000 | 272.000000 | -6.250000| =========================================================================== Hasil integral numerik dari METODE TRAPESIUM ialah : 272.000000 Dan nilai eror yang dihasilkan dari METODE TRAPESIUM ialah : -6.250000","title":"1. Metode Trapesium"},{"location":"index/#2_metode_simpson_13","text":"\u200b Metode simpson 1/3 merupakan metode integrasi numerik yang dilakukan dengan menggunakan polinomial orde 2, yang melalui 3 titik data agar memperoleh ketelitian yang lebih tinggi.Metode simpson 1/3 memerlukan langkah yang genap untuk menerapkan metodenya.Dengan kata lain, jumlah langkah untuk metode Simpson 1/3 harus dapat dibagi dengan 2. 3 Metode simpson 1/3 dideskripsikan oleh gambar berikut. Persamaan metode simpson 1/3 dengan 1 segmen dapat dituliskan sebagai berikut. \\int^{a}_{b} f(x) dx= \\dfrac{\\Delta x}{3}[f(a) + 4f(c) + f(b)] I = \\dfrac{b-a}{6}[f(a) + 4f(c) + f(b)] Keterangan : I = Hasil pengintegralan f(x) = Fungsi yang diintegralkan a = Batas atas integral b = Batas bawah integral c = Nilai tengah (b-a/2) Untuk lebih jelasnya selesaikan contoh berikut. Tentukan nilai aproksimasi integral dari fungsi f(x) = 4x^{3} dari x = 0 hingga x = 4 dengan menggunakan metode simpson1/3. jawab : I = \\dfrac{4-0}{6}[4\\times0^{3}+4(4\\times2^{3})+4\\times4^{3}] =\\dfrac{4}{6}[0+4(32)+4\\times64] =\\dfrac{4}{6}[0+128+256] =\\dfrac{4}{6}[384]=256 Untuk eror yang dihasilkan dari metode simpson 1/3 yaitu sebagai berikut. e = \\dfrac{256-256}{256} \\times 100\\% = 0\\% Sama halnya dengan metode trapesium, metode simpson1/3 juga dapat menggunakan banyak segmen/pias yang dideskripsikan pada gambar berikut. 2 Metode simpson 1/3 banyak pias dapat dinyatakan sebagai berikut. \\int^{a}_{b} f(x) dx= I = \\dfrac{\\Delta x}{3}[f(a)+f(b)+4\\sum^{n-1}_{i=1,3,5}f(x_{i})+2\\sum^{n-2}_{i=2,3,6}f(x_{i})] Keterangan : I = Hasil pengintegralan f(x) = Fungsi yang diintegralkan a = Batas atas integral b = Batas bawah integral n = Banyak pias/segmen Untuk lebih jelasnya perhatikan contoh berikut. Tentukan nilai aproksimasi integral dari fungsi f(x) = 4x^{3} dari x = 0 hingga x = 4 dengan menggunakan metode simpson 1/3 empat pias. jawab: Dengan menggunakan metode simpson 1/3 diperoleh I = \\dfrac{1}{3}[4\\times0^{3}+4\\times4^{3}+4((4\\times1^{3})+(4\\times3^{3}))+2(4\\times2^{3})] \\dfrac{1}{3}[0+256+4(4+108)+2(32)] \\dfrac{1}{3}[256+4(112)+64] \\dfrac{1}{3}[256+448+64] \\dfrac{1}{3}[768]=256 Untuk eror yang dihasilkan dari metode simpson 1/3 dengan 4 segmen/pias yaitu sebagai berikut. e = \\dfrac{256-256}{256} \\times 100\\% = 0\\% Algoritma program untuk metode simpson 1/3 dinyatakan sebagai berikut. Mendefinisikan fungsi yang akan diintegrasikan, Menentukan batas atas a dan batas bawah b , Menginputkan banyaknya iterasi (pias/segmen) yaitu n , Menghitung lebar segmen/pias yaitu h =(b-a)/n , Deklarasi nilai awal x = 0 dan sigma = 0 , Update nilai x = x + h setiap melakukan perulangan Mengupdate nilai sigma mulai dari n = 1 hingga n = n -1 dengan ketentuan : Jika i = ganjil maka sigma = sigma + 4 \\times f(x) jika i = genap maka sigma = sigma + 2 \\times f(x) Menghitung nilai I dengan menjumlahkan nilai sigma dari n = 1 sampai n = n -1 dengan nilai f(a) dan f(b) , Cetak hasil perhitungannya. Dan implementasi dari algoritma tersebut terangkum dalam source code berikut. 5 def f ( x ): #deklarasi fungsi y = 4 * x ** 3 #nilai fungsi return y true = 256 #nilai analitik a = 4 #batas atas b = 0 #batas bawah n = int ( input ( \"Masukkan banyak iterasi : \" )) #inputkan banyak iterasi(segmen/pias) h = ( a - b ) / n #hitung lebar segmen/pias x = b #inisialisasi awal nilai x sigma = 0 #inisialisasi awal nilai sigma I = ( h / 3 ) * ( f ( b ) + sigma + f ( a )) #menghitung nilai I e = ( true - I ) / true * 100 # menghitung eror print ( \"===========================================================================\" ) print ( \">>>>>>>>>>>>>>>>>>>>>>>>>>- METODE 1/3 RAMPSON -<<<<<<<<<<<<<<<<<<<<<<<<<<<\" ) print ( \"===========================================================================\" ) print ( '|iterasi|' , 'nilai xi' , ' \\t |' , 'nilai f(xi)' , ' \\t |' , 'nilai I'' \\t |' , 'nilai eror|' ) print ( \"| %d \" % 1 , ' \\t |' , \" %f \" % x , ' \\t |' , \" %f \" % f ( x ), ' \\t |' , \" %f \" % I , ' \\t |' , \" %f |\" % e ) for i in range ( 1 , n ): x = x + h #update nilai x y = i + 1 if ( i % 2 ) == 1 : #kondisi jika ganjil sigma = sigma + 4 * f ( x ) #update nilai sigma 4*f(x) else : #kondisi jika genap sigma = sigma + 2 * f ( x ) #update nilai sigma 2*f(x) I = ( h / 3 ) * ( f ( b ) + sigma + f ( a )) #menghitung nilai I e = ( true - I ) / true * 100 # menghitung eror print ( \"| %d \" % y , ' \\t |' , \" %f \" % x , ' \\t |' , \" %f \" % f ( x ), ' \\t |' , \" %f \" % I , ' \\t |' , \" %f |\" % e ) #menampilkan nilai keseluruhan print ( \"===========================================================================\" ) print ( \"Hasil integral numerik dari METODE SIMPSON 1/3 ialah : %f \" % I ) #menampilkan nilai I print ( \"Dan nilai eror yang dihasilkan dari METODE SIMPSON 1/3 ialah : %f \" % e ) #menampilkan nilai eror Dan hasil output dari source code tersebut ialah sebagai berikut. Masukkan banyak iterasi : 4 =========================================================================== >>>>>>>>>>>>>>>>>>>>>>>>>>- METODE 1/3 RAMPSON -<<<<<<<<<<<<<<<<<<<<<<<<<<< =========================================================================== |iterasi| nilai xi | nilai f(xi) | nilai I | nilai eror| |1 | 0.000000 | 0.000000 | 85.333333 | 66.666667| |2 | 1.000000 | 4.000000 | 90.666667 | 64.583333| |3 | 2.000000 | 32.000000 | 112.000000 | 56.250000| |4 | 3.000000 | 108.000000 | 256.000000 | 0.000000| =========================================================================== Hasil integral numerik dari METODE SIMPSON 1/3 ialah : 256.000000 Dan nilai eror yang dihasilkan dari METODE SIMPSON 1/3 ialah : 0.000000","title":"2. Metode Simpson 1/3"},{"location":"index/#3_metode_simpson_38","text":"\u200b Metode simpson3/8 merupakan metode integrasi numerik yang dilakukan dengan menggunakan polinomial orde 3, yang melalui 4 titik data 2 Lain halnya dengan metode Simpson 1/3, metode simpson 3/8 tidak mensyaratkan jumlah langkah yang genap ataupun ganjil melainkan mensyaratkan jumlah langkah yang dapat dibagi dengan 3. Ungkapan metode Simpson 3/8 untuk 3 segmen dinyatakan sebagai berikut. 3 \\int^{a}_{b} f(x) dx=I = \\dfrac{3\\Delta x}{8}[f(x_{0})+3f(x_{1})+3f(x_{2})+f(x_{3})] atau \\int^{a}_{b} f(x) dx=I = {3\\Delta x}\\dfrac{[f(x_{0})+3f(x_{1})+3f(x_{2})+f(x_{3})]}{8} Keterangan : I = Hasil pengintegralan f(x) = Fungsi yang diintegralkan a = Batas atas integral b = Batas bawah integral \\Delta x = Panjang setiap pias/segmen Contoh: Tentukan nilai aproksimasi integral dari fungsi f(x) = 4x^{3} dari x = 0 hingga x = 4 dengan menggunakan metode simpson 3/8. jawab: Dengan menggunakan metode simpson 3/8 diperoleh I = (4-0)\\dfrac{[4\\times0^{3}+3(4\\times1,3333^{3})+3(4\\times2,6666^{3})+4\\times4^{3}]}{8} 4\\dfrac{[0+3(4\\times2,37)+3(4\\times18,96)+4\\times64]}{8} 4\\dfrac{[3(9,48)+3(75,85)+4\\times64]}{8} 4\\dfrac{[28,4+227,6+256]}{8} 4\\dfrac{[512]}{8} = 256 Dari hasil tersebut diperoleh nilai eror e = \\dfrac{256-256}{256} \\times 100\\% = 0\\% Sedangkan untuk metode simpson 3/8 banyak segmen/pias dapat didefinisikan sebagai berikut. \\int^{a}_{b} f(x) dx=I = \\dfrac{3\\times h}{8}[f(a)+3\\sum^{n-1}_{i=1}f(x_{i})+2\\sum^{n-3}_{i=3,6,9,...}f(x_{i}) + f(b)] Keterangan : I = Hasil pengintegralan f(x) = Fungsi yang diintegralkan a = Batas atas integral b = Batas bawah integral h = Panjang setiap pias/segmen n = Banyak pias/segmen Contoh: Tentukan nilai aproksimasi integral dari fungsi f(x) = 4x^{3} dari x = 0 hingga x = 4 dengan menggunakan metode simpson 3/8 6 pias. Jawab: I = \\dfrac{3\\times0,67}{8}[4\\times0^{3}+3(4\\times0,67^{3})+3(4\\times1,33^{3})+2(4\\times2^{3})+3(4\\times2,67^{3}) +3(4\\times3,33^{3})+4\\times4^{3}] \\dfrac{2}{8}[0+3(4\\times0,296)+3(4\\times2,37)+2(4\\times8)+3(4\\times18,96)+3(4\\times37,037)+4\\times64] \\dfrac{1}{4}[0+3(1,185)+3(9,481)+2(32)+3(75,85)+3(148,128)+256] \\dfrac{1}{4}[0+3,55+28,44+64+227,55+444,384+256] \\dfrac{1}{4}[1024] = 256 Dari hasil tersebut diperoleh nilai eror e = \\dfrac{256-256}{256} \\times 100\\% = 0\\% Berikut ini merupakan algoritma program metode simpson 3/8 Mendefinisikan fungsi yang akan diintegrasikan, Menentukan batas atas a dan batas bawah b , Menginputkan banyaknya iterasi (pias/segmen) yaitu n , Menghitung lebar segmen/pias yaitu h =(b-a)/n , Deklarasi nilai awal x = 0 dan sigma = 0 , Update nilai x = x + h setiap melakukan perulangan Mengupdate nilai sigma mulai dari n = 1 hingga n = n -1 dengan ketentuan : Jika i habis dibagi 3 maka sigma = sigma + 2 \\times f(x) Jika tidak maka sigma = sigma + 3 \\times f(x) Menghitung nilai I dengan menjumlahkan nilai sigma dari n = 1 sampai n = n -1 dengan nilai f(a) dan f(b) , Cetak hasil perhitungannya. Dan implementasi dari algoritma tersebut terangkum dalam source code berikut. 6 def f ( x ): #deklarasi fungsi y = 4 * x ** 3 #nilai fungsi return y true = 256 #nilai analitik a = 4 #batas atas b = 0 #batas bawah n = int ( input ( \"Masukkan banyak iterasi : \" )) #inputkan banyak iterasi(segmen/pias) h = ( a - b ) / n #hitung lebar segmen/pias x = b #inisialisasi awal nilai x sigma = 0 #inisialisasi awal nilai sigma I = ( 3 * h / 8 ) * ( f ( b ) + sigma + f ( a )) #menghitung nilai I e = ( true - I ) / true * 100 # menghitung eror print ( \"===========================================================================\" ) print ( \">>>>>>>>>>>>>>>>>>>>>>>>>>- METODE 3/8 RAMPSON -<<<<<<<<<<<<<<<<<<<<<<<<<<<\" ) print ( \"===========================================================================\" ) print ( '|iterasi|' , 'nilai xi' , ' \\t |' , 'nilai f(xi)' , ' \\t |' , 'nilai I'' \\t |' , 'nilai eror|' ) print ( \"| %d \" % 1 , ' \\t |' , \" %f \" % x , ' \\t |' , \" %f \" % f ( x ), ' \\t |' , \" %f \" % I , ' \\t |' , \" %f |\" % e ) for i in range ( 1 , n ): x = x + h #nilai x diupdate y = i + 1 if ( i % 3 ) == 0 : #kondisi jika habis dibagi 3 sigma = sigma + 2 * f ( x ) #update nilai sigma + 2*f(x) else : #jika tidak memenuhi sigma = sigma + 3 * f ( x ) #update nilai sigma + 3*f(x) I = ( 3 * h / 8 ) * ( f ( b ) + sigma + f ( a )) #menghitung nilai I e = ( true - I ) / true * 100 # menghitung eror print ( \"| %d \" % y , ' \\t |' , \" %f \" % x , ' \\t |' , \" %f \" % f ( x ), ' \\t |' , \" %f \" % I , ' \\t |' , \" %f |\" % e ) #menampilkan nilai keseluruhanprint print ( \"===========================================================================\" ) print ( \"Hasil integral dari METODE SIMPSON 3/8 ialah : %f \" % I ) #menampilkan nilai I print ( \"Dan nilai eror yang dihasilkan dari METODE SIMPSON 3/8 ialah : %f \" % e ) #menampilkan nilai eror Dan hasil output dari source code tersebut sebagai berikut Masukkan banyak iterasi : 6 =========================================================================== >>>>>>>>>>>>>>>>>>>>>>>>>>- METODE 3/8 RAMPSON -<<<<<<<<<<<<<<<<<<<<<<<<<<< =========================================================================== |iterasi| nilai xi | nilai f(xi) | nilai I | nilai eror| |1 | 0.000000 | 0.000000 | 64.000000 | 75.000000| |2 | 0.666667 | 1.185185 | 64.888889 | 74.652778| |3 | 1.333333 | 9.481481 | 72.000000 | 71.875000| |4 | 2.000000 | 32.000000 | 88.000000 | 65.625000| |5 | 2.666667 | 75.851852 | 144.888889 | 43.402778| |6 | 3.333333 | 148.148148 | 256.000000 | 0.000000 | =========================================================================== Hasil integral dari METODE SIMPSON 3/8 ialah : 256.000000 Dan nilai eror yang dihasilkan dari METODE SIMPSON 3/8 ialah : 0.000000","title":"3. Metode Simpson 3/8"},{"location":"index/#4_aturan_titik_tengah","text":"\u200b Aturan titik tengah merupakan metode integrasi numerik yang diperoleh degan cara yang sama dengan aturan trapesium. Dengan mengevaluasi fungsi f(x) di titik tengah pada setiap interval, maka kesalahannya akan jauh lebih kecil dibandingkan dengan metode trapesium. Gambar berikut memberikan deskripsi grafis terhadap pendekatan ini. 3 \u200b Untuk dapat mereduksi kesalahan dari metode ini adalah dengan cara membagi interval x_{0} hingga x_{1} menjadi n segmen yang lebih kecil. Aturan titik tengah banyak segmen ini dapat dinyatakan sebagai berikut. 3 \\int^{a}_{b} f(x)dx = I = h\\sum^{n-1}_{i=0}f(x_{(a+1/2)}h) Keterangan : I = Hasil pengintegralan f(x) = Fungsi yang diintegralkan a = Batas atas integral b = Batas bawah integral h = Panjang setiap pias/segmen n = Banyak pias/segmen Contoh : Tentukan nilai aproksimasi integral dari fungsi f(x) = 4x^{3} dari x = 0 hingga x = 4 dengan menggunakan aturan titik tengah empat pias/segmen. \u200b Jawab : \\int^{4}_{0}4x^{3} = 1[4\\times((0+0.5)1)^{3} + 4\\times((1+0.5)1)^{3} + 4\\times((2+0.5)1)^{3} + 4\\times((3+0.5)1)^{3}] 1[4(0.5^{3})+4(1,5^{3})+4(2,5^{3})+4(3,5^{3})] 1[4(0,125)+4(3,375)+4(15,625)+4(42,875)] 1[0,5+13,5+62,5+171,5] = 248 Dari hasil tersebut diperoleh nilai eror sebesar e = \\dfrac{256-248}{256} \\times 100\\% = 3,125\\% Algoritma program untuk aturan titik tengah dapat dinyatakan sebagai berikut. Mendefinisikan fungsi yang akan diintegrasikan, Menentukan batas atas a dan batas bawah b , Menginputkan banyaknya iterasi (pias/segmen) yaitu n , Menghitung lebar segmen/pias yaitu h =(b-a)/n , Menghitung nilai x = a + (h/2) Inisialisasi nilai sigma sama dengan nilai fungsi f(x) Update nilai x = x + h setiap melakukan perulangan Update nilai sigma = sigma + f(x) Hitung nilai I = h \\times sigma Cetak hasil perhitungannya. Kemudian implementasi dari algoritma tersebut terangkum dalam source code berikut. 7 def f ( x ): #deklarasi fungsi y = 4 * x ** 3 #nilai fungsi return y true = 256 #nilai analitik a = 4 #batas atas b = 0 #batas bawah n = int ( input ( \"Masukkan banyak iterasi : \" )) #inputkan banyak iterasi(segmen/pias) h = ( a - b ) / n #hitung lebar segmen/pias x = b + h / 2 #inisialisasi awal nilai x sigma = f ( x ) #inisialisasi awal nilai sigma I = h * sigma e = ( true - I ) / true * 100 # menghitung eror print ( \"===========================================================================\" ) print ( \">>>>>>>>>>>>>>>>>>>>>>>>>>>- ATURAN TITIK TENGAH -<<<<<<<<<<<<<<<<<<<<<<<<<\" ) print ( \"===========================================================================\" ) print ( \"banyak iterasi : \" , n ) print ( '|iterssi|' , 'nilai xi' , ' \\t |' , 'nilai f(xi)' , ' \\t |' , 'nilai I'' \\t |' , 'nilai eror|' ) print ( \"| %d \" % 1 , ' \\t |' , \" %f \" % x , ' \\t |' , \" %f \" % f ( x ), ' \\t |' , \" %f \" % I , ' \\t |' , \" %f |\" % e ) for i in range ( 1 , n ): x = x + h #nilai x diupdate y = i + 1 sigma = sigma + f ( x ) #nilai I dari n=1 hingga n=n-1 I = h * sigma #menghitung nilai I e = ( true - I ) / true * 100 # menghitung eror print ( \"| %d \" % y , ' \\t |' , \" %f \" % x , ' \\t |' , \" %f \" % f ( x ), ' \\t |' , \" %f \" % I , ' \\t |' , \" %f |\" % e ) #menampilkan nilai keseluruhan print ( \"===========================================================================\" ) print ( \"Hasil integral numerik dari ATURAN TITIK TENGAH ialah : %f \" % I ) #menampilkan nilai print ( \"Dan nilai eror yang dihasilkan dari ATURAN TITIK TENGAH ialah : %f \" % e ) #menampilkan nilai eror Dan hasil output dari source code tersebut sebagai berikut. Masukkan banyak iterasi : 4 =========================================================================== >>>>>>>>>>>>>>>>>>>>>>>>>>>- ATURAN TITIK TENGAH -<<<<<<<<<<<<<<<<<<<<<<<<< =========================================================================== banyak iterasi : 4 |iterssi| nilai xi | nilai f(xi) | nilai I | nilai eror| |1 | 0.500000 | 0.500000 | 0.500000 | 99.804688| |2 | 1.500000 | 13.500000 | 14.000000 | 94.531250| |3 | 2.500000 | 62.500000 | 76.500000 | 70.117188| |4 | 3.500000 | 171.500000 | 248.000000 | 3.125000| =========================================================================== Hasil integral numerik dari ATURAN TITIK TENGAH ialah : 248.000000 Dan nilai eror yang dihasilkan dari ATURAN TITIK TENGAH ialah : 3.125000","title":"4. Aturan Titik Tengah"},{"location":"index/#referensi","text":"http://ishaq.staff.gunadarma.ac.id/Downloads/files/43838/Integrasi+Numerik.pdf \u21a9 \u21a9 https://youtu.be/0UcJbiFHiT4 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 http://staffnew.uny.ac.id/upload/132206562/pendidikan/Integrasi+Numerik.pdf \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 https://youtu.be/iAszeC2_1cU \u21a9 https://youtu.be/U8dttZ5MMsA \u21a9 https://youtu.be/lY8e3DysYSs \u21a9 https://youtu.be/qOaWNCBnePk \u21a9","title":"Referensi"},{"location":"index/Differensial/","text":"PERSAMAAN DIFFERENSIAL BIASA (PDB) \u00b6 A. Definisi Persamaan Differensial Biasa (PDB) \u00b6 \u200b Persamaan Differensial Biasa (PDB) merupakan persamaan differensial yang terdiri dari beberapa turunan biasa dari fungsi yang tidak diketahui dari variabel bebas tunggal. 1 Dan variabel bebas tersebut biasanya disimbolkan dengan x. Berikut merupakan contoh contoh persamaan differensial biasa. 2 Contoh : 1.\\ \\dfrac{dy}{dx} = x +y\\\\ 2.\\ y^{'} = x^{2}+y^{2}\\\\ 3.\\ \\dfrac{2dy}{dx} +x^{2}y-y = 0\\\\ 4.\\ y^{''} + y^{'}cos\\ x -3y = sin\\ 2x\\\\ 5.\\ 2y^{'''}-23y^{'} = 1 -y^{''} \u200b Variabel bebas dari contoh 1 hingga 5 adalah x dan variabel terikatnya ialah y yang merupakan fungsi dari x atau bisa ditulis y = f(x) . Berdasarkan turunnan tertinggi yang ada di persamaannya, PDB dikelompokkan lagi berdasarkan ordenya yaitu : 2 PDB orde 1 yaitu turunan tertingginya ialah turunan pertama, contohnya pada contoh nomor 1,2 dan 3 di atas. PDB orde 2 yaitu turunan tertingginya ialah turunan kedua, contohnya pada contoh nomor 4 di atas. PDB orde 3 yaitu turunan tertingginya ialah turunan ketiga, contohnya pada contoh nomor 5 diatas. Dan untuk PDB selanjutnya yang lebih tinggi dinamakan PDB orde lanjut. 2 Metode numerik dapat digunakan untuk menyelesaikan persamaan differensial biasa karena sebagian besar persamaan differensial tidak dapat diselesaikan secara analitik. Berikut ini pembahasan tentang metode numerik untuk menyelesaikan persamaan differensial biasa orde satu. B. Metode Persamaan Differensial Biasa (PDB) \u00b6 \u200b Bentuk baku PDB orde satu dengan nilai awal dapat ditulis : y^{'} = f(x,y)\\ \\ \\ \\ \\ \\ atau\\ \\ \\ \\ \\ \\ \\dfrac{dy}{dx} = f(x,y) dengan nilai awal y(x0) = y PDB orde satu yang tidak mengikuti bentuk tersebut harus ditulis ulang seperti bentuk baku diatas agar dapat diselesaikan secara numerik. Penyelesaian PDB secara numerik berarti menghitung nilai fungsi di x_{i+1} = h , dengan h adalah ukuran langkah setiap lelaran. Pada metode analiti nilai awal berfungsi untuk memperoleh solusi yang unik, sedangkan pada metode numerik nilai awal berfungsi untuk memulai lelaran. Terdapat beberapa metode numerik yang digunakan untuk menyelesaikan PDB , mulai dari mrtode yang paling dasar hingga metode yang lebih teliti, diantanya ialah sebagai berikut. 2 1. Metode Euler \u00b6 \u200b Metode Euler adalah metode yang digunakan untuk menyelesaikan PDB yang dihasilkan dari turunan deret Taylor. Metode euler juga disebut metode orde-pertama dikarenakan hanya mengambil sampai suku pertama saja dari deret Taylor. Selain menggunakan bantuan deret Taylor, metode Euler juga dapat diturunkan dengan menggunakan metode aturan segiempat untuk mengintegrasikan f(x,y) pada persamaan diferensial. Tafsiran geometri penurunan metode Euler digambarkan sebagai berikut. 2 Sehingga bentuk metode Euler dari penurunan tersebut sebagai berikut. y(x_{i+1}) - y(x_{i}) = hf(x_{i},y(x_{i}))\\\\ atau\\\\ y(x_{i+1}) = y(x_{i}) + hf(x_{i},y(x_{i})) Contoh : Diketahui PDB \\dfrac{dy}{dt} = x + y dan y(0) = 1 gunakan metode Euler untuk menghitung y(0,10) dengan ukuran langkah h = 0.02 . Dan diketahui solusi PDB sejatinya = 1,1103 Jawab : Diketahui x_{0} = 0\\\\ y_{0} = 1\\\\ x_{b} = 0,10\\\\ h = 0,02\\\\ f(x,y) = x + y\\\\ hasil\\ analitik = 1,1103 Sehingga nilai n = (x_{b} - x_{0})/h = (0,10-0)/0,02 = 5 (banyaknya langkah) dan penerapan metode Euler pada PDB tersebut menjadi y_{i+1} = y_{i} + 0,02(x_{i}+y{i}) langkah-langkah: x_{0} = 0 \\Rightarrow y_{0} = 1\\\\ x_{1} = 0,02 \\Rightarrow y_{1} = y_{0}+0,02(x_{0}+y_{0}) = 1 + (0,02)(0+1) = 1,0200\\\\ x_{2} = 0,04 \\Rightarrow y_{2} = y_{1}+0,02(x_{1}+y_{1}) = 1,0200 + (0,02)(0,02+1,0200) = 1,0408\\\\ x_{3} = 0,06 \\Rightarrow y_{3} = y_{2}+0,02(x_{2}+y_{2}) = 1,0408 + (0,02)(0,04+1,0408) = 1,0624\\\\ x_{4} = 0,08 \\Rightarrow y_{4} = y_{3}+0,02(x_{3}+y_{3}) = 1,0624 + (0,02)(0,06+1,0624) = 1,0848\\\\ x_{5} = 0,10 \\Rightarrow y_{5} = y_{4}+0,02(x_{4}+y_{4}) = 1,0848 + (0,02)(0,08+1,0848) = 1,1081 Jadi solusi numerik dengan menggunakan metode Euler di y(0,10) = 1,1081 dan nilai error yang dihasilkan ialah e = hasil analitik - solusi numerik = 1,1103 - 1,1081 = 0,0022 Algoritma Metode Euler Deklarasi fungsi PDB yang akan di selesaikan, Masukkan inputan yang dibutuhkan seperti x_{0},y_{0},xb , dan h , Hitung perulangan yang diperlukan dengan menggunakan rumus n = (x_{b} - x_{0})/h , Inisialisasi nilai x dan y awal sama dengan x_{o} dan y_{0} , Tentukan nilai analitiknya untuk menghitung nilai error Lakukan perulangan sebanyak n, Setiap melakukan perulangan update nilai y dan x dengan menggunakan persamaan metode Euler, dan menghitung nilai erornya kemudian cetak hasilnya. Sorce Code Metode Euler def f ( x , y ): return x + y print ( \"Penyelesaian Persamaan Differensial Biasa Menggunakan Metode Euler\" ) x0 = float ( input ( \"Masukkan Nilai X0 : \" )) y0 = float ( input ( \"Masukkan Nilai y0 : \" )) xb = float ( input ( \"Masukkan Nilai X yang dicari : \" )) h = float ( input ( \"Masukkan Nilai h : \" )) n = ( xb - x0 ) / h iterasi = int ( n ) x = x0 y = y0 true = 1.1103 e = abs ( true - y ) print ( \"==================================================\" ) print ( \">>>>>>>>>>>>>>>>>>- METODE EULER -<<<<<<<<<<<<<<<<\" ) print ( \"==================================================\" ) print ( '|i' , ' \\t |' , 'x(i)' , ' \\t\\t |' , 'y(i) \\t\\t |e' ) print ( \"| %d \" % x0 , ' \\t |' , \" %f \" % x , ' \\t |' , \" %f \\t |\" % y , \" %f \" % e ) for i in range ( iterasi ): y = y + h * f ( x , y ) x = x + h e = abs ( true - y ) print ( \"| %d \" % ( i + 1 ), ' \\t |' , \" %f \" % x , ' \\t |' , \" %f \\t |\" % y , \" %f \" % e ) print ( \"==================================================\" ) Output hasil program sebagai berikut Penyelesaian Persamaan Differensial Biasa Menggunakan Metode Euler Masukkan Nilai X0 : 0 Masukkan Nilai y0 : 1 Masukkan Nilai X yang dicari : 0.1 Masukkan Nilai h : 0.02 ================================================== >>>>>>>>>>>>>>>>>>- METODE EULER -<<<<<<<<<<<<<<<< ================================================== |i | x(i) | y(i) |e |0 | 0.000000 | 1.000000 | 0.110300 |1 | 0.020000 | 1.020000 | 0.090300 |2 | 0.040000 | 1.040800 | 0.069500 |3 | 0.060000 | 1.062416 | 0.047884 |4 | 0.080000 | 1.084864 | 0.025436 |5 | 0.100000 | 1.108162 | 0.002138 ================================================== 2. Metode Heun \u00b6 \u200b Metode Heun merupakan metode perbaikan dari metode Euler yang memiliki nilai error yang tinggi. Pada metode Heun solusi dari metode Euler dijadikan sebagai solusi perkiraan awal( predictor ), selanjutnya solusi perkiraan awal tersebut diperbaiki dengan metode Heun( corrector ). 2 Sehingga persamaan metode Heun dituliskan sebagai berikut. Predictor= y^{0}_{i+1} = y_{i} + hf(x_{i},y_{i})\\\\ Corrector = y_{i+1} = y_{i}+\\dfrac{h}{2}[f(x_{i},y{i})+f(x_i+1),y^{0}_{i+1}] Sehingga tafsiran geometri metode Heun digambarkan sebagai berikut. Contoh : Diketahui PDB \\dfrac{dy}{dt} = x + y dan y(0) = 1 gunakan metode Heun untuk menghitung y(0,10) dengan ukuran langkah h = 0.02 . Dan diketahui solusi PDB sejatinya = 1,1103 Jawab : Diketahui x_{0} = 0\\\\ y_{0} = 1\\\\ x_{b} = 0,10\\\\ h = 0,02\\\\ f(x,y) = x + y\\\\ hasil\\ analitik = 1,1103 Maka nilai n = (x_{b} - x_{0})/h = (0,10-0)/0,02 = 5 (banyaknya langkah) dan penerapan metode Heun pada PDB tersebut menjadi : y_{i+1} = y_{i} + \\dfrac{0,02}{2}[(x_{i}+y{i})+((x_{i}+0,02)+y_{eu})] Langkah-langkah : x_{0} = 0\\Rightarrow y^{0} = 1\\\\ x_{1} = 0,02\\Rightarrow y_{1}= 1 +(\\dfrac{0,02}{2})(0+1+0,02+1,0200) = 1,0204\\\\ x_{2} = 0,04\\Rightarrow y_{2} = 1,0204 +(\\dfrac{0,02}{2})(0,02+1,0204+0,04+1,0412)=1,0416\\\\ x_{3} = 0,04\\Rightarrow y_{3} = 1,0416 +(\\dfrac{0,02}{2})(0,04+1,0204+0,06+1,0632)=1,0636\\\\ x_{4} = 0,04\\Rightarrow y_{4} = 1,0636 +(\\dfrac{0,02}{2})(0,06+1,0204+0,08+1,0861)=1,0865\\\\ x_{5} = 0,04\\Rightarrow y_{5} = 1,0865 +(\\dfrac{0,02}{2})(0,08+1,0204+0,10+1,1098)=1,1103\\\\ Jadi solusi numerik dengan menggunakan metode Heun di y(0,10) = 1,1103 dan nilai error yang dihasilkan ialah e = hasil analitik - solusi numerik = 1,1103 - 1,1103 = 0,0 . Algoritma Metode Heun Deklarasi fungsi PDB yang akan di selesaikan, Masukkan inputan yang dibutuhkan seperti x_{0},y_{0},xb , dan h , Hitung perulangan yang diperlukan dengan menggunakan rumus n = (x_{b} - x_{0})/h , Inisialisasi nilai x dan y awal sama dengan x_{o} dan y_{0} , Tentukan nilai analitiknya untuk menghitung nilai error Lakukan perulangan sebanyak n, Setiap melakukan perulangan update nilai y predictor dan y corrector serta x dengan menggunakan persamaan metode Heun, dan menghitung nilai erornya kemudian cetak hasilnya. Source Code Metode Heun def f ( x , y ): return x + y print ( \"Penyelesaian Persamaan Differensial Biasa Menggunakan Metode Heun\" ) x0 = float ( input ( \"Masukkan Nilai X0 : \" )) y0 = float ( input ( \"Masukkan Nilai y0 : \" )) xb = float ( input ( \"Masukkan Nilai X yang dicari : \" )) h = float ( input ( \"Masukkan Nilai h : \" )) iterasi = ( xb - x0 ) / h n = int ( iterasi ) x = x0 y = y0 true = 1.1103 e = abs ( true - y ) print ( \"==================================================\" ) print ( \">>>>>>>>>>>>>>>>>>- METODE HEUN -<<<<<<<<<<<<<<<<<\" ) print ( \"==================================================\" ) print ( '|i' , ' \\t |' , 'x(i)' , ' \\t\\t |' , 'y(i) \\t\\t |e' ) print ( \"| %d \" % x0 , ' \\t |' , \" %f \" % x , ' \\t |' , \" %f \\t |\" % y , \" %f \" % e ) for i in range ( n ): ypre = y + h * f ( x , y ) y = y + h / 2 * ( f ( x , y ) + f ( x + h , ypre )) x = x + h e = abs ( true - y ) print ( \"| %d \" % ( i + 1 ), ' \\t |' , \" %f \" % x , ' \\t |' , \" %f \\t |\" % y , \" %f \" % e ) print ( \"==================================================\" ) Ouput yang dihasilkan dari program di atas ialah sebagai berikut. Penyelesaian Persamaan Differensial Biasa Menggunakan Metode Heun Masukkan Nilai X0 : 0 Masukkan Nilai y0 : 1 Masukkan Nilai X yang dicari : 0.1 Masukkan Nilai h : 0.02 ================================================== >>>>>>>>>>>>>>>>>>- METODE HEUN -<<<<<<<<<<<<<<<<< ================================================== |i | x(i) | y(i) |e |0 | 0.000000 | 1.000000 | 0.110300 |1 | 0.020000 | 1.020400 | 0.089900 |2 | 0.040000 | 1.041616 | 0.068684 |3 | 0.060000 | 1.063665 | 0.046635 |4 | 0.080000 | 1.086563 | 0.023737 |5 | 0.100000 | 1.110327 | 0.000027 ================================================== 3. Metode Runge-Kutta \u00b6 \u200b Metode Runge-Kutta merupakan metode untuk menyelesaikan persamaan differensial biasa dengan ketelitian yang lebih tinggi, dan menghindarkan mencari turunan yang lebih tinggi dengan jalan mengevaluasi fungsi f(x,y) pada titik terpilih dalam setiap langkah. Metode ini merupakan metode yang paling poopuler dikarenakan banyak dipakai dalam praktek. 2 \u200b Bentuk umum metode runge-Kutta orde-n ialah: y_{i+1} = y_{i}+a_{1}k_{1}+a_{2}k_{2}+\\ldots+a_{n}k_{n} dengan a_{1},a_{2},...,a_{n} adalah tetapan dan k_{1} = hf(x_{i},y_{i})\\\\ k_{2} = hf(x_{i}+p_{1}h,y_{i}+q_{11}k_{1})\\\\ k_{3} = hf(x_{i}+p_{2}h,y_{i}+q_{21}k_{1}+q_{22}k_{2}\\\\ \\cdots\\\\ k_{n} = hf(x_{i}+p_{n-1}h,y_{i}+q_{n-1,1}k_{1}+q_{n-1,2}k_{2}+\\cdots+q_{n-1,n-1} k_{n-1} Dimana nilai a_{i}, p_{i}, q_{ij} dipilih sedemikian rupa sehingga meminimumkan galat perlangkah. Dan berikut ini metode Runge-Kutta berdasarkan ordenya 1. Metode Runge-Kutta Orde Satu \u00b6 Metode Runge-Kutta orde satu berbentuk k_{1} = hf(x_{i},y_{i})\\\\ y_{i+1} = y_{i}+k_{1}\\\\ atau\\\\ y_{i+1} = y_{i} +hf(x_i,y_{i}) Salah satu bentuk contoh dari metode Runge-Kutta orde 1 ialah metode Euler yang dapat dilihat dari bentuk persamaannya. Contoh : Diketahui PDB \\dfrac{dy}{dt} = x + y dan y(0) = 1 gunakan metode Runge-Kutta orde 1 untuk menghitung y(0,10) dengan ukuran langkah h = 0.02 . Dan diketahui solusi PDB sejatinya = 1,1103 Jawab : Diketahui x_{0} = 0\\\\ y_{0} = 1\\\\ x_{b} = 0,10\\\\ h = 0,02\\\\ f(x,y) = x + y\\\\ hasil\\ analitik = 1,1103 Maka nilai n = (x_{b} - x_{0})/h = (0,10-0)/0,02 = 5 (banyaknya langkah) dan penerapan metode Runge-Kutta orde satu pada PDB tersebut menjadi : y_{i+1} = y_{i} +k_{i} Langkah-langkah : x_{0} = 0 \\Rightarrow y_{0} = 1\\\\ x_{1} = 0,02 \\Rightarrow y_{1} = 1 + 0,0200 = 1,0200\\\\ x_{2} = 0,04 \\Rightarrow y_{2} = 1,0200+0,0208 = 1,0404\\\\ x_{3} = 0,06 \\Rightarrow y_{3} = 1,0404+0,0216 = 1,0624\\\\ x_{4} = 0,08 \\Rightarrow y_{4} = 1,0624+0,0254 = 1,0848\\\\ x_{5} = 0,10 \\Rightarrow y_{5} = 1,0848+0,0232 = 1,1081 Jadi solusi numerik dengan menggunakan metode Runge-Kutta orde 1 di y(0,10) = 1,1081 dan nilai error yang dihasilkan ialah e = hasil analitik - solusi numerik = 1,1103 - 1,1081 = 0,0022 Algoritma Metode Runge-Kutta Orde Satu Deklarasi fungsi PDB yang akan di selesaikan, Masukkan inputan yang dibutuhkan seperti x_{0},y_{0},xb , dan h , Hitung perulangan yang diperlukan dengan menggunakan rumus n = (x_{b} - x_{0})/h , Inisialisasi nilai x dan y awal sama dengan x_{o} dan y_{0} , Tentukan nilai analitiknya untuk menghitung nilai error Lakukan perulangan sebanyak n, Update nilai k_{1} , nilai y dan nilai x serta nilai e kemudian cetak nilai nilai tersebut setiap melakukan peulangan. Source Code Metode Runge-Kutta Orde Satu def f ( x , y ): return x + y print ( \"Penyelesaian Sistem Persamaan Differensial Biasa Menggunakan Metode Runge-Kutta Orde1\" ) x0 = float ( input ( \"Masukkan Nilai X0 : \" )) y0 = float ( input ( \"Masukkan Nilai y0 : \" )) xb = float ( input ( \"Masukkan Nilai X yang dicari : \" )) h = float ( input ( \"Masukkan Nilai h : \" )) iterasi = ( xb - x0 ) / h n = int ( iterasi ) x = x0 y = y0 true = 1.1103 e = abs ( true - y ) print ( \"==================================================================\" ) print ( \">>>>>>>>>>>>>>>>>>>>>>- METODE RUNGE-KUTTA1 -<<<<<<<<<<<<<<<<<<<<<\" ) print ( \"==================================================================\" ) print ( '|i' , ' \\t |' , 'x(i)' , ' \\t\\t |' , 'y(i) \\t\\t |e \\t\\t |k1' ) print ( \"| %d \" % x0 , ' \\t |' , \" %f \" % x , ' \\t |' , \" %f \\t |\" % y , \" %f \" % e , \" \\t |0\" ) for i in range ( n ): k1 = h * f ( x , y ) y = y + k1 x = x + h e = abs ( true - y ) print ( \"| %d \" % ( i + 1 ), ' \\t |' , \" %f \" % x , ' \\t |' , \" %f \\t |\" % y , \" %f \\t |\" % e , \" %f \" % k1 ) print ( \"==================================================================\" ) Dan hasil output program diatas sebagai berikut Penyelesaian Sistem Persamaan Differensial Biasa Menggunakan Metode Runge-Kutta Orde1 Masukkan Nilai X0 : 0 Masukkan Nilai y0 : 1 Masukkan Nilai X yang dicari : 0.1 Masukkan Nilai h : 0.02 ================================================================== >>>>>>>>>>>>>>>>>>>>>>- METODE RUNGE-KUTTA1 -<<<<<<<<<<<<<<<<<<<<< ================================================================== |i | x(i) | y(i) |e |k1 |0 | 0.000000 | 1.000000 | 0.110300 |0 |1 | 0.020000 | 1.020000 | 0.090300 | 0.020000 |2 | 0.040000 | 1.040800 | 0.069500 | 0.020800 |3 | 0.060000 | 1.062416 | 0.047884 | 0.021616 |4 | 0.080000 | 1.084864 | 0.025436 | 0.022448 |5 | 0.100000 | 1.108162 | 0.002138 | 0.023297 ================================================================== 2. Metode Runge-Kutta Orde Dua \u00b6 Metode Runge-Kutta orde dua berbentuk k_{1} = hf(x_{i},y_{i})\\\\ k_{2} = hf(x_{i}+h,y_{i}+k_{1})\\\\ y_{i+1}= y_{i}+\\dfrac{1}{2}h(k1+k2) Salah satu bentuk contoh dari metode Runge-Kutta orde 2 ialah metode Heun yang dapat dilihat dari bentuk persamaannya. Contoh : Diketahui PDB \\dfrac{dy}{dt} = x + y dan y(0) = 1 gunakan metode Runge-Kutta orde 2 untuk menghitung y(0,10) dengan ukuran langkah h = 0.02 . Dan diketahui solusi PDB sejatinya = 1,1103 Jawab : Diketahui x_{0} = 0\\\\ y_{0} = 1\\\\ x_{b} = 0,10\\\\ h = 0,02\\\\ f(x,y) = x + y\\\\ hasil\\ analitik = 1,1103 Maka nilai n = (x_{b} - x_{0})/h = (0,10-0)/0,02 = 5 (banyaknya langkah) dan penerapan metode Runge-Kutta orde satu pada PDB tersebut menjadi : y_{i+1}= y_{i}+\\dfrac{1}{2}0,02(k1+k2) Langkah-langkah : x_{0} = 0 \\Rightarrow y_{0} = 1\\\\ x_{1} = 0,02 \\Rightarrow y_{1} 1 + \\dfrac{1}{2}0,02(0,0200+0,0208) = 1,0204\\\\ x_{2} = 0,04 \\Rightarrow y_{2} 1,0204 + \\dfrac{1}{2}0,02(0,0208+0,0216) = 1,0416\\\\ x_{3} = 0,06 \\Rightarrow y_{3} 1,0416 + \\dfrac{1}{2}0,02(0,0216+0,0224) = 1,0636\\\\ x_{4} = 0,08 \\Rightarrow y_{4} 1,0636 + \\dfrac{1}{2}0,02(0,0224+0,0233) = 1,0865\\\\ x_{5} = 0,10 \\Rightarrow y_{1} 1,0865 + \\dfrac{1}{2}0,02(0,0233+0,0241) = 1,1103\\\\ Jadi solusi numerik dengan menggunakan metode Runge-Kutta orde 2 di y(0,10) = 1,1081 dan nilai error yang dihasilkan ialah e = hasil analitik - solusi numerik = 1,1103 - 1,1103 = 0,0 Algoritma Metode Runge-Kutta Orde Dua Deklarasi fungsi PDB yang akan di selesaikan, Masukkan inputan yang dibutuhkan seperti x_{0},y_{0},xb , dan h , Hitung perulangan yang diperlukan dengan menggunakan rumus n = (x_{b} - x_{0})/h , Inisialisasi nilai x dan y awal sama dengan x_{o} dan y_{0} , Tentukan nilai analitiknya untuk menghitung nilai error Lakukan perulangan sebanyak n, Update nilai k_{1} dan k_{2} , nilai y dan nilai x serta nilai e kemudian cetak nilai nilai tersebut setiap melakukan peulangan. Source Code Metode Runge-Kutta Orde Dua def f ( x , y ): return x + y print ( \"Penyelesaian Sistem Persamaan Differensial Biasa Menggunakan Metode Runge-Kutta Orde2\" ) x0 = float ( input ( \"Masukkan Nilai X0 : \" )) y0 = float ( input ( \"Masukkan Nilai y0 : \" )) xb = float ( input ( \"Masukkan Nilai X yang dicari : \" )) h = float ( input ( \"Masukkan Nilai h : \" )) iterasi = ( xb - x0 ) / h n = int ( iterasi ) x = x0 y = y0 true = 1.1103 e = abs ( true - y ) print ( \"==================================================================================\" ) print ( \">>>>>>>>>>>>>>>>>>>>>>>>>>>>>- METODE RUNGE-KUTTA2 -<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\" ) print ( \"==================================================================================\" ) print ( '|i' , ' \\t |' , 'x(i)' , ' \\t\\t |' , 'y(i) \\t\\t |e \\t\\t |k1 \\t\\t |k2' ) print ( \"| %d \" % x0 , ' \\t |' , \" %f \" % x , ' \\t |' , \" %f \\t |\" % y , \" %f \" % e , \" \\t |0 \\t\\t |0\" ) for i in range ( n ): k1 = h * f ( x , y ) k2 = h * f ( x + h , y + k1 ) y = y + ( k1 + k2 ) / 2 x = x + h e = abs ( true - y ) print ( \"| %d \" % ( i + 1 ), ' \\t |' , \" %f \" % x , ' \\t |' , \" %f \\t |\" % y , \" %f \\t |\" % e , \" %f \\t |\" % k1 , \" %f \" % k2 ) print ( \"==================================================================================\" ) Dan hasil output dari program diatas sebagai berikut Penyelesaian Sistem Persamaan Differensial Biasa Menggunakan Metode Runge-Kutta Orde2 Masukkan Nilai X0 : 0 Masukkan Nilai y0 : 1 Masukkan Nilai X yang dicari : 0.1 Masukkan Nilai h : 0.02 ================================================================================== >>>>>>>>>>>>>>>>>>>>>>>>>>>>>- METODE RUNGE-KUTTA2 -<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< ================================================================================== |i | x(i) | y(i) |e |k1 |k2 |0 | 0.000000 | 1.000000 | 0.110300 |0 |0 |1 | 0.020000 | 1.020400 | 0.089900 | 0.020000 | 0.020800 |2 | 0.040000 | 1.041616 | 0.068684 | 0.020808 | 0.021624 |3 | 0.060000 | 1.063665 | 0.046635 | 0.021632 | 0.022465 |4 | 0.080000 | 1.086563 | 0.023737 | 0.022473 | 0.023323 |5 | 0.100000 | 1.110327 | 0.000027 | 0.023331 | 0.024198 ================================================================================== 3. Metode Runge-Kutta Orde Tiga \u00b6 Metode Runge-Kutta orde tiga metode yang terkenal dikarenakan tingkat ketelitian solusinya tinggi dibandingkan metode Runge-Kutta sebelumnya. Bentuk metode Runge-Kutta orde tiga berbentuk k_{1} = hf(x_{i},y_{i})\\\\ k_{2} = hf(x_{i}+\\dfrac{h}{2},y_{i}+\\dfrac{k_{1}}{2})\\\\ k_{3} = hf(x_{i}+h,y_{i}-k{1}+2k_{2})\\\\ y_{i+1} = y_{i}+\\dfrac{(k_{1}+k_{2}+k_{3})}{6} Contoh : Diketahui PDB \\dfrac{dy}{dt} = x + y dan y(0) = 1 gunakan metode Runge-Kutta orde 3 untuk menghitung y(0,10) dengan ukuran langkah h = 0.02 . Dan diketahui solusi PDB sejatinya = 1,1103 Jawab : Diketahui x_{0} = 0\\\\ y_{0} = 1\\\\ x_{b} = 0,10\\\\ h = 0,02\\\\ f(x,y) = x + y\\\\ hasil\\ analitik = 1,1103 Maka nilai n = (x_{b} - x_{0})/h = (0,10-0)/0,02 = 5 (banyaknya langkah) dan penerapan metode Runge-Kutta orde tiga pada PDB tersebut menjadi : y_{i+1} = y_{i}+\\dfrac{(k_{1}+k_{2}+k_{3})}{6} Langkah-langkah: x_{0} = 0 \\Rightarrow y_{0} = 1\\\\ x_{1} = 0,02 \\Rightarrow y_{1} = 1 + \\dfrac{(0,0200+0,0204+0,0208)}{6} = 1,0204\\\\ x_{2} = 0,04 \\Rightarrow y_{2} = 1,0204 +\\dfrac{(0,0208+0,0212+0,0216)}{6}=1,0416\\\\ x_{3} = 0,06 \\Rightarrow y_{3} = 1,0416 +\\dfrac{(0,0216+0,0220+0,0224)}{6}=1,0636\\\\ x_{4} = 0,08 \\Rightarrow y_{4}= 1,0636 +\\dfrac{(0,0224+0,0228+0,0233)}{6}=1,0865\\\\ x_{5} = 0,10 \\Rightarrow y_{5} = 1,0865 +\\dfrac{(0,0233+0,0237+0,0242)}{6}=1,1103 Jadi solusi numerik dengan menggunakan metode Runge-Kutta orde tiga di y(0,10) = 1,1103 dan nilai error yang dihasilkan ialah e = hasil analitik - solusi numerik = 1,1103 - 1,1103 = 0,0 . Algoritma Metode Runge-Kutta Orde Tiga Deklarasi fungsi PDB yang akan di selesaikan, Masukkan inputan yang dibutuhkan seperti x_{0},y_{0},xb , dan h , Hitung perulangan yang diperlukan dengan menggunakan rumus n = (x_{b} - x_{0})/h , Inisialisasi nilai x dan y awal sama dengan x_{o} dan y_{0} , Tentukan nilai analitiknya untuk menghitung nilai error Lakukan perulangan sebanyak n, Update nilai k_{1} hinga k_{3} , nilai y dan nilai x serta nilai e kemudian cetak nilai nilai tersebut setiap melakukan peulangan. Source Code Metode Runge Kutta Orde Tiga def f ( x , y ): return x + y print ( \"Penyelesaian Persamaan Differensial Biasa Menggunakan Metode Runge-Kutta Orde3\" ) x0 = float ( input ( \"Masukkan Nilai X0 : \" )) y0 = float ( input ( \"Masukkan Nilai y0 : \" )) xb = float ( input ( \"Masukkan Nilai X yang dicari : \" )) h = float ( input ( \"Masukkan Nilai h : \" )) iterasi = ( xb - x0 ) / h n = int ( iterasi ) x = x0 y = y0 true = 1.1103 e = abs ( true - y ) print ( \"==================================================================================================\" ) print ( \">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>- METODE RUNGE-KUTTA ORDE 3 -<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\" ) print ( \"==================================================================================================\" ) print ( '|i \\t |x(i) \\t\\t |y(i) \\t\\t |e \\t\\t |k1 \\t\\t |k2 \\t\\t |k3' ) print ( \"| %d \" % x0 , ' \\t | %f ' % x , ' \\t | %f |' % y , ' \\t | %f ' % e , ' \\t |0' , ' \\t\\t |0' , ' \\t\\t |0' ) for i in range ( n ): k1 = h * f ( x , y ) k2 = h * f ( x + h / 2 , y + k1 / 2 ) k3 = h * f ( x + h , y - k1 + 2 * k2 ) y = y + ( k1 + 4 * k2 + k3 ) / 6 x = x + h e = abs ( true - y ) print ( \"| %d \" % ( i + 1 ), ' \\t |' , \" %f \" % x , ' \\t |' , \" %f \\t |\" % y , \" %f \\t |\" % e , \" %f \\t |\" % k1 , \" %f \\t |\" % k2 , \" %f \" % k3 ) print ( \"==================================================================================================\" ) Dan hasil output program diatas sebagai berikut. Penyelesaian Persamaan Differensial Biasa Menggunakan Metode Runge-Kutta Orde3 Masukkan Nilai X0 : 0 Masukkan Nilai y0 : 1 Masukkan Nilai X yang dicari : 0.1 Masukkan Nilai h : 0.02 ================================================================================================== >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>- METODE RUNGE-KUTTA ORDE 3 -<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< ================================================================================================== |i |x(i) |y(i) |e |k1 |k2 |k3 |0 |0.000000 |1.000000| |0.110300 |0 |0 |0 |1 | 0.020000 | 1.020403 | 0.089897 | 0.020000 | 0.020400 | 0.020816 |2 | 0.040000 | 1.041622 | 0.068678 | 0.020808 | 0.021216 | 0.021641 |3 | 0.060000 | 1.063673 | 0.046627 | 0.021632 | 0.022049 | 0.022482 |4 | 0.080000 | 1.086574 | 0.023726 | 0.022473 | 0.022898 | 0.023340 |5 | 0.100000 | 1.110342 | 0.000042 | 0.023331 | 0.023765 | 0.024215 ================================================================================================== 4. Metode Runge-Kutta Orde Empat \u00b6 Metode Runge-Kutta orde empat merupakan penyelesaian persamaaan differensial biasa dengan tingkat ketelitian yang tinggi. Bentuk Runge-Kutta orde empat berbentuk k_{1} = hf(x_{i},y_{i})\\\\ k_{2} = hf(x_{i}+\\dfrac{h}{2},y_{i}+\\dfrac{k1}{2})\\\\ k_{3} = hf(x_{i}+\\dfrac{h}{2},y_{i}+\\dfrac {k_{2}}{2})\\\\ k_{4} = hf(x_{i}+h,y_{i}+k_{3})\\\\ y_{i+1} = y_{i}+\\dfrac{k_{1}+2k_{2}+2k_{3}+k_{4}}{6} Contoh : Diketahui PDB \\dfrac{dy}{dt} = x + y dan y(0) = 1 gunakan metode Runge-Kutta orde 4 untuk menghitung y(0,10) dengan ukuran langkah h = 0.02 . Dan diketahui solusi PDB sejatinya = 1,1103 Jawab : Diketahui x_{0} = 0\\\\ y_{0} = 1\\\\ x_{b} = 0,10\\\\ h = 0,02\\\\ f(x,y) = x + y\\\\ hasil\\ analitik = 1,1103 Maka nilai n = (x_{b} - x_{0})/h = (0,10-0)/0,02 = 5 (banyaknya langkah) dan penerapan metode Runge-Kutta orde tiga pada PDB tersebut menjadi : y_{i+1} = y_{i}+\\dfrac{(k_{1}+2k_{2}+2k_{3}+k_{4})}{6} Langkah-langkah: x_{0} = 0 \\Rightarrow y_{0} = 1\\\\ x_{1} = 0,02 \\Rightarrow y_{1} = 1 +\\dfrac{0,0200+2(0,0204)+2(0,0204)+0,0208}{6}= 1,0204\\\\ x_{2} = 0,04 \\Rightarrow y_{2} = 1,0204 +\\dfrac{0,0208+2(0,0212)+2(0,0212)+0,0216}{6}= 1,0416\\\\ x_{3} = 0,06 \\Rightarrow y_{3} = 1,0416 +\\dfrac{0,0216+2(0,0220)+2(0,0220)+0,0224}{6}= 1,0636\\\\ x_{4} = 0,08 \\Rightarrow y_{4} = 1,0636 +\\dfrac{0,0224+2(0,0228)+2(0,0229)+0,0233}{6}= 1,0865\\\\ x_{5} = 0,10 \\Rightarrow y_{2} = 1,0204 +\\dfrac{0,0233+2(0,0237)+2(0,0237)+0,0242}{6}= 1,1103 Jadi solusi numerik dengan menggunakan metode Runge-Kutta orde empat di y(0,10) = 1,1103 dan nilai error yang dihasilkan ialah e = hasil analitik - solusi numerik = 1,1103 - 1,1103 = 0,0 . Algoritma Metode Runge-Kutta Orde Empat Deklarasi fungsi PDB yang akan di selesaikan, Masukkan inputan yang dibutuhkan seperti x_{0},y_{0},xb , dan h , Hitung perulangan yang diperlukan dengan menggunakan rumus n = (x_{b} - x_{0})/h , Inisialisasi nilai x dan y awal sama dengan x_{o} dan y_{0} , Tentukan nilai analitiknya untuk menghitung nilai error Lakukan perulangan sebanyak n, Update nilai k_{1} hinga k_{4} , nilai y dan nilai x serta nilai e kemudian cetak nilai nilai tersebut setiap melakukan peulangan. Source Code Metode Runge Kutta Orde Empat def f ( x , y ): return x + y print ( \"Penyelesaian Sistem Persamaan Differensial Biasa Menggunakan Metode Runge-Kutta Orde4\" ) x0 = float ( input ( \"Masukkan Nilai X0 : \" )) y0 = float ( input ( \"Masukkan Nilai y0 : \" )) xb = float ( input ( \"Masukkan Nilai X yang dicari : \" )) h = float ( input ( \"Masukkan Nilai h : \" )) iterasi = ( xb - x0 ) / h n = int ( iterasi ) x = x0 y = y0 true = 1.1103 e = abs ( true - y ) print ( \"==================================================================================================================\" ) print ( \">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>- METODE RUNGE-KUTTA ORDE 4 -<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\" ) print ( \"==================================================================================================================\" ) print ( '|i \\t |x(i) \\t\\t |y(i) \\t\\t |e \\t\\t |k1 \\t\\t |k2 \\t\\t |k3 \\t\\t |k4' ) print ( \"| %d \" % x0 , ' \\t | %f ' % x , ' \\t | %f |' % y , ' \\t | %f ' % e , ' \\t |0' , ' \\t\\t |0' , ' \\t\\t |0' , ' \\t\\t |0' ) for i in range ( n ): k1 = h * f ( x , y ) k2 = h * f ( x + h / 2 , y + k1 / 2 ) k3 = h * f ( x + h / 2 , y + k2 / 2 ) k4 = h * f ( x + h , y + k3 ) y = y + ( k1 + 2 * k2 + 2 * k3 + k4 ) / 6 x = x + h e = abs ( true - y ) print ( \"| %d \" % ( i + 1 ), ' \\t |' , \" %f \" % x , ' \\t |' , \" %f \\t |\" % y , \" %f \\t |\" % e , \" %f \\t |\" % k1 , \" %f \\t |\" % k2 , \" %f \\t |\" % k3 , \" %f \" % k4 ) print ( \"==================================================================================================================\" ) Dan output dari source code diatas ialah Penyelesaian Sistem Persamaan Differensial Biasa Menggunakan Metode Runge-Kutta Orde4 Masukkan Nilai X0 : 0 Masukkan Nilai y0 : 1 Masukkan Nilai X yang dicari : 0.1 Masukkan Nilai h : 0.02 ================================================================================================================== >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>- METODE RUNGE-KUTTA ORDE 3 -<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< ================================================================================================================== |i |x(i) |y(i) |e |k1 |k2 |k3 |k4 |0 |0.000000 |1.000000| |0.110300 |0 |0 |0 |0 |1 | 0.020000 | 1.020403 | 0.089897 | 0.020000 | 0.020400 | 0.020404 | 0.020808 |2 | 0.040000 | 1.041622 | 0.068678 | 0.020808 | 0.021216 | 0.021220 | 0.021632 |3 | 0.060000 | 1.063673 | 0.046627 | 0.021632 | 0.022049 | 0.022053 | 0.022473 |4 | 0.080000 | 1.086574 | 0.023726 | 0.022473 | 0.022898 | 0.022902 | 0.023332 |5 | 0.100000 | 1.110342 | 0.000042 | 0.023331 | 0.023765 | 0.023769 | 0.024207 ================================================================================================================== Referensi \u00b6 https://app.schoology.com/course/4711478201/materials/gp/4905811750 \u21a9 http://iffatul.staff.gunadarma.ac.id/Downloads/files/46564/BAb-+08+Solusi+Persamaan+Diferensial+Bi \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9","title":"PERSAMAAN DIFFERENSIAL BIASA (PDB)"},{"location":"index/Differensial/#persamaan_differensial_biasa_pdb","text":"","title":"PERSAMAAN DIFFERENSIAL BIASA (PDB)"},{"location":"index/Differensial/#a_definisi_persamaan_differensial_biasa_pdb","text":"\u200b Persamaan Differensial Biasa (PDB) merupakan persamaan differensial yang terdiri dari beberapa turunan biasa dari fungsi yang tidak diketahui dari variabel bebas tunggal. 1 Dan variabel bebas tersebut biasanya disimbolkan dengan x. Berikut merupakan contoh contoh persamaan differensial biasa. 2 Contoh : 1.\\ \\dfrac{dy}{dx} = x +y\\\\ 2.\\ y^{'} = x^{2}+y^{2}\\\\ 3.\\ \\dfrac{2dy}{dx} +x^{2}y-y = 0\\\\ 4.\\ y^{''} + y^{'}cos\\ x -3y = sin\\ 2x\\\\ 5.\\ 2y^{'''}-23y^{'} = 1 -y^{''} \u200b Variabel bebas dari contoh 1 hingga 5 adalah x dan variabel terikatnya ialah y yang merupakan fungsi dari x atau bisa ditulis y = f(x) . Berdasarkan turunnan tertinggi yang ada di persamaannya, PDB dikelompokkan lagi berdasarkan ordenya yaitu : 2 PDB orde 1 yaitu turunan tertingginya ialah turunan pertama, contohnya pada contoh nomor 1,2 dan 3 di atas. PDB orde 2 yaitu turunan tertingginya ialah turunan kedua, contohnya pada contoh nomor 4 di atas. PDB orde 3 yaitu turunan tertingginya ialah turunan ketiga, contohnya pada contoh nomor 5 diatas. Dan untuk PDB selanjutnya yang lebih tinggi dinamakan PDB orde lanjut. 2 Metode numerik dapat digunakan untuk menyelesaikan persamaan differensial biasa karena sebagian besar persamaan differensial tidak dapat diselesaikan secara analitik. Berikut ini pembahasan tentang metode numerik untuk menyelesaikan persamaan differensial biasa orde satu.","title":"A. Definisi Persamaan Differensial Biasa (PDB)"},{"location":"index/Differensial/#b_metode_persamaan_differensial_biasa_pdb","text":"\u200b Bentuk baku PDB orde satu dengan nilai awal dapat ditulis : y^{'} = f(x,y)\\ \\ \\ \\ \\ \\ atau\\ \\ \\ \\ \\ \\ \\dfrac{dy}{dx} = f(x,y) dengan nilai awal y(x0) = y PDB orde satu yang tidak mengikuti bentuk tersebut harus ditulis ulang seperti bentuk baku diatas agar dapat diselesaikan secara numerik. Penyelesaian PDB secara numerik berarti menghitung nilai fungsi di x_{i+1} = h , dengan h adalah ukuran langkah setiap lelaran. Pada metode analiti nilai awal berfungsi untuk memperoleh solusi yang unik, sedangkan pada metode numerik nilai awal berfungsi untuk memulai lelaran. Terdapat beberapa metode numerik yang digunakan untuk menyelesaikan PDB , mulai dari mrtode yang paling dasar hingga metode yang lebih teliti, diantanya ialah sebagai berikut. 2","title":"B. Metode Persamaan Differensial Biasa (PDB)"},{"location":"index/Differensial/#1_metode_euler","text":"\u200b Metode Euler adalah metode yang digunakan untuk menyelesaikan PDB yang dihasilkan dari turunan deret Taylor. Metode euler juga disebut metode orde-pertama dikarenakan hanya mengambil sampai suku pertama saja dari deret Taylor. Selain menggunakan bantuan deret Taylor, metode Euler juga dapat diturunkan dengan menggunakan metode aturan segiempat untuk mengintegrasikan f(x,y) pada persamaan diferensial. Tafsiran geometri penurunan metode Euler digambarkan sebagai berikut. 2 Sehingga bentuk metode Euler dari penurunan tersebut sebagai berikut. y(x_{i+1}) - y(x_{i}) = hf(x_{i},y(x_{i}))\\\\ atau\\\\ y(x_{i+1}) = y(x_{i}) + hf(x_{i},y(x_{i})) Contoh : Diketahui PDB \\dfrac{dy}{dt} = x + y dan y(0) = 1 gunakan metode Euler untuk menghitung y(0,10) dengan ukuran langkah h = 0.02 . Dan diketahui solusi PDB sejatinya = 1,1103 Jawab : Diketahui x_{0} = 0\\\\ y_{0} = 1\\\\ x_{b} = 0,10\\\\ h = 0,02\\\\ f(x,y) = x + y\\\\ hasil\\ analitik = 1,1103 Sehingga nilai n = (x_{b} - x_{0})/h = (0,10-0)/0,02 = 5 (banyaknya langkah) dan penerapan metode Euler pada PDB tersebut menjadi y_{i+1} = y_{i} + 0,02(x_{i}+y{i}) langkah-langkah: x_{0} = 0 \\Rightarrow y_{0} = 1\\\\ x_{1} = 0,02 \\Rightarrow y_{1} = y_{0}+0,02(x_{0}+y_{0}) = 1 + (0,02)(0+1) = 1,0200\\\\ x_{2} = 0,04 \\Rightarrow y_{2} = y_{1}+0,02(x_{1}+y_{1}) = 1,0200 + (0,02)(0,02+1,0200) = 1,0408\\\\ x_{3} = 0,06 \\Rightarrow y_{3} = y_{2}+0,02(x_{2}+y_{2}) = 1,0408 + (0,02)(0,04+1,0408) = 1,0624\\\\ x_{4} = 0,08 \\Rightarrow y_{4} = y_{3}+0,02(x_{3}+y_{3}) = 1,0624 + (0,02)(0,06+1,0624) = 1,0848\\\\ x_{5} = 0,10 \\Rightarrow y_{5} = y_{4}+0,02(x_{4}+y_{4}) = 1,0848 + (0,02)(0,08+1,0848) = 1,1081 Jadi solusi numerik dengan menggunakan metode Euler di y(0,10) = 1,1081 dan nilai error yang dihasilkan ialah e = hasil analitik - solusi numerik = 1,1103 - 1,1081 = 0,0022 Algoritma Metode Euler Deklarasi fungsi PDB yang akan di selesaikan, Masukkan inputan yang dibutuhkan seperti x_{0},y_{0},xb , dan h , Hitung perulangan yang diperlukan dengan menggunakan rumus n = (x_{b} - x_{0})/h , Inisialisasi nilai x dan y awal sama dengan x_{o} dan y_{0} , Tentukan nilai analitiknya untuk menghitung nilai error Lakukan perulangan sebanyak n, Setiap melakukan perulangan update nilai y dan x dengan menggunakan persamaan metode Euler, dan menghitung nilai erornya kemudian cetak hasilnya. Sorce Code Metode Euler def f ( x , y ): return x + y print ( \"Penyelesaian Persamaan Differensial Biasa Menggunakan Metode Euler\" ) x0 = float ( input ( \"Masukkan Nilai X0 : \" )) y0 = float ( input ( \"Masukkan Nilai y0 : \" )) xb = float ( input ( \"Masukkan Nilai X yang dicari : \" )) h = float ( input ( \"Masukkan Nilai h : \" )) n = ( xb - x0 ) / h iterasi = int ( n ) x = x0 y = y0 true = 1.1103 e = abs ( true - y ) print ( \"==================================================\" ) print ( \">>>>>>>>>>>>>>>>>>- METODE EULER -<<<<<<<<<<<<<<<<\" ) print ( \"==================================================\" ) print ( '|i' , ' \\t |' , 'x(i)' , ' \\t\\t |' , 'y(i) \\t\\t |e' ) print ( \"| %d \" % x0 , ' \\t |' , \" %f \" % x , ' \\t |' , \" %f \\t |\" % y , \" %f \" % e ) for i in range ( iterasi ): y = y + h * f ( x , y ) x = x + h e = abs ( true - y ) print ( \"| %d \" % ( i + 1 ), ' \\t |' , \" %f \" % x , ' \\t |' , \" %f \\t |\" % y , \" %f \" % e ) print ( \"==================================================\" ) Output hasil program sebagai berikut Penyelesaian Persamaan Differensial Biasa Menggunakan Metode Euler Masukkan Nilai X0 : 0 Masukkan Nilai y0 : 1 Masukkan Nilai X yang dicari : 0.1 Masukkan Nilai h : 0.02 ================================================== >>>>>>>>>>>>>>>>>>- METODE EULER -<<<<<<<<<<<<<<<< ================================================== |i | x(i) | y(i) |e |0 | 0.000000 | 1.000000 | 0.110300 |1 | 0.020000 | 1.020000 | 0.090300 |2 | 0.040000 | 1.040800 | 0.069500 |3 | 0.060000 | 1.062416 | 0.047884 |4 | 0.080000 | 1.084864 | 0.025436 |5 | 0.100000 | 1.108162 | 0.002138 ==================================================","title":"1. Metode Euler"},{"location":"index/Differensial/#2_metode_heun","text":"\u200b Metode Heun merupakan metode perbaikan dari metode Euler yang memiliki nilai error yang tinggi. Pada metode Heun solusi dari metode Euler dijadikan sebagai solusi perkiraan awal( predictor ), selanjutnya solusi perkiraan awal tersebut diperbaiki dengan metode Heun( corrector ). 2 Sehingga persamaan metode Heun dituliskan sebagai berikut. Predictor= y^{0}_{i+1} = y_{i} + hf(x_{i},y_{i})\\\\ Corrector = y_{i+1} = y_{i}+\\dfrac{h}{2}[f(x_{i},y{i})+f(x_i+1),y^{0}_{i+1}] Sehingga tafsiran geometri metode Heun digambarkan sebagai berikut. Contoh : Diketahui PDB \\dfrac{dy}{dt} = x + y dan y(0) = 1 gunakan metode Heun untuk menghitung y(0,10) dengan ukuran langkah h = 0.02 . Dan diketahui solusi PDB sejatinya = 1,1103 Jawab : Diketahui x_{0} = 0\\\\ y_{0} = 1\\\\ x_{b} = 0,10\\\\ h = 0,02\\\\ f(x,y) = x + y\\\\ hasil\\ analitik = 1,1103 Maka nilai n = (x_{b} - x_{0})/h = (0,10-0)/0,02 = 5 (banyaknya langkah) dan penerapan metode Heun pada PDB tersebut menjadi : y_{i+1} = y_{i} + \\dfrac{0,02}{2}[(x_{i}+y{i})+((x_{i}+0,02)+y_{eu})] Langkah-langkah : x_{0} = 0\\Rightarrow y^{0} = 1\\\\ x_{1} = 0,02\\Rightarrow y_{1}= 1 +(\\dfrac{0,02}{2})(0+1+0,02+1,0200) = 1,0204\\\\ x_{2} = 0,04\\Rightarrow y_{2} = 1,0204 +(\\dfrac{0,02}{2})(0,02+1,0204+0,04+1,0412)=1,0416\\\\ x_{3} = 0,04\\Rightarrow y_{3} = 1,0416 +(\\dfrac{0,02}{2})(0,04+1,0204+0,06+1,0632)=1,0636\\\\ x_{4} = 0,04\\Rightarrow y_{4} = 1,0636 +(\\dfrac{0,02}{2})(0,06+1,0204+0,08+1,0861)=1,0865\\\\ x_{5} = 0,04\\Rightarrow y_{5} = 1,0865 +(\\dfrac{0,02}{2})(0,08+1,0204+0,10+1,1098)=1,1103\\\\ Jadi solusi numerik dengan menggunakan metode Heun di y(0,10) = 1,1103 dan nilai error yang dihasilkan ialah e = hasil analitik - solusi numerik = 1,1103 - 1,1103 = 0,0 . Algoritma Metode Heun Deklarasi fungsi PDB yang akan di selesaikan, Masukkan inputan yang dibutuhkan seperti x_{0},y_{0},xb , dan h , Hitung perulangan yang diperlukan dengan menggunakan rumus n = (x_{b} - x_{0})/h , Inisialisasi nilai x dan y awal sama dengan x_{o} dan y_{0} , Tentukan nilai analitiknya untuk menghitung nilai error Lakukan perulangan sebanyak n, Setiap melakukan perulangan update nilai y predictor dan y corrector serta x dengan menggunakan persamaan metode Heun, dan menghitung nilai erornya kemudian cetak hasilnya. Source Code Metode Heun def f ( x , y ): return x + y print ( \"Penyelesaian Persamaan Differensial Biasa Menggunakan Metode Heun\" ) x0 = float ( input ( \"Masukkan Nilai X0 : \" )) y0 = float ( input ( \"Masukkan Nilai y0 : \" )) xb = float ( input ( \"Masukkan Nilai X yang dicari : \" )) h = float ( input ( \"Masukkan Nilai h : \" )) iterasi = ( xb - x0 ) / h n = int ( iterasi ) x = x0 y = y0 true = 1.1103 e = abs ( true - y ) print ( \"==================================================\" ) print ( \">>>>>>>>>>>>>>>>>>- METODE HEUN -<<<<<<<<<<<<<<<<<\" ) print ( \"==================================================\" ) print ( '|i' , ' \\t |' , 'x(i)' , ' \\t\\t |' , 'y(i) \\t\\t |e' ) print ( \"| %d \" % x0 , ' \\t |' , \" %f \" % x , ' \\t |' , \" %f \\t |\" % y , \" %f \" % e ) for i in range ( n ): ypre = y + h * f ( x , y ) y = y + h / 2 * ( f ( x , y ) + f ( x + h , ypre )) x = x + h e = abs ( true - y ) print ( \"| %d \" % ( i + 1 ), ' \\t |' , \" %f \" % x , ' \\t |' , \" %f \\t |\" % y , \" %f \" % e ) print ( \"==================================================\" ) Ouput yang dihasilkan dari program di atas ialah sebagai berikut. Penyelesaian Persamaan Differensial Biasa Menggunakan Metode Heun Masukkan Nilai X0 : 0 Masukkan Nilai y0 : 1 Masukkan Nilai X yang dicari : 0.1 Masukkan Nilai h : 0.02 ================================================== >>>>>>>>>>>>>>>>>>- METODE HEUN -<<<<<<<<<<<<<<<<< ================================================== |i | x(i) | y(i) |e |0 | 0.000000 | 1.000000 | 0.110300 |1 | 0.020000 | 1.020400 | 0.089900 |2 | 0.040000 | 1.041616 | 0.068684 |3 | 0.060000 | 1.063665 | 0.046635 |4 | 0.080000 | 1.086563 | 0.023737 |5 | 0.100000 | 1.110327 | 0.000027 ==================================================","title":"2. Metode Heun"},{"location":"index/Differensial/#3_metode_runge-kutta","text":"\u200b Metode Runge-Kutta merupakan metode untuk menyelesaikan persamaan differensial biasa dengan ketelitian yang lebih tinggi, dan menghindarkan mencari turunan yang lebih tinggi dengan jalan mengevaluasi fungsi f(x,y) pada titik terpilih dalam setiap langkah. Metode ini merupakan metode yang paling poopuler dikarenakan banyak dipakai dalam praktek. 2 \u200b Bentuk umum metode runge-Kutta orde-n ialah: y_{i+1} = y_{i}+a_{1}k_{1}+a_{2}k_{2}+\\ldots+a_{n}k_{n} dengan a_{1},a_{2},...,a_{n} adalah tetapan dan k_{1} = hf(x_{i},y_{i})\\\\ k_{2} = hf(x_{i}+p_{1}h,y_{i}+q_{11}k_{1})\\\\ k_{3} = hf(x_{i}+p_{2}h,y_{i}+q_{21}k_{1}+q_{22}k_{2}\\\\ \\cdots\\\\ k_{n} = hf(x_{i}+p_{n-1}h,y_{i}+q_{n-1,1}k_{1}+q_{n-1,2}k_{2}+\\cdots+q_{n-1,n-1} k_{n-1} Dimana nilai a_{i}, p_{i}, q_{ij} dipilih sedemikian rupa sehingga meminimumkan galat perlangkah. Dan berikut ini metode Runge-Kutta berdasarkan ordenya","title":"3. Metode Runge-Kutta"},{"location":"index/Differensial/#1_metode_runge-kutta_orde_satu","text":"Metode Runge-Kutta orde satu berbentuk k_{1} = hf(x_{i},y_{i})\\\\ y_{i+1} = y_{i}+k_{1}\\\\ atau\\\\ y_{i+1} = y_{i} +hf(x_i,y_{i}) Salah satu bentuk contoh dari metode Runge-Kutta orde 1 ialah metode Euler yang dapat dilihat dari bentuk persamaannya. Contoh : Diketahui PDB \\dfrac{dy}{dt} = x + y dan y(0) = 1 gunakan metode Runge-Kutta orde 1 untuk menghitung y(0,10) dengan ukuran langkah h = 0.02 . Dan diketahui solusi PDB sejatinya = 1,1103 Jawab : Diketahui x_{0} = 0\\\\ y_{0} = 1\\\\ x_{b} = 0,10\\\\ h = 0,02\\\\ f(x,y) = x + y\\\\ hasil\\ analitik = 1,1103 Maka nilai n = (x_{b} - x_{0})/h = (0,10-0)/0,02 = 5 (banyaknya langkah) dan penerapan metode Runge-Kutta orde satu pada PDB tersebut menjadi : y_{i+1} = y_{i} +k_{i} Langkah-langkah : x_{0} = 0 \\Rightarrow y_{0} = 1\\\\ x_{1} = 0,02 \\Rightarrow y_{1} = 1 + 0,0200 = 1,0200\\\\ x_{2} = 0,04 \\Rightarrow y_{2} = 1,0200+0,0208 = 1,0404\\\\ x_{3} = 0,06 \\Rightarrow y_{3} = 1,0404+0,0216 = 1,0624\\\\ x_{4} = 0,08 \\Rightarrow y_{4} = 1,0624+0,0254 = 1,0848\\\\ x_{5} = 0,10 \\Rightarrow y_{5} = 1,0848+0,0232 = 1,1081 Jadi solusi numerik dengan menggunakan metode Runge-Kutta orde 1 di y(0,10) = 1,1081 dan nilai error yang dihasilkan ialah e = hasil analitik - solusi numerik = 1,1103 - 1,1081 = 0,0022 Algoritma Metode Runge-Kutta Orde Satu Deklarasi fungsi PDB yang akan di selesaikan, Masukkan inputan yang dibutuhkan seperti x_{0},y_{0},xb , dan h , Hitung perulangan yang diperlukan dengan menggunakan rumus n = (x_{b} - x_{0})/h , Inisialisasi nilai x dan y awal sama dengan x_{o} dan y_{0} , Tentukan nilai analitiknya untuk menghitung nilai error Lakukan perulangan sebanyak n, Update nilai k_{1} , nilai y dan nilai x serta nilai e kemudian cetak nilai nilai tersebut setiap melakukan peulangan. Source Code Metode Runge-Kutta Orde Satu def f ( x , y ): return x + y print ( \"Penyelesaian Sistem Persamaan Differensial Biasa Menggunakan Metode Runge-Kutta Orde1\" ) x0 = float ( input ( \"Masukkan Nilai X0 : \" )) y0 = float ( input ( \"Masukkan Nilai y0 : \" )) xb = float ( input ( \"Masukkan Nilai X yang dicari : \" )) h = float ( input ( \"Masukkan Nilai h : \" )) iterasi = ( xb - x0 ) / h n = int ( iterasi ) x = x0 y = y0 true = 1.1103 e = abs ( true - y ) print ( \"==================================================================\" ) print ( \">>>>>>>>>>>>>>>>>>>>>>- METODE RUNGE-KUTTA1 -<<<<<<<<<<<<<<<<<<<<<\" ) print ( \"==================================================================\" ) print ( '|i' , ' \\t |' , 'x(i)' , ' \\t\\t |' , 'y(i) \\t\\t |e \\t\\t |k1' ) print ( \"| %d \" % x0 , ' \\t |' , \" %f \" % x , ' \\t |' , \" %f \\t |\" % y , \" %f \" % e , \" \\t |0\" ) for i in range ( n ): k1 = h * f ( x , y ) y = y + k1 x = x + h e = abs ( true - y ) print ( \"| %d \" % ( i + 1 ), ' \\t |' , \" %f \" % x , ' \\t |' , \" %f \\t |\" % y , \" %f \\t |\" % e , \" %f \" % k1 ) print ( \"==================================================================\" ) Dan hasil output program diatas sebagai berikut Penyelesaian Sistem Persamaan Differensial Biasa Menggunakan Metode Runge-Kutta Orde1 Masukkan Nilai X0 : 0 Masukkan Nilai y0 : 1 Masukkan Nilai X yang dicari : 0.1 Masukkan Nilai h : 0.02 ================================================================== >>>>>>>>>>>>>>>>>>>>>>- METODE RUNGE-KUTTA1 -<<<<<<<<<<<<<<<<<<<<< ================================================================== |i | x(i) | y(i) |e |k1 |0 | 0.000000 | 1.000000 | 0.110300 |0 |1 | 0.020000 | 1.020000 | 0.090300 | 0.020000 |2 | 0.040000 | 1.040800 | 0.069500 | 0.020800 |3 | 0.060000 | 1.062416 | 0.047884 | 0.021616 |4 | 0.080000 | 1.084864 | 0.025436 | 0.022448 |5 | 0.100000 | 1.108162 | 0.002138 | 0.023297 ==================================================================","title":"1. Metode Runge-Kutta Orde Satu"},{"location":"index/Differensial/#2_metode_runge-kutta_orde_dua","text":"Metode Runge-Kutta orde dua berbentuk k_{1} = hf(x_{i},y_{i})\\\\ k_{2} = hf(x_{i}+h,y_{i}+k_{1})\\\\ y_{i+1}= y_{i}+\\dfrac{1}{2}h(k1+k2) Salah satu bentuk contoh dari metode Runge-Kutta orde 2 ialah metode Heun yang dapat dilihat dari bentuk persamaannya. Contoh : Diketahui PDB \\dfrac{dy}{dt} = x + y dan y(0) = 1 gunakan metode Runge-Kutta orde 2 untuk menghitung y(0,10) dengan ukuran langkah h = 0.02 . Dan diketahui solusi PDB sejatinya = 1,1103 Jawab : Diketahui x_{0} = 0\\\\ y_{0} = 1\\\\ x_{b} = 0,10\\\\ h = 0,02\\\\ f(x,y) = x + y\\\\ hasil\\ analitik = 1,1103 Maka nilai n = (x_{b} - x_{0})/h = (0,10-0)/0,02 = 5 (banyaknya langkah) dan penerapan metode Runge-Kutta orde satu pada PDB tersebut menjadi : y_{i+1}= y_{i}+\\dfrac{1}{2}0,02(k1+k2) Langkah-langkah : x_{0} = 0 \\Rightarrow y_{0} = 1\\\\ x_{1} = 0,02 \\Rightarrow y_{1} 1 + \\dfrac{1}{2}0,02(0,0200+0,0208) = 1,0204\\\\ x_{2} = 0,04 \\Rightarrow y_{2} 1,0204 + \\dfrac{1}{2}0,02(0,0208+0,0216) = 1,0416\\\\ x_{3} = 0,06 \\Rightarrow y_{3} 1,0416 + \\dfrac{1}{2}0,02(0,0216+0,0224) = 1,0636\\\\ x_{4} = 0,08 \\Rightarrow y_{4} 1,0636 + \\dfrac{1}{2}0,02(0,0224+0,0233) = 1,0865\\\\ x_{5} = 0,10 \\Rightarrow y_{1} 1,0865 + \\dfrac{1}{2}0,02(0,0233+0,0241) = 1,1103\\\\ Jadi solusi numerik dengan menggunakan metode Runge-Kutta orde 2 di y(0,10) = 1,1081 dan nilai error yang dihasilkan ialah e = hasil analitik - solusi numerik = 1,1103 - 1,1103 = 0,0 Algoritma Metode Runge-Kutta Orde Dua Deklarasi fungsi PDB yang akan di selesaikan, Masukkan inputan yang dibutuhkan seperti x_{0},y_{0},xb , dan h , Hitung perulangan yang diperlukan dengan menggunakan rumus n = (x_{b} - x_{0})/h , Inisialisasi nilai x dan y awal sama dengan x_{o} dan y_{0} , Tentukan nilai analitiknya untuk menghitung nilai error Lakukan perulangan sebanyak n, Update nilai k_{1} dan k_{2} , nilai y dan nilai x serta nilai e kemudian cetak nilai nilai tersebut setiap melakukan peulangan. Source Code Metode Runge-Kutta Orde Dua def f ( x , y ): return x + y print ( \"Penyelesaian Sistem Persamaan Differensial Biasa Menggunakan Metode Runge-Kutta Orde2\" ) x0 = float ( input ( \"Masukkan Nilai X0 : \" )) y0 = float ( input ( \"Masukkan Nilai y0 : \" )) xb = float ( input ( \"Masukkan Nilai X yang dicari : \" )) h = float ( input ( \"Masukkan Nilai h : \" )) iterasi = ( xb - x0 ) / h n = int ( iterasi ) x = x0 y = y0 true = 1.1103 e = abs ( true - y ) print ( \"==================================================================================\" ) print ( \">>>>>>>>>>>>>>>>>>>>>>>>>>>>>- METODE RUNGE-KUTTA2 -<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\" ) print ( \"==================================================================================\" ) print ( '|i' , ' \\t |' , 'x(i)' , ' \\t\\t |' , 'y(i) \\t\\t |e \\t\\t |k1 \\t\\t |k2' ) print ( \"| %d \" % x0 , ' \\t |' , \" %f \" % x , ' \\t |' , \" %f \\t |\" % y , \" %f \" % e , \" \\t |0 \\t\\t |0\" ) for i in range ( n ): k1 = h * f ( x , y ) k2 = h * f ( x + h , y + k1 ) y = y + ( k1 + k2 ) / 2 x = x + h e = abs ( true - y ) print ( \"| %d \" % ( i + 1 ), ' \\t |' , \" %f \" % x , ' \\t |' , \" %f \\t |\" % y , \" %f \\t |\" % e , \" %f \\t |\" % k1 , \" %f \" % k2 ) print ( \"==================================================================================\" ) Dan hasil output dari program diatas sebagai berikut Penyelesaian Sistem Persamaan Differensial Biasa Menggunakan Metode Runge-Kutta Orde2 Masukkan Nilai X0 : 0 Masukkan Nilai y0 : 1 Masukkan Nilai X yang dicari : 0.1 Masukkan Nilai h : 0.02 ================================================================================== >>>>>>>>>>>>>>>>>>>>>>>>>>>>>- METODE RUNGE-KUTTA2 -<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< ================================================================================== |i | x(i) | y(i) |e |k1 |k2 |0 | 0.000000 | 1.000000 | 0.110300 |0 |0 |1 | 0.020000 | 1.020400 | 0.089900 | 0.020000 | 0.020800 |2 | 0.040000 | 1.041616 | 0.068684 | 0.020808 | 0.021624 |3 | 0.060000 | 1.063665 | 0.046635 | 0.021632 | 0.022465 |4 | 0.080000 | 1.086563 | 0.023737 | 0.022473 | 0.023323 |5 | 0.100000 | 1.110327 | 0.000027 | 0.023331 | 0.024198 ==================================================================================","title":"2. Metode Runge-Kutta Orde Dua"},{"location":"index/Differensial/#3_metode_runge-kutta_orde_tiga","text":"Metode Runge-Kutta orde tiga metode yang terkenal dikarenakan tingkat ketelitian solusinya tinggi dibandingkan metode Runge-Kutta sebelumnya. Bentuk metode Runge-Kutta orde tiga berbentuk k_{1} = hf(x_{i},y_{i})\\\\ k_{2} = hf(x_{i}+\\dfrac{h}{2},y_{i}+\\dfrac{k_{1}}{2})\\\\ k_{3} = hf(x_{i}+h,y_{i}-k{1}+2k_{2})\\\\ y_{i+1} = y_{i}+\\dfrac{(k_{1}+k_{2}+k_{3})}{6} Contoh : Diketahui PDB \\dfrac{dy}{dt} = x + y dan y(0) = 1 gunakan metode Runge-Kutta orde 3 untuk menghitung y(0,10) dengan ukuran langkah h = 0.02 . Dan diketahui solusi PDB sejatinya = 1,1103 Jawab : Diketahui x_{0} = 0\\\\ y_{0} = 1\\\\ x_{b} = 0,10\\\\ h = 0,02\\\\ f(x,y) = x + y\\\\ hasil\\ analitik = 1,1103 Maka nilai n = (x_{b} - x_{0})/h = (0,10-0)/0,02 = 5 (banyaknya langkah) dan penerapan metode Runge-Kutta orde tiga pada PDB tersebut menjadi : y_{i+1} = y_{i}+\\dfrac{(k_{1}+k_{2}+k_{3})}{6} Langkah-langkah: x_{0} = 0 \\Rightarrow y_{0} = 1\\\\ x_{1} = 0,02 \\Rightarrow y_{1} = 1 + \\dfrac{(0,0200+0,0204+0,0208)}{6} = 1,0204\\\\ x_{2} = 0,04 \\Rightarrow y_{2} = 1,0204 +\\dfrac{(0,0208+0,0212+0,0216)}{6}=1,0416\\\\ x_{3} = 0,06 \\Rightarrow y_{3} = 1,0416 +\\dfrac{(0,0216+0,0220+0,0224)}{6}=1,0636\\\\ x_{4} = 0,08 \\Rightarrow y_{4}= 1,0636 +\\dfrac{(0,0224+0,0228+0,0233)}{6}=1,0865\\\\ x_{5} = 0,10 \\Rightarrow y_{5} = 1,0865 +\\dfrac{(0,0233+0,0237+0,0242)}{6}=1,1103 Jadi solusi numerik dengan menggunakan metode Runge-Kutta orde tiga di y(0,10) = 1,1103 dan nilai error yang dihasilkan ialah e = hasil analitik - solusi numerik = 1,1103 - 1,1103 = 0,0 . Algoritma Metode Runge-Kutta Orde Tiga Deklarasi fungsi PDB yang akan di selesaikan, Masukkan inputan yang dibutuhkan seperti x_{0},y_{0},xb , dan h , Hitung perulangan yang diperlukan dengan menggunakan rumus n = (x_{b} - x_{0})/h , Inisialisasi nilai x dan y awal sama dengan x_{o} dan y_{0} , Tentukan nilai analitiknya untuk menghitung nilai error Lakukan perulangan sebanyak n, Update nilai k_{1} hinga k_{3} , nilai y dan nilai x serta nilai e kemudian cetak nilai nilai tersebut setiap melakukan peulangan. Source Code Metode Runge Kutta Orde Tiga def f ( x , y ): return x + y print ( \"Penyelesaian Persamaan Differensial Biasa Menggunakan Metode Runge-Kutta Orde3\" ) x0 = float ( input ( \"Masukkan Nilai X0 : \" )) y0 = float ( input ( \"Masukkan Nilai y0 : \" )) xb = float ( input ( \"Masukkan Nilai X yang dicari : \" )) h = float ( input ( \"Masukkan Nilai h : \" )) iterasi = ( xb - x0 ) / h n = int ( iterasi ) x = x0 y = y0 true = 1.1103 e = abs ( true - y ) print ( \"==================================================================================================\" ) print ( \">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>- METODE RUNGE-KUTTA ORDE 3 -<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\" ) print ( \"==================================================================================================\" ) print ( '|i \\t |x(i) \\t\\t |y(i) \\t\\t |e \\t\\t |k1 \\t\\t |k2 \\t\\t |k3' ) print ( \"| %d \" % x0 , ' \\t | %f ' % x , ' \\t | %f |' % y , ' \\t | %f ' % e , ' \\t |0' , ' \\t\\t |0' , ' \\t\\t |0' ) for i in range ( n ): k1 = h * f ( x , y ) k2 = h * f ( x + h / 2 , y + k1 / 2 ) k3 = h * f ( x + h , y - k1 + 2 * k2 ) y = y + ( k1 + 4 * k2 + k3 ) / 6 x = x + h e = abs ( true - y ) print ( \"| %d \" % ( i + 1 ), ' \\t |' , \" %f \" % x , ' \\t |' , \" %f \\t |\" % y , \" %f \\t |\" % e , \" %f \\t |\" % k1 , \" %f \\t |\" % k2 , \" %f \" % k3 ) print ( \"==================================================================================================\" ) Dan hasil output program diatas sebagai berikut. Penyelesaian Persamaan Differensial Biasa Menggunakan Metode Runge-Kutta Orde3 Masukkan Nilai X0 : 0 Masukkan Nilai y0 : 1 Masukkan Nilai X yang dicari : 0.1 Masukkan Nilai h : 0.02 ================================================================================================== >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>- METODE RUNGE-KUTTA ORDE 3 -<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< ================================================================================================== |i |x(i) |y(i) |e |k1 |k2 |k3 |0 |0.000000 |1.000000| |0.110300 |0 |0 |0 |1 | 0.020000 | 1.020403 | 0.089897 | 0.020000 | 0.020400 | 0.020816 |2 | 0.040000 | 1.041622 | 0.068678 | 0.020808 | 0.021216 | 0.021641 |3 | 0.060000 | 1.063673 | 0.046627 | 0.021632 | 0.022049 | 0.022482 |4 | 0.080000 | 1.086574 | 0.023726 | 0.022473 | 0.022898 | 0.023340 |5 | 0.100000 | 1.110342 | 0.000042 | 0.023331 | 0.023765 | 0.024215 ==================================================================================================","title":"3. Metode Runge-Kutta Orde Tiga"},{"location":"index/Differensial/#4_metode_runge-kutta_orde_empat","text":"Metode Runge-Kutta orde empat merupakan penyelesaian persamaaan differensial biasa dengan tingkat ketelitian yang tinggi. Bentuk Runge-Kutta orde empat berbentuk k_{1} = hf(x_{i},y_{i})\\\\ k_{2} = hf(x_{i}+\\dfrac{h}{2},y_{i}+\\dfrac{k1}{2})\\\\ k_{3} = hf(x_{i}+\\dfrac{h}{2},y_{i}+\\dfrac {k_{2}}{2})\\\\ k_{4} = hf(x_{i}+h,y_{i}+k_{3})\\\\ y_{i+1} = y_{i}+\\dfrac{k_{1}+2k_{2}+2k_{3}+k_{4}}{6} Contoh : Diketahui PDB \\dfrac{dy}{dt} = x + y dan y(0) = 1 gunakan metode Runge-Kutta orde 4 untuk menghitung y(0,10) dengan ukuran langkah h = 0.02 . Dan diketahui solusi PDB sejatinya = 1,1103 Jawab : Diketahui x_{0} = 0\\\\ y_{0} = 1\\\\ x_{b} = 0,10\\\\ h = 0,02\\\\ f(x,y) = x + y\\\\ hasil\\ analitik = 1,1103 Maka nilai n = (x_{b} - x_{0})/h = (0,10-0)/0,02 = 5 (banyaknya langkah) dan penerapan metode Runge-Kutta orde tiga pada PDB tersebut menjadi : y_{i+1} = y_{i}+\\dfrac{(k_{1}+2k_{2}+2k_{3}+k_{4})}{6} Langkah-langkah: x_{0} = 0 \\Rightarrow y_{0} = 1\\\\ x_{1} = 0,02 \\Rightarrow y_{1} = 1 +\\dfrac{0,0200+2(0,0204)+2(0,0204)+0,0208}{6}= 1,0204\\\\ x_{2} = 0,04 \\Rightarrow y_{2} = 1,0204 +\\dfrac{0,0208+2(0,0212)+2(0,0212)+0,0216}{6}= 1,0416\\\\ x_{3} = 0,06 \\Rightarrow y_{3} = 1,0416 +\\dfrac{0,0216+2(0,0220)+2(0,0220)+0,0224}{6}= 1,0636\\\\ x_{4} = 0,08 \\Rightarrow y_{4} = 1,0636 +\\dfrac{0,0224+2(0,0228)+2(0,0229)+0,0233}{6}= 1,0865\\\\ x_{5} = 0,10 \\Rightarrow y_{2} = 1,0204 +\\dfrac{0,0233+2(0,0237)+2(0,0237)+0,0242}{6}= 1,1103 Jadi solusi numerik dengan menggunakan metode Runge-Kutta orde empat di y(0,10) = 1,1103 dan nilai error yang dihasilkan ialah e = hasil analitik - solusi numerik = 1,1103 - 1,1103 = 0,0 . Algoritma Metode Runge-Kutta Orde Empat Deklarasi fungsi PDB yang akan di selesaikan, Masukkan inputan yang dibutuhkan seperti x_{0},y_{0},xb , dan h , Hitung perulangan yang diperlukan dengan menggunakan rumus n = (x_{b} - x_{0})/h , Inisialisasi nilai x dan y awal sama dengan x_{o} dan y_{0} , Tentukan nilai analitiknya untuk menghitung nilai error Lakukan perulangan sebanyak n, Update nilai k_{1} hinga k_{4} , nilai y dan nilai x serta nilai e kemudian cetak nilai nilai tersebut setiap melakukan peulangan. Source Code Metode Runge Kutta Orde Empat def f ( x , y ): return x + y print ( \"Penyelesaian Sistem Persamaan Differensial Biasa Menggunakan Metode Runge-Kutta Orde4\" ) x0 = float ( input ( \"Masukkan Nilai X0 : \" )) y0 = float ( input ( \"Masukkan Nilai y0 : \" )) xb = float ( input ( \"Masukkan Nilai X yang dicari : \" )) h = float ( input ( \"Masukkan Nilai h : \" )) iterasi = ( xb - x0 ) / h n = int ( iterasi ) x = x0 y = y0 true = 1.1103 e = abs ( true - y ) print ( \"==================================================================================================================\" ) print ( \">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>- METODE RUNGE-KUTTA ORDE 4 -<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\" ) print ( \"==================================================================================================================\" ) print ( '|i \\t |x(i) \\t\\t |y(i) \\t\\t |e \\t\\t |k1 \\t\\t |k2 \\t\\t |k3 \\t\\t |k4' ) print ( \"| %d \" % x0 , ' \\t | %f ' % x , ' \\t | %f |' % y , ' \\t | %f ' % e , ' \\t |0' , ' \\t\\t |0' , ' \\t\\t |0' , ' \\t\\t |0' ) for i in range ( n ): k1 = h * f ( x , y ) k2 = h * f ( x + h / 2 , y + k1 / 2 ) k3 = h * f ( x + h / 2 , y + k2 / 2 ) k4 = h * f ( x + h , y + k3 ) y = y + ( k1 + 2 * k2 + 2 * k3 + k4 ) / 6 x = x + h e = abs ( true - y ) print ( \"| %d \" % ( i + 1 ), ' \\t |' , \" %f \" % x , ' \\t |' , \" %f \\t |\" % y , \" %f \\t |\" % e , \" %f \\t |\" % k1 , \" %f \\t |\" % k2 , \" %f \\t |\" % k3 , \" %f \" % k4 ) print ( \"==================================================================================================================\" ) Dan output dari source code diatas ialah Penyelesaian Sistem Persamaan Differensial Biasa Menggunakan Metode Runge-Kutta Orde4 Masukkan Nilai X0 : 0 Masukkan Nilai y0 : 1 Masukkan Nilai X yang dicari : 0.1 Masukkan Nilai h : 0.02 ================================================================================================================== >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>- METODE RUNGE-KUTTA ORDE 3 -<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< ================================================================================================================== |i |x(i) |y(i) |e |k1 |k2 |k3 |k4 |0 |0.000000 |1.000000| |0.110300 |0 |0 |0 |0 |1 | 0.020000 | 1.020403 | 0.089897 | 0.020000 | 0.020400 | 0.020404 | 0.020808 |2 | 0.040000 | 1.041622 | 0.068678 | 0.020808 | 0.021216 | 0.021220 | 0.021632 |3 | 0.060000 | 1.063673 | 0.046627 | 0.021632 | 0.022049 | 0.022053 | 0.022473 |4 | 0.080000 | 1.086574 | 0.023726 | 0.022473 | 0.022898 | 0.022902 | 0.023332 |5 | 0.100000 | 1.110342 | 0.000042 | 0.023331 | 0.023765 | 0.023769 | 0.024207 ==================================================================================================================","title":"4. Metode Runge-Kutta Orde Empat"},{"location":"index/Differensial/#referensi","text":"https://app.schoology.com/course/4711478201/materials/gp/4905811750 \u21a9 http://iffatul.staff.gunadarma.ac.id/Downloads/files/46564/BAb-+08+Solusi+Persamaan+Diferensial+Bi \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9 \u21a9","title":"Referensi"},{"location":"index/SPL/","text":"SISTEM PERSAMAAN LINEAR (SPL) \u00b6 A. Definisi Sistem Persamaan Linear (SPL) \u00b6 \u200b Sistem persamaan linear (SPL) merupakan sekelompok persamaan linear yang terdiri dari beberapa variabel. 1 Sistem persamaan linear banyak dijumpai dalam berbagai disiplin ilmu, diantaranya matematika, fisika, statistika, teknik, biologi, dan ilmu-ilmu sosial serta bisnis. Sistem persamaan linear muncul secara langsung dari masalah-masalah nyata yang merupakan bagian dari proses penyelesaian masalah lain. 2 \u200b Bentuk umum sistem persamaan linear ialah sebagai berikut : Sistem Persamaan Linear Dua Variabel (SPLDV) \\begin{cases}ax+by = c\\\\ Px+qx = r \\end{cases} atau \\begin{cases}a_{1}x+b_{1}y = c_{1}\\\\ a_{2}x+b_{2}y = c_{2}\\end{cases} Sistem Persamaan Linear Tiga Variabel (SPLTV) \\begin{cases}ax+by+ cz= d\\\\ ex+fy+gz = h\\\\ ix+jy+kz = l \\end{cases} atau \\begin{cases}a_{1}x+b_{1}y + c_{1}z = d_{1}\\\\ a_{2}x+b_{2}y + c_{2}z = d_{2}\\\\a_{3}x+b_{3}y + c_{3}z = d_{3}\\end{cases} \u200b Untuk menyelesaikan bentuk sistem persamaan linear dengan 2 atau 3 variabel masih bisa diselesaikan dengan menggunakan metode analitik, namun bagaimana jika sistem persamaan linear tersebut terdiri dari banyak variabel/tak berhingga. Bentuk yang dimaksud ialah : \\begin{aligned}a_{11}x_{1}+a_{12}x_{2}+\\ldots + a_{1n}x_{n} = b_{1}\\\\ a_{21}x_{1}+a_{22}x_{2}+\\ldots +a_{2n}x_{n}=b_{2}\\\\ \\vdots \\\\a_{n1}x_{1}+a_{n2}x_{2}+\\ldots +a_{nn}x_{n}=b_{n}\\end{aligned} \u200b Untuk menyelesaikan persoalan tersebut dapat diselesaikan dengan menggunakan metode numerik, untuk lebih jelasnya perhatikan penjelasan berikut. B. Metode Penyelesaian Sistem Persamaan Linear (SPL) \u00b6 \u200b Untuk menyelesaikan sistem persamaan linear ialah dengan cara mencari nilai-nilai variabel tersebut sehingga memenuhi semua persamaan linear yang diberikan. 2 Dalam hal tersebut terdapat beberapa metode/cara untuk dapat menyelesaikan sistem persamaan linear diantaranya sebagai berikut. 1. Metode Eliminasi Gauss \u00b6 \u200b Metode eliminasi Gauss merupakan sebuah metode yang digunakan untuk menyelesaikan sistem persamaan linear dengan cara mengubah SPL tersebut ke dalam bentuk matrik yang berbentuk segitiga atas, yaitu semua koefisien di bawah diagonal utamanya bernilai nol. Kemudian bentuk segitiga atas tersebut dapat diselesaikan dengan cara mensubstitusi balik. Untuk mendapatkan bentuk segitiga atas tersebut dari SPL yang diberikan, metode eliminasi Gauss menggunakan Operasi Baris Elementer (OBE): 2 Menukar posisi dua buah persamaan. Menambah sebuah persamaan dengan suatu kelipatan persamaan lain. Mengalikan sebuah persamaan dengan sembarang konstanta tak nol. 2 Pemakaian OBE tersebut pada suatu SPL tidak akan mengubah SPL yang berkaitan, sudah jelas bahwa sebuah SPL tidak tergantung pada susunan persamaan, sehingga OBE nomor 1 dapat digunakan. Dan dalam setiap persamaan kedua ruas menyatakan nilai yang sama, sehingga OBE nomor 2 dapat dipakai. Demikian halnya OBE nomor 3 menghasilkan persamaan yang ekuivalen. Sehingga bentuk prosedur metode eliminasi gauss di asumsikan sebagai berikut. \\begin{bmatrix} a_{11}& a_{12}&a_{13}&:&b_{1}\\\\ a_{21}& a_{22}&a_{23}&:&b_{2} \\\\a_{31}& a_{32}&a_{33}&:&b_{3}\\end{bmatrix}\\Rightarrow\\begin{bmatrix} a_{11}& a_{12}&a_{13}&:&b_{1}\\\\ 0& a^{'}_{22}&a^{'}_{23}&:&b^{'}_{2} \\\\0& 0&a^{''}_{33}&:&b^{''}_{3}\\end{bmatrix} x_{3} = \\dfrac{b^{''}_{3}}{a^{''}_{33}}\\\\ x_{2} = \\dfrac{(b^{'}_{2}-a^{'}_{23}x_{3})}{a^{'}_{22}}\\\\ x_{1} = \\dfrac{(b_{1}-a_{12}x_{2}-a_{13}x_{3})}{a_{11}} Contoh : Selesaikan sistem persamaan linear berikut dengan menggunakan metode eliminasi gauss 6a - 2b + 2c + 4d = 16 12a - 8b + 6c + 10d = 26 3a - 13b + 9c + 3d = -19 -6a + 4b + c + -18d = -34 Jawab : Untuk menyelesaikan sistem persamaan tersebut ialah ubah bentuk persamaan tersebut kedalam bentuk matrik segitiga atas dengan cara eliminasi maju. Ubah persamaan tersebut kedalam bentuk matrik \\begin{bmatrix}6&-2&2&4\\\\12&-8&6&10\\\\3&-13&9&3\\\\-6&4&1&-18\\end{bmatrix}\\begin{bmatrix}x_{1}\\\\x_{2}\\\\x_{3}\\\\x_{4}\\end{bmatrix}=\\begin{bmatrix}16\\\\26\\\\-19\\\\-34\\end{bmatrix} Eliminasi x_{1} dari persamaan 2,3 dan 4 \\begin{bmatrix}6&-2&2&4\\\\0&-4&2&2\\\\0&-12&8&1\\\\0&2&3&-14\\end{bmatrix}\\begin{bmatrix}x_{1}\\\\x_{2}\\\\x_{3}\\\\x_{4}\\end{bmatrix}=\\begin{bmatrix}16\\\\-6\\\\-27\\\\-18\\end{bmatrix} Eliminasi x_{2} dari persamaan 3 dan 4 \\begin{bmatrix}6&-2&2&4\\\\0&-4&2&2\\\\0&0&2&-5\\\\0&0&4&-13\\end{bmatrix}\\begin{bmatrix}x_{1}\\\\x_{2}\\\\x_{3}\\\\x_{4}\\end{bmatrix}=\\begin{bmatrix}16\\\\-6\\\\-9\\\\-21\\end{bmatrix} Eliminasi x_{3} dari persamaan 4 \\begin{bmatrix}6&-2&2&4\\\\0&-4&2&2\\\\0&0&2&-5\\\\0&0&0&-3\\end{bmatrix}\\begin{bmatrix}x_{1}\\\\x_{2}\\\\x_{3}\\\\x_{4}\\end{bmatrix}=\\begin{bmatrix}16\\\\-6\\\\-9\\\\-3\\end{bmatrix} Hasil dari eliminasi maju sebagai berikut. \\begin{bmatrix}6&-2&2&4\\\\12&-8&6&10\\\\3&-13&9&3\\\\-6&4&1&-18\\end{bmatrix}\\begin{bmatrix}x_{1}\\\\x_{2}\\\\x_{3}\\\\x_{4}\\end{bmatrix}=\\begin{bmatrix}16\\\\26\\\\-19\\\\-34\\end{bmatrix}\\Rightarrow\\ \\begin{bmatrix}6&-2&2&4\\\\0&-4&2&2\\\\0&0&2&-5\\\\0&0&0&-3\\end{bmatrix}\\begin{bmatrix}x_{1}\\\\x_{2}\\\\x_{3}\\\\x_{4}\\end{bmatrix}=\\begin{bmatrix}16\\\\-6\\\\-9\\\\-3\\end{bmatrix} Setelah diperoleh bentuk matrik segitiga atas, langkah selanjutnya lakukan substitusi mundur mulai dari x_{4} hingga x_{1} x_{4} = \\dfrac{-3}{-3} = 1\\\\ x_{3} = \\dfrac{-9+5(1)}{-2} = \\dfrac{-4}{2}=-2\\\\ x_{2} = \\dfrac {-6-2(2)-2(1)}{-4} = \\dfrac{-4}{-4} = 1\\\\ x_{1} = \\dfrac{16-4(1)-2(-2)+2(1)}{6}= \\dfrac{18}{6}=3 Sehingga diperoleh nilai a = 3 , b = 1 , c = -2 dan d = 1 Algoritma Metode Eliminasi Gauss Deklarasikan SPL dalam bentuk matrik Membuat perulangan bersarang untuk melakukan eliminasi maju dengan struktur : Perulangan pertama untuk melakukan perulangan sebanyak panjang matrik yang dimulai dari 0. Perulangan kedua (di dalam perulangan pertama) untuk menentukan nilai faktor pengali pembuat 0 dan mengubah nilai matrik hasil yang dikurangi dengan nilai dari faktor yang dikalikan dengan matrik di indeks atas diagonal. Perulangan ketiga (di dalam perulangan kedua) untuk mengubah nilai matrik di indeks bawah diagonal menjadi nol dengan cara dikurangi dengan nilai dari faktor yang dikalikan dengan matrik di indeks atas diagonal. Perulangan keempat(di dalam perulangan kedua) untuk menampilkan perubahan nilai matrik. Membuat perulangan bersarang untuk melakukan substitusi mundur dengan struktur : Perulangan pertama sebanyak panjang matrik yang dimulai dari indeks terakhir untuk mengambil nilai hasil dari x_{n} hingga x_{1} dan mengubah nilai matrik di indeks yang menyimpan nilai x_{i} dengan nilai yang diperoleh di perulangan kedua yang dibagi dengan koefisien x_{i} . Perulangan kedua(di dalam perulangan pertama) untuk mengurangi nilai hasil dengan nilai korfisien yang dikalikan dengan nilai x_{i} . Perulangan ketiga(di dalam perulangan pertama) untuk menampilkan nilai matrik setelah diubah. Menampilkan nilai dari x_{1} hingga x_{n} . Kemudian implementasi dari algoritma tersebut ialah sebagai berikut Source Code Metode Eliminasi Gauss matrik = [ [[ 6 , - 2 , 2 , 4 ],[ \"X1\" ],[ 16 ]], [[ 12 , - 8 , 6 , 10 ],[ \"X2\" ],[ 26 ]], [[ 3 , - 13 , 9 , 3 ],[ \"X3\" ],[ - 19 ]], [[ - 6 , 4 , 1 , - 18 ],[ \"X4\" ],[ - 34 ]], ] print ( \"Penyelesaiaan Sistem Persamaan Linear Dari\" ) for u in matrik : print ( u ) print ( \"Menggunakan Metode Eliminasi Gauss\" ) print ( \"=======================================================\" ) print ( \">>>>>>>>>>>>>>- METODE ELIMINNASI GAUSS -<<<<<<<<<<<<<\" ) print ( \"=======================================================\" ) #untuk Eliminasi Maju for k in range ( 0 , len ( matrik ) - 1 ): for i in range ( k + 1 , len ( matrik )): faktor = matrik [ i ][ 0 ][ k ] / matrik [ k ][ 0 ][ k ] print ( \"faktor = \" , faktor ) for j in range ( k , len ( matrik )): matrik [ i ][ 0 ][ j ] = round ( matrik [ i ][ 0 ][ j ] - ( faktor * matrik [ k ][ 0 ][ j ]), 4 ) matrik [ i ][ 2 ][ 0 ] = round ( matrik [ i ][ 2 ][ 0 ] - ( faktor * matrik [ k ][ 2 ][ 0 ]), 2 ) for u in matrik : print ( u ) print ( \" \\n \" ) #Untuk Substitusi Mundur for i in range ( len ( matrik ) - 1 , - 1 , - 1 ): sum = matrik [ i ][ 2 ][ 0 ] for j in range ( i + 1 , len ( matrik )): sum = sum - round (( matrik [ i ][ 0 ][ j ] * matrik [ j ][ 1 ][ 0 ]), 4 ) matrik [ i ][ 1 ][ 0 ] = round ( sum / matrik [ i ][ 0 ][ i ], 4 ) for u in matrik : print ( u ) print ( \" \\n \" ) print ( \"Nilai Variabel yang diperoleh\" ) for u in range ( len ( matrik [ 0 ][ 0 ])): print ( f \"x { u + 1 } = { round ( matrik [ u ][ 1 ][ 0 ], 4 ) } \" ) print ( \"=======================================================\" ) Dan hasil output dari source code tersebut ialah sebagai berikut. Penyelesaiaan Sistem Persamaan Linear Dari [[6, -2, 2, 4], ['X1'], [16]] [[12, -8, 6, 10], ['X2'], [26]] [[3, -13, 9, 3], ['X3'], [-19]] [[-6, 4, 1, -18], ['X4'], [-34]] Menggunakan Metode Eliminasi Gauss ======================================================= >>>>>>>>>>>>>>- METODE ELIMINNASI GAUSS -<<<<<<<<<<<<< ======================================================= faktor = 2.0 [[6, -2, 2, 4], ['X1'], [16]] [[0.0, -4.0, 2.0, 2.0], ['X2'], [-6.0]] [[3, -13, 9, 3], ['X3'], [-19]] [[-6, 4, 1, -18], ['X4'], [-34]] faktor = 0.5 [[6, -2, 2, 4], ['X1'], [16]] [[0.0, -4.0, 2.0, 2.0], ['X2'], [-6.0]] [[0.0, -12.0, 8.0, 1.0], ['X3'], [-27.0]] [[-6, 4, 1, -18], ['X4'], [-34]] faktor = -1.0 [[6, -2, 2, 4], ['X1'], [16]] [[0.0, -4.0, 2.0, 2.0], ['X2'], [-6.0]] [[0.0, -12.0, 8.0, 1.0], ['X3'], [-27.0]] [[0.0, 2.0, 3.0, -14.0], ['X4'], [-18.0]] faktor = 3.0 [[6, -2, 2, 4], ['X1'], [16]] [[0.0, -4.0, 2.0, 2.0], ['X2'], [-6.0]] [[0.0, 0.0, 2.0, -5.0], ['X3'], [-9.0]] [[0.0, 2.0, 3.0, -14.0], ['X4'], [-18.0]] faktor = -0.5 [[6, -2, 2, 4], ['X1'], [16]] [[0.0, -4.0, 2.0, 2.0], ['X2'], [-6.0]] [[0.0, 0.0, 2.0, -5.0], ['X3'], [-9.0]] [[0.0, 0.0, 4.0, -13.0], ['X4'], [-21.0]] faktor = 2.0 [[6, -2, 2, 4], ['X1'], [16]] [[0.0, -4.0, 2.0, 2.0], ['X2'], [-6.0]] [[0.0, 0.0, 2.0, -5.0], ['X3'], [-9.0]] [[0.0, 0.0, 0.0, -3.0], ['X4'], [-3.0]] [[6, -2, 2, 4], ['X1'], [16]] [[0.0, -4.0, 2.0, 2.0], ['X2'], [-6.0]] [[0.0, 0.0, 2.0, -5.0], ['X3'], [-9.0]] [[0.0, 0.0, 0.0, -3.0], [1.0], [-3.0]] [[6, -2, 2, 4], ['X1'], [16]] [[0.0, -4.0, 2.0, 2.0], ['X2'], [-6.0]] [[0.0, 0.0, 2.0, -5.0], [-2.0], [-9.0]] [[0.0, 0.0, 0.0, -3.0], [1.0], [-3.0]] [[6, -2, 2, 4], ['X1'], [16]] [[0.0, -4.0, 2.0, 2.0], [1.0], [-6.0]] [[0.0, 0.0, 2.0, -5.0], [-2.0], [-9.0]] [[0.0, 0.0, 0.0, -3.0], [1.0], [-3.0]] [[6, -2, 2, 4], [3.0], [16]] [[0.0, -4.0, 2.0, 2.0], [1.0], [-6.0]] [[0.0, 0.0, 2.0, -5.0], [-2.0], [-9.0]] [[0.0, 0.0, 0.0, -3.0], [1.0], [-3.0]] Nilai Variabel yang diperoleh x1 = 3.0 x2 = 1.0 x3 = -2.0 x4 = 1.0 ======================================================= 2. Metode Jacobi \u00b6 \u200b Metode jacobi merupakan metode untuk menyelesaikan sistem persamaan linear dengan cara melakukan iterasi. Misalkan terdapat 3 persamaan dengan 3 bilangan tak diketahui : a_{11}x_{1}+a_{12}x_{2}+a_{13}x_{3}=b_{1}\\\\a_{21}x_{1}+a_{22}x_{2}+a_{23}x_{3}=b_{2}\\\\a_{31}x_{1}+a_{32}x_{2}+a_{33}x_{3}=b_{3} \u200b Dari sistem persamaan tersebut dengan menggunakan metode jacobi kita dapat menhitung nilai x_{1} dengan menggunakan persamaan pertama. Begitu pula dengan x_{2} dan x_{3} dapat dihitung dengan menggunakan persamaan kedua dan ketiga, sehingga didapat : x_{1} = \\dfrac{b_{1}-a_{12}x_{2}-a_{13}x_{3}}{a_{11}}\\\\x_{2} = \\dfrac{b_{2}-a_{21}x_{1}-a_{23}x_{3}}{a_{22}}\\\\x_{3} = \\dfrac{b_{3}-a_{31}x_{1}-a_{32}x_{2}}{a_{33}} \u200b Sehingga metode jacobi secara umum dapat dituliskan sebagai berikut:[^3] x^{(k+1)}_{i} =\\left( b_{i}-\\sum^{i-1}_{j=1}a_{ij}x^{k}_{j}-\\sum^{n}_{j=i+1}a_{ij}x^{k}_{j} \\right)/a_{ii} Contoh : Selesaikan sistem persamaan linear 4 variabel berikut menggunakan iterasi jacobi. 10a - b + 2c = 6 -a + 11b - c + 3d = 25 2a - b + 10c - d = -11 3b - c + 8d = 15 Jawab : Dari soal diperoleh : 10x_{1}-x_{2}+2x_{3} = 6\\\\ -x{1}+11x_{2}-x_{3}+3x_{4} = 25 \\\\ 2x_{1}-x_{2}+10_{x3}-x_{4}=11\\\\ 3x_{2}-x_{3}+8x_{4} = 15 Sehingga nilai x_{1} hingga x_{4} : x_{1} =(x_{2}-2x_{3}+6)/10\\\\ x_{2} =(x_{1}+x_{3}-3x_{4}+25)/11\\\\ x_{3} =(-2x_{1}+x_{2}+x_{4}-11)/10\\\\ x_{4} =(-3x_{2}+x_{3}+15)/8 Sehingga nilai x_{1} hingga x_{4} pada iterasi ke k dapat dituliskan sebagai berikut : x_{1}^{(k+1)} =(x_{2}^{k}-2x_{3}^{k}+6)/10\\\\ x_{2}^{(k+1)} =(x_{1}^{k}+x_{3}^{k}-3x_{4}^{k}+25)/11\\\\ x_{3}^{(k+1)} =(-2x_{1}^{k}+x_{2}^{k}+x_{4}^{k}-11)/10\\\\ x_{4}^{(k+1)} =(-3x_{2}^{k}+x_{3}^{k}+15)/8 Dan nilai yang diperoleh disajikan dalam tabel berikut : X_{i} K = 1 K = 2 K = 3 K = 4 K = 5 K = 6 K = 7 K = 8 K = 9 K = 10 x_{1} 0,6000 1,0473 0,9326 1,0152 0,9890 1,0032 0,9981 1,0006 0,9997 1,0001 x_{2} 2,2727 1,7159 2,0533 1,9537 2,0114 1,9922 2,0023 1,9987 2.0004 1,9998 x_{3} -1,1000 -0,8052 -1,0493 -0,9681 -1,0103 -0,9945 -1,0020 0,9990 -1,0004 -0,9998 x_{4} -1,8750 0,8852 1,1309 0,9738 1,0214 0,9944 1.0036 0,9989 1,0006 0,9998 Algoritma Metode Jacobi Deklarasikan SPL dalam bentuk matrik Deklarasi nilai X_{i} dari hasil analitik Deklarasi array yang kosong ( K = [ ] ) Buat perulangan untuk menampilkan SPL dalam bentuk matrik Tentukan banyak iterasi ( n ) Buat perulangan untuk membuat nilai awal x_{i} = 0 Buat perulangan bersarang dengan ketentuan : Perulangan pertama sebanyak n inputan untuk menentukan berapa kali melakukan iterasi. Dan menghapus nilai di dalam array kosong( K = [ ] ). Perulangan kedua(di dalam perulangan pertama) sebanyak panjang dari matrik untuk mengambil nilai hasil di dalam matrik. Dan menampung nilai yang dihasilkan dari perulangan ketiga kedalam array kosong . Perulangan ketiga(di dalam perulangan kedua) sebanyak panjang dari matrik untuk mengurangi nilai hasil dengan koefisien yang dikalikan dengan nilai x_{i} dengan mengambil nilai dari matrik. Perulangan keempat(di dalam perulangan pertama) sebanyak panjang matrik untuk mengubah nilai x_{i} dengan nilai yang ditampung di array kosong. Dan menghitung nilai error yang dihasilkan kemudian menampilkan nilai x_{i} dan error yang dihasilkan pada iterasi ke-k. Sehingga source code dari metode jacobi ialah sebagai berikut. Source Code Metode Jacobi matrik = [ [[ 10 , - 1 , 2 , 0 ],[ \"X1\" ],[ 6 ]], [[ - 1 , 11 , - 1 , 3 ],[ \"X2\" ],[ 25 ]], [[ 2 , - 1 , 10 , - 1 ],[ \"X3\" ],[ - 11 ]], [[ 0 , 3 , - 1 , 8 ],[ \"X4\" ],[ 15 ]], ] true = [ 1 , 2 , - 1 , 1 ] K = [] print ( \"Penyelesaiaan Sistem Persamaan Linear Dari\" ) for i in matrik : print ( i ) print ( \"Menggunakan Metode Jacobi\" ) n = int ( input ( \"Masukkan banyak iterasi : \" )) print ( \"=======================================================\" ) print ( \">>>>>>>>>>>>>>>>>>>>- METODE JACOBI -<<<<<<<<<<<<<<<<<<\" ) print ( \"=======================================================\" ) for i in range ( len ( matrik [ 0 ][ 0 ])): matrik [ i ][ 1 ][ 0 ] = 0 for k in range ( n ): for i in range ( len ( matrik )): sum = matrik [ i ][ 2 ][ 0 ] for j in range ( len ( matrik )): if i == j : continue sum = sum - matrik [ i ][ 0 ][ j ] * matrik [ j ][ 1 ][ 0 ] K . append ( sum / matrik [ i ][ 0 ][ i ]) print ( f \"iterasi { k + 1 } \" , ' \\t ' , \"|Xi\" , ' \\t\\t\\t ' , \"|errorXi\" ) for x in range ( len ( matrik )): matrik [ x ][ 1 ][ 0 ] = K [ x ] ea = abs (( true [ x ] - K [ x ]) / true [ x ]) * 100 print ( \"X\" + str ( x + 1 ), ' \\t\\t ' , \"| %.10f |\" % K [ x ], ' \\t ' , \" %.10f \" % ea ) K . clear () print ( \"=======================================================\" ) Dan output yang dihasilkan sebagai berikut. Penyelesaiaan Sistem Persamaan Linear Dari [[10, -1, 2, 0], ['X1'], [6]] [[-1, 11, -1, 3], ['X2'], [25]] [[2, -1, 10, -1], ['X3'], [-11]] [[0, 3, -1, 8], ['X4'], [15]] Menggunakan Metode Jacobi Masukkan banyak iterasi : 10 ======================================================= >>>>>>>>>>>>>>>>>>>>- METODE JACOBI -<<<<<<<<<<<<<<<<<< ======================================================= iterasi 1 |Xi |errorXi X1 |0.6000000000| 40.0000000000 X2 |2.2727272727| 13.6363636364 X3 |-1.1000000000| 10.0000000000 X4 |1.8750000000| 87.5000000000 iterasi 2 |Xi |errorXi X1 |1.0472727273| 4.7272727273 X2 |1.7159090909| 14.2045454545 X3 |-0.8052272727| 19.4772727273 X4 |0.8852272727| 11.4772727273 iterasi 3 |Xi |errorXi X1 |0.9326363636| 6.7363636364 X2 |2.0533057851| 2.6652892562 X3 |-1.0493409091| 4.9340909091 X4 |1.1308806818| 13.0880681818 iterasi 4 |Xi |errorXi X1 |1.0151987603| 1.5198760331 X2 |1.9536957645| 2.3152117769 X3 |-0.9681086260| 3.1891373967 X4 |0.9738427169| 2.6157283058 iterasi 5 |Xi |errorXi X1 |0.9889913017| 1.1008698347 X2 |2.0114147258| 0.5707362885 X3 |-1.0102859039| 1.0285903926 X4 |1.0213505101| 2.1350510072 iterasi 6 |Xi |errorXi X1 |1.0031986534| 0.3198653362 X2 |1.9922412607| 0.3879369659 X3 |-0.9945217367| 0.5478263254 X4 |0.9944337398| 0.5566260154 iterasi 7 |Xi |errorXi X1 |0.9981284734| 0.1871526582 X2 |2.0023068816| 0.1153440776 X3 |-1.0019722306| 0.1972230620 X4 |1.0035943102| 0.3594310151 iterasi 8 |Xi |errorXi X1 |1.0006251343| 0.0625134279 X2 |1.9986703011| 0.0664849439 X3 |-0.9990355755| 0.0964424487 X4 |0.9988883906| 0.1111609410 iterasi 9 |Xi |errorXi X1 |0.9996741452| 0.0325854785 X2 |2.0004476715| 0.0223835773 X3 |-1.0003691577| 0.0369157685 X4 |1.0006191901| 0.0619190140 iterasi 10 |Xi |errorXi X1 |1.0001185987| 0.0118598691 X2 |1.9997679470| 0.0116026495 X3 |-0.9998281429| 0.0171857126 X4 |0.9997859785| 0.0214021540 ======================================================= 3. Metode Gauss Seidel \u00b6 \u200b Metode Gauss Seidel merupakan metode penyelesaian sistem persamaan linear yang hampir sama dengan metode jacobi. Hanya saja di dalam metode jacobi nilai x_{1} yang didapat dari persamaan pertama tidak digunakan untuk menghitung nilai x_{2} dengan menggunakan persamaan kedua. Demikian halnya dengan nilai x_{2} tidak digunakan untuk mencari nilai x_{3} , begitu seterusnya. 2 Sedangkan didalam metode Gauss Seidel nilai x_{1} yang diperoleh dari persamaan sebelumnya akan dipakai untuk mencari nilai x_{2} begitupun seterusnya. Sehingga dapat disimpulkan metode Jacobi tidak menggunakan nilai yang terbaru sedangkan metode Gauss Seidel menggunakan nilai yang terbaru. \u200b Sehingga bentuk metoode Gauss Seidel secara umum dapat dituliskan sebagai berikut:[^3] x^{(k+1)}_{i} =\\left( b_{i}-\\sum^{i-1}_{j=1}a_{ij}x^{(k+1)}_{j}-\\sum^{n}_{j=i+1}a_{ij}x^{k}_{j} \\right)/a_{ii} Contoh : Selesaikan sistem persamaan linear 4 variabel berikut menggunakan iterasi Gauss Seidel. 10a - b + 2c = 6 -a + 11b - c + 3d = 25 2a - b + 10c - d = -11 3b - c + 8d = 15 Jawab : Dari soal diperoleh : 10x_{1}-x_{2}+2x_{3} = 6\\\\ -x{1}+11x_{2}-x_{3}+3x_{4} = 25 \\\\ 2x_{1}-x_{2}+10_{x3}-x_{4}=11\\\\ 3x_{2}-x_{3}+8x_{4} = 15 Sehingga nilai x_{1} hingga x_{4} : x_{1} =(x_{2}-2x_{3}+6)/10\\\\ x_{2} =(x_{1}+x_{3}-3x_{4}+25)/11\\\\ x_{3} =(-2x_{1}+x_{2}+x_{4}-11)/10\\\\ x_{4} =(-3x_{2}+x_{3}+15)/8 Sehingga nilai x_{1} hingga x_{4} pada iterasi ke k dapat dituliskan sebagai berikut : x_{1}^{(k+1)} =(x_{2}^{k}-2x_{3}^{k}+6)/10\\\\ x_{2}^{(k+1)} =(x_{1}^{(k+1)}+x_{3}^{k}-3x_{4}^{k}+25)/11\\\\ x_{3}^{(k+1)} =(-2x_{1}^{(k+1)}+x_{2}^{(k+1)}+x_{4}^{k}-11)/10\\\\ x_{4}^{(k+1)} =(-3x_{2}^{(k+1)}+x_{3}^{(k+1)}+15)/8 Dan nilai yang diperoleh disajikan dalam tabel berikut : K = 1 K = 2 K = 3 K = 4 K = 5 x_{1} 0,6000 1,0302 1,0066 1,0009 1,0001 x_{2} 2,3273 2,0369 2,0036 2,0003 2,0000 x_{3} -0,9873 -1,0145 -1,0025 -1,0003 -1,0000 x_{4} 0,8789 0,9843 0,9984 0,9998 1,0000 Algoritma Metode Jacobi Deklarasikan SPL dalam bentuk matrik Deklarasi nilai X_{i} dari hasil analitik Buat perulangan untuk menampilkan SPL dalam bentuk matrik Tentukan banyak iterasi ( n ) Buat perulangan untuk membuat nilai awal x_{i} = 0 Buat perulangan bersarang dengan ketentuan : Perulangan pertama sebanyak n inputan untuk menentukan berapa kali melakukan iterasi. Perulangan kedua(di dalam perulangan pertama) sebanyak panjang dari matrik untuk mengambil nilai hasil di dalam matrik. Dan mengubah nilai x_{i} menjadi nilai yang dihasilkan dari perulangan ketiga. Perulangan ketiga(di dalam perulangan kedua) sebanyak panjang dari matrik untuk mengurangi nilai hasil dengan koefisien yang dikalikan dengan nilai x_{i} dengan mengambil nilai dari matrik. Perulangan keempat(di dalam perulangan pertama) sebanyak panjang matrik untuk menghitung nilai error yang dihasilkan kemudian menampilkan nilai x_{i} dan error yang dihasilkan pada iterasi ke-k. Sehingga source code dari metode Gauss Seidel ialah sebagai berikut. Source Code Metode Gauss Seidel matrik = [ [[ 10 , - 1 , 2 , 0 ],[ \"X1\" ],[ 6 ]], [[ - 1 , 11 , - 1 , 3 ],[ \"X2\" ],[ 25 ]], [[ 2 , - 1 , 10 , - 1 ],[ \"X3\" ],[ - 11 ]], [[ 0 , 3 , - 1 , 8 ],[ \"X4\" ],[ 15 ]], ] true = [ 1 , 2 , - 1 , 1 ] print ( \"Penyelesaiaan Sistem Persamaan Linear Dari\" ) for i in matrik : print ( i ) print ( \"Menggunakan Metode Gauss Seidel\" ) n = int ( input ( \"Masukkan banyak iterasi : \" )) print ( \"=======================================================\" ) print ( \">>>>>>>>>>>>>>>>>- METODE GAUSS SEIDEL -<<<<<<<<<<<<<<<\" ) print ( \"=======================================================\" ) for i in range ( len ( matrik [ 0 ][ 0 ])): matrik [ i ][ 1 ][ 0 ] = 0 for k in range ( n ): for i in range ( len ( matrik )): Xi = matrik [ i ][ 1 ][ 0 ] sum = matrik [ i ][ 2 ][ 0 ] for j in range ( len ( matrik )): if j == i : continue sum = sum - matrik [ i ][ 0 ][ j ] * matrik [ j ][ 1 ][ 0 ] matrik [ i ][ 1 ][ 0 ] = sum / matrik [ i ][ 0 ][ i ] print ( f \"iterasi { k + 1 } \" , ' \\t ' , \"|Xi\" , ' \\t\\t\\t ' , \"|errorXi\" ) for x in range ( len ( matrik )): ea = abs (( matrik [ x ][ 1 ][ 0 ] - true [ x ]) / true [ x ]) * 100 print ( \"X\" + str ( x + 1 ), ' \\t\\t ' , \"| %.10f |\" % matrik [ x ][ 1 ][ 0 ], ' \\t ' , \" %.10f \" % ea ) print ( \"=======================================================\" ) Dan hasil ouput dari source code tersebut ialah sebagai berikut. Penyelesaiaan Sistem Persamaan Linear Dari [[10, -1, 2, 0], ['X1'], [6]] [[-1, 11, -1, 3], ['X2'], [25]] [[2, -1, 10, -1], ['X3'], [-11]] [[0, 3, -1, 8], ['X4'], [15]] Menggunakan Metode Gauss Seidel Masukkan banyak iterasi : 5 ======================================================= >>>>>>>>>>>>>>>>>- METODE GAUSS SEIDEL -<<<<<<<<<<<<<<< ======================================================= iterasi 1 |Xi |errorXi X1 |0.6000000000| 40.0000000000 X2 |2.3272727273| 16.3636363636 X3 |-0.9872727273| 1.2727272727 X4 |0.8788636364| 12.1136363636 iterasi 2 |Xi |errorXi X1 |1.0301818182| 3.0181818182 X2 |2.0369380165| 1.8469008264 X3 |-1.0144561983| 1.4456198347 X4 |0.9843412190| 1.5658780992 iterasi 3 |Xi |errorXi X1 |1.0065850413| 0.6585041322 X2 |2.0035550169| 0.1777508452 X3 |-1.0025273847| 0.2527384673 X4 |0.9983509456| 0.1649054423 iterasi 4 |Xi |errorXi X1 |1.0008609786| 0.0860978625 X2 |2.0002982507| 0.0149125328 X3 |-1.0003072761| 0.0307276102 X4 |0.9998497465| 0.0150253509 iterasi 5 |Xi |errorXi X1 |1.0000912803| 0.0091280286 X2 |2.0000213422| 0.0010671123 X3 |-1.0000311472| 0.0031147183 X4 |0.9999881033| 0.0011896740 ======================================================= Referensi \u00b6 https://id.m.wikipedia.org/wiki/Sistem_persamaan_linear \u21a9 https://www.slideshare.net/KhannalPakinde/makalah-metode-numerik-sistem-persamaan-linear \u21a9 \u21a9 \u21a9 \u21a9 \u21a9","title":"SISTEM PERSAMAAN LINEAR (SPL)"},{"location":"index/SPL/#sistem_persamaan_linear_spl","text":"","title":"SISTEM PERSAMAAN LINEAR (SPL)"},{"location":"index/SPL/#a_definisi_sistem_persamaan_linear_spl","text":"\u200b Sistem persamaan linear (SPL) merupakan sekelompok persamaan linear yang terdiri dari beberapa variabel. 1 Sistem persamaan linear banyak dijumpai dalam berbagai disiplin ilmu, diantaranya matematika, fisika, statistika, teknik, biologi, dan ilmu-ilmu sosial serta bisnis. Sistem persamaan linear muncul secara langsung dari masalah-masalah nyata yang merupakan bagian dari proses penyelesaian masalah lain. 2 \u200b Bentuk umum sistem persamaan linear ialah sebagai berikut : Sistem Persamaan Linear Dua Variabel (SPLDV) \\begin{cases}ax+by = c\\\\ Px+qx = r \\end{cases} atau \\begin{cases}a_{1}x+b_{1}y = c_{1}\\\\ a_{2}x+b_{2}y = c_{2}\\end{cases} Sistem Persamaan Linear Tiga Variabel (SPLTV) \\begin{cases}ax+by+ cz= d\\\\ ex+fy+gz = h\\\\ ix+jy+kz = l \\end{cases} atau \\begin{cases}a_{1}x+b_{1}y + c_{1}z = d_{1}\\\\ a_{2}x+b_{2}y + c_{2}z = d_{2}\\\\a_{3}x+b_{3}y + c_{3}z = d_{3}\\end{cases} \u200b Untuk menyelesaikan bentuk sistem persamaan linear dengan 2 atau 3 variabel masih bisa diselesaikan dengan menggunakan metode analitik, namun bagaimana jika sistem persamaan linear tersebut terdiri dari banyak variabel/tak berhingga. Bentuk yang dimaksud ialah : \\begin{aligned}a_{11}x_{1}+a_{12}x_{2}+\\ldots + a_{1n}x_{n} = b_{1}\\\\ a_{21}x_{1}+a_{22}x_{2}+\\ldots +a_{2n}x_{n}=b_{2}\\\\ \\vdots \\\\a_{n1}x_{1}+a_{n2}x_{2}+\\ldots +a_{nn}x_{n}=b_{n}\\end{aligned} \u200b Untuk menyelesaikan persoalan tersebut dapat diselesaikan dengan menggunakan metode numerik, untuk lebih jelasnya perhatikan penjelasan berikut.","title":"A. Definisi Sistem Persamaan Linear (SPL)"},{"location":"index/SPL/#b_metode_penyelesaian_sistem_persamaan_linear_spl","text":"\u200b Untuk menyelesaikan sistem persamaan linear ialah dengan cara mencari nilai-nilai variabel tersebut sehingga memenuhi semua persamaan linear yang diberikan. 2 Dalam hal tersebut terdapat beberapa metode/cara untuk dapat menyelesaikan sistem persamaan linear diantaranya sebagai berikut.","title":"B. Metode Penyelesaian Sistem Persamaan Linear (SPL)"},{"location":"index/SPL/#1_metode_eliminasi_gauss","text":"\u200b Metode eliminasi Gauss merupakan sebuah metode yang digunakan untuk menyelesaikan sistem persamaan linear dengan cara mengubah SPL tersebut ke dalam bentuk matrik yang berbentuk segitiga atas, yaitu semua koefisien di bawah diagonal utamanya bernilai nol. Kemudian bentuk segitiga atas tersebut dapat diselesaikan dengan cara mensubstitusi balik. Untuk mendapatkan bentuk segitiga atas tersebut dari SPL yang diberikan, metode eliminasi Gauss menggunakan Operasi Baris Elementer (OBE): 2 Menukar posisi dua buah persamaan. Menambah sebuah persamaan dengan suatu kelipatan persamaan lain. Mengalikan sebuah persamaan dengan sembarang konstanta tak nol. 2 Pemakaian OBE tersebut pada suatu SPL tidak akan mengubah SPL yang berkaitan, sudah jelas bahwa sebuah SPL tidak tergantung pada susunan persamaan, sehingga OBE nomor 1 dapat digunakan. Dan dalam setiap persamaan kedua ruas menyatakan nilai yang sama, sehingga OBE nomor 2 dapat dipakai. Demikian halnya OBE nomor 3 menghasilkan persamaan yang ekuivalen. Sehingga bentuk prosedur metode eliminasi gauss di asumsikan sebagai berikut. \\begin{bmatrix} a_{11}& a_{12}&a_{13}&:&b_{1}\\\\ a_{21}& a_{22}&a_{23}&:&b_{2} \\\\a_{31}& a_{32}&a_{33}&:&b_{3}\\end{bmatrix}\\Rightarrow\\begin{bmatrix} a_{11}& a_{12}&a_{13}&:&b_{1}\\\\ 0& a^{'}_{22}&a^{'}_{23}&:&b^{'}_{2} \\\\0& 0&a^{''}_{33}&:&b^{''}_{3}\\end{bmatrix} x_{3} = \\dfrac{b^{''}_{3}}{a^{''}_{33}}\\\\ x_{2} = \\dfrac{(b^{'}_{2}-a^{'}_{23}x_{3})}{a^{'}_{22}}\\\\ x_{1} = \\dfrac{(b_{1}-a_{12}x_{2}-a_{13}x_{3})}{a_{11}} Contoh : Selesaikan sistem persamaan linear berikut dengan menggunakan metode eliminasi gauss 6a - 2b + 2c + 4d = 16 12a - 8b + 6c + 10d = 26 3a - 13b + 9c + 3d = -19 -6a + 4b + c + -18d = -34 Jawab : Untuk menyelesaikan sistem persamaan tersebut ialah ubah bentuk persamaan tersebut kedalam bentuk matrik segitiga atas dengan cara eliminasi maju. Ubah persamaan tersebut kedalam bentuk matrik \\begin{bmatrix}6&-2&2&4\\\\12&-8&6&10\\\\3&-13&9&3\\\\-6&4&1&-18\\end{bmatrix}\\begin{bmatrix}x_{1}\\\\x_{2}\\\\x_{3}\\\\x_{4}\\end{bmatrix}=\\begin{bmatrix}16\\\\26\\\\-19\\\\-34\\end{bmatrix} Eliminasi x_{1} dari persamaan 2,3 dan 4 \\begin{bmatrix}6&-2&2&4\\\\0&-4&2&2\\\\0&-12&8&1\\\\0&2&3&-14\\end{bmatrix}\\begin{bmatrix}x_{1}\\\\x_{2}\\\\x_{3}\\\\x_{4}\\end{bmatrix}=\\begin{bmatrix}16\\\\-6\\\\-27\\\\-18\\end{bmatrix} Eliminasi x_{2} dari persamaan 3 dan 4 \\begin{bmatrix}6&-2&2&4\\\\0&-4&2&2\\\\0&0&2&-5\\\\0&0&4&-13\\end{bmatrix}\\begin{bmatrix}x_{1}\\\\x_{2}\\\\x_{3}\\\\x_{4}\\end{bmatrix}=\\begin{bmatrix}16\\\\-6\\\\-9\\\\-21\\end{bmatrix} Eliminasi x_{3} dari persamaan 4 \\begin{bmatrix}6&-2&2&4\\\\0&-4&2&2\\\\0&0&2&-5\\\\0&0&0&-3\\end{bmatrix}\\begin{bmatrix}x_{1}\\\\x_{2}\\\\x_{3}\\\\x_{4}\\end{bmatrix}=\\begin{bmatrix}16\\\\-6\\\\-9\\\\-3\\end{bmatrix} Hasil dari eliminasi maju sebagai berikut. \\begin{bmatrix}6&-2&2&4\\\\12&-8&6&10\\\\3&-13&9&3\\\\-6&4&1&-18\\end{bmatrix}\\begin{bmatrix}x_{1}\\\\x_{2}\\\\x_{3}\\\\x_{4}\\end{bmatrix}=\\begin{bmatrix}16\\\\26\\\\-19\\\\-34\\end{bmatrix}\\Rightarrow\\ \\begin{bmatrix}6&-2&2&4\\\\0&-4&2&2\\\\0&0&2&-5\\\\0&0&0&-3\\end{bmatrix}\\begin{bmatrix}x_{1}\\\\x_{2}\\\\x_{3}\\\\x_{4}\\end{bmatrix}=\\begin{bmatrix}16\\\\-6\\\\-9\\\\-3\\end{bmatrix} Setelah diperoleh bentuk matrik segitiga atas, langkah selanjutnya lakukan substitusi mundur mulai dari x_{4} hingga x_{1} x_{4} = \\dfrac{-3}{-3} = 1\\\\ x_{3} = \\dfrac{-9+5(1)}{-2} = \\dfrac{-4}{2}=-2\\\\ x_{2} = \\dfrac {-6-2(2)-2(1)}{-4} = \\dfrac{-4}{-4} = 1\\\\ x_{1} = \\dfrac{16-4(1)-2(-2)+2(1)}{6}= \\dfrac{18}{6}=3 Sehingga diperoleh nilai a = 3 , b = 1 , c = -2 dan d = 1 Algoritma Metode Eliminasi Gauss Deklarasikan SPL dalam bentuk matrik Membuat perulangan bersarang untuk melakukan eliminasi maju dengan struktur : Perulangan pertama untuk melakukan perulangan sebanyak panjang matrik yang dimulai dari 0. Perulangan kedua (di dalam perulangan pertama) untuk menentukan nilai faktor pengali pembuat 0 dan mengubah nilai matrik hasil yang dikurangi dengan nilai dari faktor yang dikalikan dengan matrik di indeks atas diagonal. Perulangan ketiga (di dalam perulangan kedua) untuk mengubah nilai matrik di indeks bawah diagonal menjadi nol dengan cara dikurangi dengan nilai dari faktor yang dikalikan dengan matrik di indeks atas diagonal. Perulangan keempat(di dalam perulangan kedua) untuk menampilkan perubahan nilai matrik. Membuat perulangan bersarang untuk melakukan substitusi mundur dengan struktur : Perulangan pertama sebanyak panjang matrik yang dimulai dari indeks terakhir untuk mengambil nilai hasil dari x_{n} hingga x_{1} dan mengubah nilai matrik di indeks yang menyimpan nilai x_{i} dengan nilai yang diperoleh di perulangan kedua yang dibagi dengan koefisien x_{i} . Perulangan kedua(di dalam perulangan pertama) untuk mengurangi nilai hasil dengan nilai korfisien yang dikalikan dengan nilai x_{i} . Perulangan ketiga(di dalam perulangan pertama) untuk menampilkan nilai matrik setelah diubah. Menampilkan nilai dari x_{1} hingga x_{n} . Kemudian implementasi dari algoritma tersebut ialah sebagai berikut Source Code Metode Eliminasi Gauss matrik = [ [[ 6 , - 2 , 2 , 4 ],[ \"X1\" ],[ 16 ]], [[ 12 , - 8 , 6 , 10 ],[ \"X2\" ],[ 26 ]], [[ 3 , - 13 , 9 , 3 ],[ \"X3\" ],[ - 19 ]], [[ - 6 , 4 , 1 , - 18 ],[ \"X4\" ],[ - 34 ]], ] print ( \"Penyelesaiaan Sistem Persamaan Linear Dari\" ) for u in matrik : print ( u ) print ( \"Menggunakan Metode Eliminasi Gauss\" ) print ( \"=======================================================\" ) print ( \">>>>>>>>>>>>>>- METODE ELIMINNASI GAUSS -<<<<<<<<<<<<<\" ) print ( \"=======================================================\" ) #untuk Eliminasi Maju for k in range ( 0 , len ( matrik ) - 1 ): for i in range ( k + 1 , len ( matrik )): faktor = matrik [ i ][ 0 ][ k ] / matrik [ k ][ 0 ][ k ] print ( \"faktor = \" , faktor ) for j in range ( k , len ( matrik )): matrik [ i ][ 0 ][ j ] = round ( matrik [ i ][ 0 ][ j ] - ( faktor * matrik [ k ][ 0 ][ j ]), 4 ) matrik [ i ][ 2 ][ 0 ] = round ( matrik [ i ][ 2 ][ 0 ] - ( faktor * matrik [ k ][ 2 ][ 0 ]), 2 ) for u in matrik : print ( u ) print ( \" \\n \" ) #Untuk Substitusi Mundur for i in range ( len ( matrik ) - 1 , - 1 , - 1 ): sum = matrik [ i ][ 2 ][ 0 ] for j in range ( i + 1 , len ( matrik )): sum = sum - round (( matrik [ i ][ 0 ][ j ] * matrik [ j ][ 1 ][ 0 ]), 4 ) matrik [ i ][ 1 ][ 0 ] = round ( sum / matrik [ i ][ 0 ][ i ], 4 ) for u in matrik : print ( u ) print ( \" \\n \" ) print ( \"Nilai Variabel yang diperoleh\" ) for u in range ( len ( matrik [ 0 ][ 0 ])): print ( f \"x { u + 1 } = { round ( matrik [ u ][ 1 ][ 0 ], 4 ) } \" ) print ( \"=======================================================\" ) Dan hasil output dari source code tersebut ialah sebagai berikut. Penyelesaiaan Sistem Persamaan Linear Dari [[6, -2, 2, 4], ['X1'], [16]] [[12, -8, 6, 10], ['X2'], [26]] [[3, -13, 9, 3], ['X3'], [-19]] [[-6, 4, 1, -18], ['X4'], [-34]] Menggunakan Metode Eliminasi Gauss ======================================================= >>>>>>>>>>>>>>- METODE ELIMINNASI GAUSS -<<<<<<<<<<<<< ======================================================= faktor = 2.0 [[6, -2, 2, 4], ['X1'], [16]] [[0.0, -4.0, 2.0, 2.0], ['X2'], [-6.0]] [[3, -13, 9, 3], ['X3'], [-19]] [[-6, 4, 1, -18], ['X4'], [-34]] faktor = 0.5 [[6, -2, 2, 4], ['X1'], [16]] [[0.0, -4.0, 2.0, 2.0], ['X2'], [-6.0]] [[0.0, -12.0, 8.0, 1.0], ['X3'], [-27.0]] [[-6, 4, 1, -18], ['X4'], [-34]] faktor = -1.0 [[6, -2, 2, 4], ['X1'], [16]] [[0.0, -4.0, 2.0, 2.0], ['X2'], [-6.0]] [[0.0, -12.0, 8.0, 1.0], ['X3'], [-27.0]] [[0.0, 2.0, 3.0, -14.0], ['X4'], [-18.0]] faktor = 3.0 [[6, -2, 2, 4], ['X1'], [16]] [[0.0, -4.0, 2.0, 2.0], ['X2'], [-6.0]] [[0.0, 0.0, 2.0, -5.0], ['X3'], [-9.0]] [[0.0, 2.0, 3.0, -14.0], ['X4'], [-18.0]] faktor = -0.5 [[6, -2, 2, 4], ['X1'], [16]] [[0.0, -4.0, 2.0, 2.0], ['X2'], [-6.0]] [[0.0, 0.0, 2.0, -5.0], ['X3'], [-9.0]] [[0.0, 0.0, 4.0, -13.0], ['X4'], [-21.0]] faktor = 2.0 [[6, -2, 2, 4], ['X1'], [16]] [[0.0, -4.0, 2.0, 2.0], ['X2'], [-6.0]] [[0.0, 0.0, 2.0, -5.0], ['X3'], [-9.0]] [[0.0, 0.0, 0.0, -3.0], ['X4'], [-3.0]] [[6, -2, 2, 4], ['X1'], [16]] [[0.0, -4.0, 2.0, 2.0], ['X2'], [-6.0]] [[0.0, 0.0, 2.0, -5.0], ['X3'], [-9.0]] [[0.0, 0.0, 0.0, -3.0], [1.0], [-3.0]] [[6, -2, 2, 4], ['X1'], [16]] [[0.0, -4.0, 2.0, 2.0], ['X2'], [-6.0]] [[0.0, 0.0, 2.0, -5.0], [-2.0], [-9.0]] [[0.0, 0.0, 0.0, -3.0], [1.0], [-3.0]] [[6, -2, 2, 4], ['X1'], [16]] [[0.0, -4.0, 2.0, 2.0], [1.0], [-6.0]] [[0.0, 0.0, 2.0, -5.0], [-2.0], [-9.0]] [[0.0, 0.0, 0.0, -3.0], [1.0], [-3.0]] [[6, -2, 2, 4], [3.0], [16]] [[0.0, -4.0, 2.0, 2.0], [1.0], [-6.0]] [[0.0, 0.0, 2.0, -5.0], [-2.0], [-9.0]] [[0.0, 0.0, 0.0, -3.0], [1.0], [-3.0]] Nilai Variabel yang diperoleh x1 = 3.0 x2 = 1.0 x3 = -2.0 x4 = 1.0 =======================================================","title":"1. Metode Eliminasi Gauss"},{"location":"index/SPL/#2_metode_jacobi","text":"\u200b Metode jacobi merupakan metode untuk menyelesaikan sistem persamaan linear dengan cara melakukan iterasi. Misalkan terdapat 3 persamaan dengan 3 bilangan tak diketahui : a_{11}x_{1}+a_{12}x_{2}+a_{13}x_{3}=b_{1}\\\\a_{21}x_{1}+a_{22}x_{2}+a_{23}x_{3}=b_{2}\\\\a_{31}x_{1}+a_{32}x_{2}+a_{33}x_{3}=b_{3} \u200b Dari sistem persamaan tersebut dengan menggunakan metode jacobi kita dapat menhitung nilai x_{1} dengan menggunakan persamaan pertama. Begitu pula dengan x_{2} dan x_{3} dapat dihitung dengan menggunakan persamaan kedua dan ketiga, sehingga didapat : x_{1} = \\dfrac{b_{1}-a_{12}x_{2}-a_{13}x_{3}}{a_{11}}\\\\x_{2} = \\dfrac{b_{2}-a_{21}x_{1}-a_{23}x_{3}}{a_{22}}\\\\x_{3} = \\dfrac{b_{3}-a_{31}x_{1}-a_{32}x_{2}}{a_{33}} \u200b Sehingga metode jacobi secara umum dapat dituliskan sebagai berikut:[^3] x^{(k+1)}_{i} =\\left( b_{i}-\\sum^{i-1}_{j=1}a_{ij}x^{k}_{j}-\\sum^{n}_{j=i+1}a_{ij}x^{k}_{j} \\right)/a_{ii} Contoh : Selesaikan sistem persamaan linear 4 variabel berikut menggunakan iterasi jacobi. 10a - b + 2c = 6 -a + 11b - c + 3d = 25 2a - b + 10c - d = -11 3b - c + 8d = 15 Jawab : Dari soal diperoleh : 10x_{1}-x_{2}+2x_{3} = 6\\\\ -x{1}+11x_{2}-x_{3}+3x_{4} = 25 \\\\ 2x_{1}-x_{2}+10_{x3}-x_{4}=11\\\\ 3x_{2}-x_{3}+8x_{4} = 15 Sehingga nilai x_{1} hingga x_{4} : x_{1} =(x_{2}-2x_{3}+6)/10\\\\ x_{2} =(x_{1}+x_{3}-3x_{4}+25)/11\\\\ x_{3} =(-2x_{1}+x_{2}+x_{4}-11)/10\\\\ x_{4} =(-3x_{2}+x_{3}+15)/8 Sehingga nilai x_{1} hingga x_{4} pada iterasi ke k dapat dituliskan sebagai berikut : x_{1}^{(k+1)} =(x_{2}^{k}-2x_{3}^{k}+6)/10\\\\ x_{2}^{(k+1)} =(x_{1}^{k}+x_{3}^{k}-3x_{4}^{k}+25)/11\\\\ x_{3}^{(k+1)} =(-2x_{1}^{k}+x_{2}^{k}+x_{4}^{k}-11)/10\\\\ x_{4}^{(k+1)} =(-3x_{2}^{k}+x_{3}^{k}+15)/8 Dan nilai yang diperoleh disajikan dalam tabel berikut : X_{i} K = 1 K = 2 K = 3 K = 4 K = 5 K = 6 K = 7 K = 8 K = 9 K = 10 x_{1} 0,6000 1,0473 0,9326 1,0152 0,9890 1,0032 0,9981 1,0006 0,9997 1,0001 x_{2} 2,2727 1,7159 2,0533 1,9537 2,0114 1,9922 2,0023 1,9987 2.0004 1,9998 x_{3} -1,1000 -0,8052 -1,0493 -0,9681 -1,0103 -0,9945 -1,0020 0,9990 -1,0004 -0,9998 x_{4} -1,8750 0,8852 1,1309 0,9738 1,0214 0,9944 1.0036 0,9989 1,0006 0,9998 Algoritma Metode Jacobi Deklarasikan SPL dalam bentuk matrik Deklarasi nilai X_{i} dari hasil analitik Deklarasi array yang kosong ( K = [ ] ) Buat perulangan untuk menampilkan SPL dalam bentuk matrik Tentukan banyak iterasi ( n ) Buat perulangan untuk membuat nilai awal x_{i} = 0 Buat perulangan bersarang dengan ketentuan : Perulangan pertama sebanyak n inputan untuk menentukan berapa kali melakukan iterasi. Dan menghapus nilai di dalam array kosong( K = [ ] ). Perulangan kedua(di dalam perulangan pertama) sebanyak panjang dari matrik untuk mengambil nilai hasil di dalam matrik. Dan menampung nilai yang dihasilkan dari perulangan ketiga kedalam array kosong . Perulangan ketiga(di dalam perulangan kedua) sebanyak panjang dari matrik untuk mengurangi nilai hasil dengan koefisien yang dikalikan dengan nilai x_{i} dengan mengambil nilai dari matrik. Perulangan keempat(di dalam perulangan pertama) sebanyak panjang matrik untuk mengubah nilai x_{i} dengan nilai yang ditampung di array kosong. Dan menghitung nilai error yang dihasilkan kemudian menampilkan nilai x_{i} dan error yang dihasilkan pada iterasi ke-k. Sehingga source code dari metode jacobi ialah sebagai berikut. Source Code Metode Jacobi matrik = [ [[ 10 , - 1 , 2 , 0 ],[ \"X1\" ],[ 6 ]], [[ - 1 , 11 , - 1 , 3 ],[ \"X2\" ],[ 25 ]], [[ 2 , - 1 , 10 , - 1 ],[ \"X3\" ],[ - 11 ]], [[ 0 , 3 , - 1 , 8 ],[ \"X4\" ],[ 15 ]], ] true = [ 1 , 2 , - 1 , 1 ] K = [] print ( \"Penyelesaiaan Sistem Persamaan Linear Dari\" ) for i in matrik : print ( i ) print ( \"Menggunakan Metode Jacobi\" ) n = int ( input ( \"Masukkan banyak iterasi : \" )) print ( \"=======================================================\" ) print ( \">>>>>>>>>>>>>>>>>>>>- METODE JACOBI -<<<<<<<<<<<<<<<<<<\" ) print ( \"=======================================================\" ) for i in range ( len ( matrik [ 0 ][ 0 ])): matrik [ i ][ 1 ][ 0 ] = 0 for k in range ( n ): for i in range ( len ( matrik )): sum = matrik [ i ][ 2 ][ 0 ] for j in range ( len ( matrik )): if i == j : continue sum = sum - matrik [ i ][ 0 ][ j ] * matrik [ j ][ 1 ][ 0 ] K . append ( sum / matrik [ i ][ 0 ][ i ]) print ( f \"iterasi { k + 1 } \" , ' \\t ' , \"|Xi\" , ' \\t\\t\\t ' , \"|errorXi\" ) for x in range ( len ( matrik )): matrik [ x ][ 1 ][ 0 ] = K [ x ] ea = abs (( true [ x ] - K [ x ]) / true [ x ]) * 100 print ( \"X\" + str ( x + 1 ), ' \\t\\t ' , \"| %.10f |\" % K [ x ], ' \\t ' , \" %.10f \" % ea ) K . clear () print ( \"=======================================================\" ) Dan output yang dihasilkan sebagai berikut. Penyelesaiaan Sistem Persamaan Linear Dari [[10, -1, 2, 0], ['X1'], [6]] [[-1, 11, -1, 3], ['X2'], [25]] [[2, -1, 10, -1], ['X3'], [-11]] [[0, 3, -1, 8], ['X4'], [15]] Menggunakan Metode Jacobi Masukkan banyak iterasi : 10 ======================================================= >>>>>>>>>>>>>>>>>>>>- METODE JACOBI -<<<<<<<<<<<<<<<<<< ======================================================= iterasi 1 |Xi |errorXi X1 |0.6000000000| 40.0000000000 X2 |2.2727272727| 13.6363636364 X3 |-1.1000000000| 10.0000000000 X4 |1.8750000000| 87.5000000000 iterasi 2 |Xi |errorXi X1 |1.0472727273| 4.7272727273 X2 |1.7159090909| 14.2045454545 X3 |-0.8052272727| 19.4772727273 X4 |0.8852272727| 11.4772727273 iterasi 3 |Xi |errorXi X1 |0.9326363636| 6.7363636364 X2 |2.0533057851| 2.6652892562 X3 |-1.0493409091| 4.9340909091 X4 |1.1308806818| 13.0880681818 iterasi 4 |Xi |errorXi X1 |1.0151987603| 1.5198760331 X2 |1.9536957645| 2.3152117769 X3 |-0.9681086260| 3.1891373967 X4 |0.9738427169| 2.6157283058 iterasi 5 |Xi |errorXi X1 |0.9889913017| 1.1008698347 X2 |2.0114147258| 0.5707362885 X3 |-1.0102859039| 1.0285903926 X4 |1.0213505101| 2.1350510072 iterasi 6 |Xi |errorXi X1 |1.0031986534| 0.3198653362 X2 |1.9922412607| 0.3879369659 X3 |-0.9945217367| 0.5478263254 X4 |0.9944337398| 0.5566260154 iterasi 7 |Xi |errorXi X1 |0.9981284734| 0.1871526582 X2 |2.0023068816| 0.1153440776 X3 |-1.0019722306| 0.1972230620 X4 |1.0035943102| 0.3594310151 iterasi 8 |Xi |errorXi X1 |1.0006251343| 0.0625134279 X2 |1.9986703011| 0.0664849439 X3 |-0.9990355755| 0.0964424487 X4 |0.9988883906| 0.1111609410 iterasi 9 |Xi |errorXi X1 |0.9996741452| 0.0325854785 X2 |2.0004476715| 0.0223835773 X3 |-1.0003691577| 0.0369157685 X4 |1.0006191901| 0.0619190140 iterasi 10 |Xi |errorXi X1 |1.0001185987| 0.0118598691 X2 |1.9997679470| 0.0116026495 X3 |-0.9998281429| 0.0171857126 X4 |0.9997859785| 0.0214021540 =======================================================","title":"2. Metode Jacobi"},{"location":"index/SPL/#3_metode_gauss_seidel","text":"\u200b Metode Gauss Seidel merupakan metode penyelesaian sistem persamaan linear yang hampir sama dengan metode jacobi. Hanya saja di dalam metode jacobi nilai x_{1} yang didapat dari persamaan pertama tidak digunakan untuk menghitung nilai x_{2} dengan menggunakan persamaan kedua. Demikian halnya dengan nilai x_{2} tidak digunakan untuk mencari nilai x_{3} , begitu seterusnya. 2 Sedangkan didalam metode Gauss Seidel nilai x_{1} yang diperoleh dari persamaan sebelumnya akan dipakai untuk mencari nilai x_{2} begitupun seterusnya. Sehingga dapat disimpulkan metode Jacobi tidak menggunakan nilai yang terbaru sedangkan metode Gauss Seidel menggunakan nilai yang terbaru. \u200b Sehingga bentuk metoode Gauss Seidel secara umum dapat dituliskan sebagai berikut:[^3] x^{(k+1)}_{i} =\\left( b_{i}-\\sum^{i-1}_{j=1}a_{ij}x^{(k+1)}_{j}-\\sum^{n}_{j=i+1}a_{ij}x^{k}_{j} \\right)/a_{ii} Contoh : Selesaikan sistem persamaan linear 4 variabel berikut menggunakan iterasi Gauss Seidel. 10a - b + 2c = 6 -a + 11b - c + 3d = 25 2a - b + 10c - d = -11 3b - c + 8d = 15 Jawab : Dari soal diperoleh : 10x_{1}-x_{2}+2x_{3} = 6\\\\ -x{1}+11x_{2}-x_{3}+3x_{4} = 25 \\\\ 2x_{1}-x_{2}+10_{x3}-x_{4}=11\\\\ 3x_{2}-x_{3}+8x_{4} = 15 Sehingga nilai x_{1} hingga x_{4} : x_{1} =(x_{2}-2x_{3}+6)/10\\\\ x_{2} =(x_{1}+x_{3}-3x_{4}+25)/11\\\\ x_{3} =(-2x_{1}+x_{2}+x_{4}-11)/10\\\\ x_{4} =(-3x_{2}+x_{3}+15)/8 Sehingga nilai x_{1} hingga x_{4} pada iterasi ke k dapat dituliskan sebagai berikut : x_{1}^{(k+1)} =(x_{2}^{k}-2x_{3}^{k}+6)/10\\\\ x_{2}^{(k+1)} =(x_{1}^{(k+1)}+x_{3}^{k}-3x_{4}^{k}+25)/11\\\\ x_{3}^{(k+1)} =(-2x_{1}^{(k+1)}+x_{2}^{(k+1)}+x_{4}^{k}-11)/10\\\\ x_{4}^{(k+1)} =(-3x_{2}^{(k+1)}+x_{3}^{(k+1)}+15)/8 Dan nilai yang diperoleh disajikan dalam tabel berikut : K = 1 K = 2 K = 3 K = 4 K = 5 x_{1} 0,6000 1,0302 1,0066 1,0009 1,0001 x_{2} 2,3273 2,0369 2,0036 2,0003 2,0000 x_{3} -0,9873 -1,0145 -1,0025 -1,0003 -1,0000 x_{4} 0,8789 0,9843 0,9984 0,9998 1,0000 Algoritma Metode Jacobi Deklarasikan SPL dalam bentuk matrik Deklarasi nilai X_{i} dari hasil analitik Buat perulangan untuk menampilkan SPL dalam bentuk matrik Tentukan banyak iterasi ( n ) Buat perulangan untuk membuat nilai awal x_{i} = 0 Buat perulangan bersarang dengan ketentuan : Perulangan pertama sebanyak n inputan untuk menentukan berapa kali melakukan iterasi. Perulangan kedua(di dalam perulangan pertama) sebanyak panjang dari matrik untuk mengambil nilai hasil di dalam matrik. Dan mengubah nilai x_{i} menjadi nilai yang dihasilkan dari perulangan ketiga. Perulangan ketiga(di dalam perulangan kedua) sebanyak panjang dari matrik untuk mengurangi nilai hasil dengan koefisien yang dikalikan dengan nilai x_{i} dengan mengambil nilai dari matrik. Perulangan keempat(di dalam perulangan pertama) sebanyak panjang matrik untuk menghitung nilai error yang dihasilkan kemudian menampilkan nilai x_{i} dan error yang dihasilkan pada iterasi ke-k. Sehingga source code dari metode Gauss Seidel ialah sebagai berikut. Source Code Metode Gauss Seidel matrik = [ [[ 10 , - 1 , 2 , 0 ],[ \"X1\" ],[ 6 ]], [[ - 1 , 11 , - 1 , 3 ],[ \"X2\" ],[ 25 ]], [[ 2 , - 1 , 10 , - 1 ],[ \"X3\" ],[ - 11 ]], [[ 0 , 3 , - 1 , 8 ],[ \"X4\" ],[ 15 ]], ] true = [ 1 , 2 , - 1 , 1 ] print ( \"Penyelesaiaan Sistem Persamaan Linear Dari\" ) for i in matrik : print ( i ) print ( \"Menggunakan Metode Gauss Seidel\" ) n = int ( input ( \"Masukkan banyak iterasi : \" )) print ( \"=======================================================\" ) print ( \">>>>>>>>>>>>>>>>>- METODE GAUSS SEIDEL -<<<<<<<<<<<<<<<\" ) print ( \"=======================================================\" ) for i in range ( len ( matrik [ 0 ][ 0 ])): matrik [ i ][ 1 ][ 0 ] = 0 for k in range ( n ): for i in range ( len ( matrik )): Xi = matrik [ i ][ 1 ][ 0 ] sum = matrik [ i ][ 2 ][ 0 ] for j in range ( len ( matrik )): if j == i : continue sum = sum - matrik [ i ][ 0 ][ j ] * matrik [ j ][ 1 ][ 0 ] matrik [ i ][ 1 ][ 0 ] = sum / matrik [ i ][ 0 ][ i ] print ( f \"iterasi { k + 1 } \" , ' \\t ' , \"|Xi\" , ' \\t\\t\\t ' , \"|errorXi\" ) for x in range ( len ( matrik )): ea = abs (( matrik [ x ][ 1 ][ 0 ] - true [ x ]) / true [ x ]) * 100 print ( \"X\" + str ( x + 1 ), ' \\t\\t ' , \"| %.10f |\" % matrik [ x ][ 1 ][ 0 ], ' \\t ' , \" %.10f \" % ea ) print ( \"=======================================================\" ) Dan hasil ouput dari source code tersebut ialah sebagai berikut. Penyelesaiaan Sistem Persamaan Linear Dari [[10, -1, 2, 0], ['X1'], [6]] [[-1, 11, -1, 3], ['X2'], [25]] [[2, -1, 10, -1], ['X3'], [-11]] [[0, 3, -1, 8], ['X4'], [15]] Menggunakan Metode Gauss Seidel Masukkan banyak iterasi : 5 ======================================================= >>>>>>>>>>>>>>>>>- METODE GAUSS SEIDEL -<<<<<<<<<<<<<<< ======================================================= iterasi 1 |Xi |errorXi X1 |0.6000000000| 40.0000000000 X2 |2.3272727273| 16.3636363636 X3 |-0.9872727273| 1.2727272727 X4 |0.8788636364| 12.1136363636 iterasi 2 |Xi |errorXi X1 |1.0301818182| 3.0181818182 X2 |2.0369380165| 1.8469008264 X3 |-1.0144561983| 1.4456198347 X4 |0.9843412190| 1.5658780992 iterasi 3 |Xi |errorXi X1 |1.0065850413| 0.6585041322 X2 |2.0035550169| 0.1777508452 X3 |-1.0025273847| 0.2527384673 X4 |0.9983509456| 0.1649054423 iterasi 4 |Xi |errorXi X1 |1.0008609786| 0.0860978625 X2 |2.0002982507| 0.0149125328 X3 |-1.0003072761| 0.0307276102 X4 |0.9998497465| 0.0150253509 iterasi 5 |Xi |errorXi X1 |1.0000912803| 0.0091280286 X2 |2.0000213422| 0.0010671123 X3 |-1.0000311472| 0.0031147183 X4 |0.9999881033| 0.0011896740 =======================================================","title":"3. Metode Gauss Seidel"},{"location":"index/SPL/#referensi","text":"https://id.m.wikipedia.org/wiki/Sistem_persamaan_linear \u21a9 https://www.slideshare.net/KhannalPakinde/makalah-metode-numerik-sistem-persamaan-linear \u21a9 \u21a9 \u21a9 \u21a9 \u21a9","title":"Referensi"}]}